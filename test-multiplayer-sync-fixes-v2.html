<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Sync Fixes Test Interface v2</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.3);
            padding: 30px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        
        h1 {
            text-align: center;
            color: #4ecdc4;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .section {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .section h2 {
            color: #ff6b6b;
            margin-top: 0;
            border-bottom: 2px solid #ff6b6b;
            padding-bottom: 10px;
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
        }
        
        button {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            background: linear-gradient(45deg, #44a08d, #4ecdc4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .danger {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52) !important;
        }
        
        .danger:hover {
            background: linear-gradient(45deg, #ee5a52, #ff6b6b) !important;
        }
        
        .success {
            background: linear-gradient(45deg, #51cf66, #40c057) !important;
        }
        
        .success:hover {
            background: linear-gradient(45deg, #40c057, #51cf66) !important;
        }
        
        input[type="text"] {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            margin: 5px;
            min-width: 200px;
        }
        
        input[type="text"]::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        .status {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .card h3 {
            color: #4ecdc4;
            margin-top: 0;
        }
        
        .highlight {
            background: rgba(255, 235, 59, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            color: #fff59d;
        }
        
        .error {
            color: #ff6b6b;
        }
        
        .success-text {
            color: #51cf66;
        }
        
        .warning {
            color: #ffd93d;
        }
        
        .info {
            background: rgba(33, 150, 243, 0.2);
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #4ecdc4;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            overflow: hidden;
        }
        
        .results-table th,
        .results-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .results-table th {
            background: rgba(255, 255, 255, 0.1);
            color: #4ecdc4;
            font-weight: bold;
        }
        
        .results-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîß Multiplayer Sync Fixes Test Interface v2</h1>
        
        <div class="info">
            <strong>üéØ Purpose:</strong> This interface helps test and verify the comprehensive multiplayer synchronization fixes including:
            <ul>
                <li><strong>Token Rendering:</strong> Fixes tokens appearing as circles instead of proper images</li>
                <li><strong>Turn Validation:</strong> Prevents development prompts when it's not player's turn</li>
                <li><strong>Firebase Conversion:</strong> Fixes array conversion filtering out valid player data</li>
                <li><strong>Player Synchronization:</strong> Ensures consistent player states across clients</li>
            </ul>
        </div>
        
        <div class="section">
            <h2>üè† Room Configuration</h2>
            <div class="button-group">
                <input type="text" id="roomId" placeholder="Enter Room ID (e.g., CRYSTAL_LAKE)" value="">
                <button onclick="setCurrentRoom()">Set Current Room</button>
                <button onclick="debugCurrentRoom()" class="success">Debug Current Room</button>
            </div>
            <div id="roomStatus" class="status"></div>
        </div>
        
        <div class="grid">
            <div class="card">
                <h3>üéØ Token Rendering Tests</h3>
                <div class="button-group">
                    <button onclick="testTokenRendering()">Test Token Rendering</button>
                    <button onclick="forceTokenReload()" class="success">Force Token Reload</button>
                </div>
                <div id="tokenResults" class="status"></div>
            </div>
            
            <div class="card">
                <h3>üö´ Turn Validation Tests</h3>
                <div class="button-group">
                    <button onclick="testTurnValidation()">Test Turn Validation</button>
                    <button onclick="simulateWrongTurn()" class="warning">Simulate Wrong Turn</button>
                </div>
                <div id="turnResults" class="status"></div>
            </div>
            
            <div class="card">
                <h3>üîÑ Firebase Conversion Tests</h3>
                <div class="button-group">
                    <button onclick="testFirebaseConversion()">Test Conversion</button>
                    <button onclick="testPlayerFiltering()">Test Player Filtering</button>
                </div>
                <div id="firebaseResults" class="status"></div>
            </div>
            
            <div class="card">
                <h3>üîÑ Player Sync Tests</h3>
                <div class="button-group">
                    <button onclick="testPlayerSync()">Test Player Sync</button>
                    <button onclick="checkPlayerData()">Check Player Data</button>
                </div>
                <div id="syncResults" class="status"></div>
            </div>
        </div>
        
        <div class="section">
            <h2>üß™ Comprehensive Testing</h2>
            <div class="button-group">
                <button onclick="runComprehensiveTest()" class="success">Run All Tests</button>
                <button onclick="autoFixIssues()" class="danger">Auto-Fix Issues</button>
                <button onclick="clearAllResults()">Clear Results</button>
            </div>
            <div id="comprehensiveResults" class="status"></div>
        </div>
        
        <div class="section">
            <h2>üìä Live Monitoring</h2>
            <div class="button-group">
                <button onclick="startMonitoring()" class="success">Start Monitoring</button>
                <button onclick="stopMonitoring()" class="danger">Stop Monitoring</button>
                <button onclick="takeSnapshot()">Take Snapshot</button>
            </div>
            <div id="monitoringResults" class="status"></div>
        </div>
    </div>

    <!-- Load the fix utilities -->
    <script src="fix-multiplayer-sync-comprehensive-v2.js"></script>
    
    <script>
        let currentRoomId = '';
        let monitoringInterval = null;
        
        // Utility functions
        function log(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : type === 'success' ? 'success-text' : type === 'warning' ? 'warning' : '';
            element.innerHTML += `<div class="${className}">[${timestamp}] ${message}</div>`;
            element.scrollTop = element.scrollHeight;
        }
        
        function clearLog(elementId) {
            document.getElementById(elementId).innerHTML = '';
        }
        
        function showLoading(elementId, message) {
            const element = document.getElementById(elementId);
            element.innerHTML += `<div><span class="loading"></span>${message}</div>`;
            element.scrollTop = element.scrollHeight;
        }
        
        // Room management
        function setCurrentRoom() {
            const roomInput = document.getElementById('roomId');
            currentRoomId = roomInput.value.trim().toUpperCase();
            if (currentRoomId) {
                log('roomStatus', `Room set to: ${currentRoomId}`, 'success');
            } else {
                log('roomStatus', 'Please enter a valid room ID', 'error');
            }
        }
        
        async function debugCurrentRoom() {
            if (!currentRoomId) {
                log('roomStatus', 'Please set a room ID first', 'error');
                return;
            }
            
            showLoading('roomStatus', 'Debugging room...');
            
            try {
                const result = await debugMultiplayerRoom(currentRoomId);
                if (result) {
                    log('roomStatus', 'Room debug completed - check console for details', 'success');
                } else {
                    log('roomStatus', 'Room not found or error occurred', 'error');
                }
            } catch (error) {
                log('roomStatus', `Error debugging room: ${error.message}`, 'error');
            }
        }
        
        // Token rendering tests
        async function testTokenRendering() {
            showLoading('tokenResults', 'Testing token rendering...');
            
            try {
                const results = await multiplayerSyncDebug.testTokenRendering(currentRoomId);
                if (results && results.length > 0) {
                    log('tokenResults', `Found ${results.length} players:`, 'success');
                    results.forEach(player => {
                        const status = player.status === 'has_image' ? '‚úÖ' : 
                                     player.status === 'needs_loading' ? '‚è≥' : 'üî¥';
                        log('tokenResults', `${status} ${player.name}: ${player.status} (${player.color})`);
                    });
                } else {
                    log('tokenResults', 'No players found or error occurred', 'warning');
                }
            } catch (error) {
                log('tokenResults', `Error testing tokens: ${error.message}`, 'error');
            }
        }
        
        async function forceTokenReload() {
            showLoading('tokenResults', 'Force reloading all tokens...');
            
            try {
                const results = await multiplayerSyncDebug.forceTokenReload();
                if (results && results.length > 0) {
                    log('tokenResults', 'Token reload completed:', 'success');
                    results.forEach(result => {
                        const status = result.status === 'loaded' ? '‚úÖ' : 
                                     result.status === 'failed' ? '‚ùå' : '‚ö†Ô∏è';
                        log('tokenResults', `${status} ${result.player}: ${result.status}`);
                    });
                } else {
                    log('tokenResults', 'No tokens to reload', 'warning');
                }
            } catch (error) {
                log('tokenResults', `Error reloading tokens: ${error.message}`, 'error');
            }
        }
        
        // Turn validation tests
        function testTurnValidation() {
            showLoading('turnResults', 'Testing turn validation...');
            
            try {
                multiplayerSyncDebug.testTurnValidation();
                log('turnResults', 'Turn validation test completed - check console for details', 'success');
            } catch (error) {
                log('turnResults', `Error testing turn validation: ${error.message}`, 'error');
            }
        }
        
        function simulateWrongTurn() {
            log('turnResults', 'Simulating wrong turn scenario...', 'warning');
            
            // Try to trigger property info panel when it's not the player's turn
            if (window.updateInfoPanelInternal) {
                try {
                    // This should be blocked by turn validation
                    window.updateInfoPanelInternal();
                    log('turnResults', 'Wrong turn simulation completed - check if UI was blocked', 'info');
                } catch (error) {
                    log('turnResults', `Error in simulation: ${error.message}`, 'error');
                }
            } else {
                log('turnResults', 'updateInfoPanelInternal function not found', 'warning');
            }
        }
        
        // Firebase conversion tests
        async function testFirebaseConversion() {
            if (!currentRoomId) {
                log('firebaseResults', 'Please set a room ID first', 'error');
                return;
            }
            
            showLoading('firebaseResults', 'Testing Firebase conversion...');
            
            try {
                await multiplayerSyncDebug.testFirebaseConversion(currentRoomId);
                log('firebaseResults', 'Firebase conversion test completed - check console for details', 'success');
            } catch (error) {
                log('firebaseResults', `Error testing Firebase conversion: ${error.message}`, 'error');
            }
        }
        
        function testPlayerFiltering() {
            log('firebaseResults', 'Testing player filtering logic...', 'info');
            
            // Create test player data with various scenarios
            const testPlayers = [
                { name: 'ValidPlayer', userId: 'user123', money: 1500 },
                { name: 'undefined', userId: 'user456', properties: [] },
                { name: 'PartialPlayer', tokenImage: 'assets/images/t1.png' },
                { displayName: 'DisplayOnly', color: '#ff0000' },
                { name: null, userId: null },
                { name: 'undefined', userId: 'undefined' }
            ];
            
            log('firebaseResults', 'Testing with sample player data:', 'info');
            
            testPlayers.forEach((player, index) => {
                const hasValidName = player.name && player.name !== 'undefined' && player.name !== 'null';
                const hasValidUserId = player.userId && player.userId !== 'undefined' && player.userId !== 'null';
                const hasDisplayName = player.displayName && player.displayName !== 'undefined';
                const hasPlayerProperties = player.hasOwnProperty('money') || 
                                          player.hasOwnProperty('properties') || 
                                          player.hasOwnProperty('tokenImage') ||
                                          player.hasOwnProperty('color');
                
                const wouldPass = hasValidName || hasValidUserId || hasDisplayName || hasPlayerProperties;
                const status = wouldPass ? '‚úÖ PASS' : '‚ùå FILTERED';
                
                log('firebaseResults', `Player ${index + 1}: ${status} - ${JSON.stringify(player)}`);
            });
        }
        
        // Player sync tests
        function testPlayerSync() {
            showLoading('syncResults', 'Testing player synchronization...');
            
            try {
                const results = multiplayerSyncDebug.testPlayerSync();
                if (results && results.length > 0) {
                    log('syncResults', `Analyzed ${results.length} players:`, 'success');
                    results.forEach(player => {
                        const issues = [];
                        if (!player.name || player.name === 'undefined') issues.push('name');
                        if (!player.userId || player.userId === 'undefined') issues.push('userId');
                        if (player.tokenIndex === undefined) issues.push('tokenIndex');
                        if (!player.color) issues.push('color');
                        
                        const status = issues.length === 0 ? '‚úÖ' : '‚ö†Ô∏è';
                        const issueText = issues.length > 0 ? ` (missing: ${issues.join(', ')})` : '';
                        log('syncResults', `${status} ${player.name || 'Unknown'}: ${player.properties} properties, $${player.money}${issueText}`);
                    });
                } else {
                    log('syncResults', 'No players found to analyze', 'warning');
                }
            } catch (error) {
                log('syncResults', `Error testing player sync: ${error.message}`, 'error');
            }
        }
        
        function checkPlayerData() {
            log('syncResults', 'Checking current player data...', 'info');
            
            if (window.players && Array.isArray(window.players)) {
                log('syncResults', `Found ${window.players.length} players in memory`, 'success');
                
                window.players.forEach((player, index) => {
                    log('syncResults', `Player ${index + 1}: ${player.name || 'Unknown'} (${player.userId || 'No ID'})`);
                });
            } else {
                log('syncResults', 'No players array found in window object', 'warning');
            }
            
            // Check game state
            const gameState = {
                isMultiplayer: window.isMultiplayerGame || false,
                currentPlayerIndex: window.currentPlayerIndex || 0,
                localPlayerName: window.localPlayerName || 'Unknown'
            };
            
            log('syncResults', `Game state: ${JSON.stringify(gameState)}`, 'info');
        }
        
        // Comprehensive testing
        async function runComprehensiveTest() {
            clearLog('comprehensiveResults');
            showLoading('comprehensiveResults', 'Running comprehensive test suite...');
            
            try {
                const results = await multiplayerSyncDebug.runComprehensiveTest(currentRoomId);
                
                log('comprehensiveResults', 'üß™ Comprehensive test completed!', 'success');
                log('comprehensiveResults', `Timestamp: ${results.timestamp}`, 'info');
                
                if (results.tokenRendering) {
                    const tokenIssues = results.tokenRendering.filter(p => p.status !== 'has_image').length;
                    log('comprehensiveResults', `Token Rendering: ${tokenIssues} issues found`, tokenIssues === 0 ? 'success' : 'warning');
                }
                
                if (results.playerSync) {
                    const syncIssues = results.playerSync.filter(p => !p.name || !p.userId || !p.color).length;
                    log('comprehensiveResults', `Player Sync: ${syncIssues} issues found`, syncIssues === 0 ? 'success' : 'warning');
                }
                
                log('comprehensiveResults', 'Check console for detailed results', 'info');
                
            } catch (error) {
                log('comprehensiveResults', `Error in comprehensive test: ${error.message}`, 'error');
            }
        }
        
        async function autoFixIssues() {
            showLoading('comprehensiveResults', 'Running automatic fixes...');
            
            try {
                const fixCount = await multiplayerSyncDebug.autoFix(currentRoomId);
                log('comprehensiveResults', `Auto-fix completed: ${fixCount} fixes applied`, 'success');
                
                // Run a quick test to verify fixes
                setTimeout(() => {
                    testPlayerSync();
                    testTokenRendering();
                }, 1000);
                
            } catch (error) {
                log('comprehensiveResults', `Error in auto-fix: ${error.message}`, 'error');
            }
        }
        
        // Monitoring
        function startMonitoring() {
            if (monitoringInterval) {
                log('monitoringResults', 'Monitoring already running', 'warning');
                return;
            }
            
            log('monitoringResults', 'Starting live monitoring...', 'success');
            
            monitoringInterval = setInterval(() => {
                const timestamp = new Date().toLocaleTimeString();
                
                // Check player count
                const playerCount = window.players ? window.players.length : 0;
                
                // Check current turn
                const currentTurn = window.currentPlayerIndex || 0;
                const currentPlayerName = window.players && window.players[currentTurn] ? 
                                        window.players[currentTurn].name : 'Unknown';
                
                // Check multiplayer status
                const isMultiplayer = window.isMultiplayerGame || false;
                
                log('monitoringResults', 
                    `[${timestamp}] Players: ${playerCount}, Turn: ${currentPlayerName} (${currentTurn}), MP: ${isMultiplayer}`, 
                    'info');
                
            }, 5000); // Every 5 seconds
        }
        
        function stopMonitoring() {
            if (monitoringInterval) {
                clearInterval(monitoringInterval);
                monitoringInterval = null;
                log('monitoringResults', 'Monitoring stopped', 'warning');
            } else {
                log('monitoringResults', 'No monitoring to stop', 'info');
            }
        }
        
        function takeSnapshot() {
            const timestamp = new Date().toLocaleString();
            log('monitoringResults', `üì∏ Snapshot taken at ${timestamp}:`, 'info');
            
            const snapshot = {
                players: window.players ? window.players.length : 0,
                currentTurn: window.currentPlayerIndex || 0,
                isMultiplayer: window.isMultiplayerGame || false,
                localPlayer: window.localPlayerName || 'Unknown',
                roomId: currentRoomId || 'Not set'
            };
            
            Object.entries(snapshot).forEach(([key, value]) => {
                log('monitoringResults', `  ${key}: ${value}`, 'info');
            });
        }
        
        // Clear functions
        function clearAllResults() {
            ['roomStatus', 'tokenResults', 'turnResults', 'firebaseResults', 'syncResults', 'comprehensiveResults', 'monitoringResults'].forEach(clearLog);
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            log('roomStatus', 'Test interface loaded successfully', 'success');
            log('roomStatus', 'Enter a room ID and click "Set Current Room" to begin testing', 'info');
        });
    </script>
</body>
</html>

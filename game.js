import { renderBoard, loadTokens, renderTokens, updateFrame, setPlayers, setEyePositions, setDoublesState, setPositionsMap } from './game_utils.js';
import { initFirebaseHorropoly, createGameRoom, joinGameRoom, subscribeToGameState, updateGameState, disconnectFromGame, findAvailableRooms, findAllRoomsDebug, getDoc, doc, updatePlayerData, updatePropertyState, syncCompleteGameState, startGameWithInitialization, ensureGameRoomConnection } from './firebase-init.js';

// Game state variables
let canvas = null;
let ctx = null; // Add canvas context variable
let players = [];
let currentPlayerIndex = 0;
let isAITurn = false;
let isRecordingEyes = false;
let eyePositions = { left: { x: 856, y: 94 }, right: { x: 896, y: 91 } };
let lastRollWasDoubles = false;
let consecutiveDoublesCount = 0;
let die1Element;
let die2Element;
let autoRollTimeout = null;
let autoActionTimeout = null;
let updateInfoPanelTimeout = null;
let eyeAnimationFrame = null;
let eyeAnimationStartTime = null;
let boardImage = null;
let backgroundImage = null; // Internal background layer behind the main board
let outerBackgroundImage = null; // Outer background layer (furthest back)
let graveImage = null; // Legacy - keeping for compatibility
let grave1Image = null;
let grave2Image = null;
let grave3Image = null;
let grave4Image = null;
let cryptImage = null;
let cryptRedImage = null;
let cryptBlueImage = null;
let cryptGreenImage = null;
let cryptYellowImage = null;
let cryptWhiteImage = null;
let graveImageLoaded = false; // Legacy - keeping for compatibility
let grave1ImageLoaded = false;
let grave2ImageLoaded = false;
let grave3ImageLoaded = false;
let grave4ImageLoaded = false;
let cryptImageLoaded = false;
let cryptRedImageLoaded = false;
let cryptBlueImageLoaded = false;
let cryptGreenImageLoaded = false;
let cryptYellowImageLoaded = false;
let cryptWhiteImageLoaded = false;
let positionsMap = null;
let backgroundMusic = null;
let isMusicPlaying = false;
let gameMode = null; // 'ai' or 'multiplayer'
let isInitialRoll = true; // Add this variable
let isMultiplayerGame = false; // Track if we're in a multiplayer game
let isGameInitialized = false; // Track if game is fully initialized
let isInitializing = false; // Track if initialization is in progress
let isGameOver = false; // Flag to indicate game has ended
let isMobile = false; // Mobile detection flag

// Multiplayer UI elements
let createRoomBtn;
let joinRoomBtn;
let roomIdInput;
let roomCode;
let roomList;
let playerList;

// Steal card system variables
let gojailGlowActive = false;
let gojailGlowTimeout = null;
let nextGojailGlowTime = null;
let witchFaceImage = null; // Witch face image for gojail glow effect
let gojailGlowPlayersReceived = new Set(); // Track players who already received steal cards this glow event

// Shaking graves system variables
let gojailGravesShaking = false;
let gojailGravesShakeTimeout = null;
let nextGojailGravesShakeTime = null;

// Highlight for stolen properties
let stolenPropertyPulse = null;
let stolenPulseInterval = null;

// Track ongoing token animations for smoother remote movement
let tokenAnimations = {};

// Snake path money system
let snakePathMoney = {};
let snakePathMoneyTimer = null;
let nextMoneySpawnTime = 0;

// Lightning system variables
let lightningTimer = null;
let lightningActive = false;
let lightningInterval = 70000; // 70 seconds in milliseconds
let lastProcessedLightningTs = 0; // Prevent duplicate rendering of the same broadcast

// Snake path lightning-bolt prize system
let snakePathBoltTimer = null;
let isBoltTargetingMode = false;

// Lightning bolt icon for snake path prize (optional image; falls back to emoji)
let lightningBoltImage = null;
let lightningBoltImageLoaded = false;

// Global compatibility shims for external fix scripts that may load early
try {
    if (typeof window !== 'undefined') {
        if (!window.handleDiceClick) {
            window.handleDiceClick = function(origin = 'shim') {
                try {
                    // Prefer main flow
                    if (typeof triggerDiceRoll === 'function') {
                        triggerDiceRoll();
                    } else if (typeof handleDiceClick === 'function' && handleDiceClick !== window.handleDiceClick) {
                        // If the real handler exists later, delegate
                        handleDiceClick(origin);
                    } else {
                        console.warn('handleDiceClick shim active but core roll function not ready');
                    }
                } catch (e) {
                    console.warn('handleDiceClick shim error:', e?.message || e);
                }
            };
        }
        if (!window.triggerLightningStrike) {
            window.triggerLightningStrike = function() {
                try {
                    // If an immediate enhanced trigger exists, use it
                    if (typeof enhancedTriggerLightningStrike === 'function') {
                        enhancedTriggerLightningStrike();
                        return;
                    }
                    // If a direct trigger exists, call it
                    if (typeof triggerLightningStrike === 'function' && triggerLightningStrike !== window.triggerLightningStrike) {
                        triggerLightningStrike();
                        return;
                    }
                    // Fallback: schedule next strike soon if scheduler exists
                    if (typeof scheduleLightningStrike === 'function') {
                        scheduleLightningStrike();
                    } else {
                        console.warn('triggerLightningStrike shim active but no lightning functions available');
                    }
                } catch (e) {
                    console.warn('triggerLightningStrike shim error:', e?.message || e);
                }
            };
        }
    }
} catch (_) {}

// Blue mist animation state (over b1-b9)
let blueMistStartTime = Date.now();
let blueMistEnabled = true;

// Draw animated blue mist across b1-b9 (above board, below tokens)
function drawBlueMist(ctx) {
    try {
        if (!blueMistEnabled || !positionsMap) return;
        const mistSquares = ['b1','b2','b3','b4','b5','b6','b7','b8','b9'];
        const points = mistSquares.map(sq => positionsMap?.get(sq)).filter(Boolean);
        if (!points || points.length === 0) return;
        
        // Compute bounding box around b1-b9 and add generous padding
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (const p of points) {
            if (p.x < minX) minX = p.x;
            if (p.y < minY) minY = p.y;
            if (p.x > maxX) maxX = p.x;
            if (p.y > maxY) maxY = p.y;
        }
        const padding = 80;
        const originX = minX - padding;
        const originY = minY - padding;
        const width = (maxX - minX) + padding * 2;
        const height = (maxY - minY) + padding * 2;
        
        // Time-based motion
        const t = (Date.now() - blueMistStartTime) / 1000;
        
        ctx.save();
        // Subtle overall drift
        ctx.translate(Math.sin(t * 0.25) * 8, Math.cos(t * 0.18) * 5);
        
        // Blend softly with scene
        const prevComp = ctx.globalCompositeOperation;
        ctx.globalCompositeOperation = 'lighter';
        
        // Layer multiple moving radial gradients to simulate flowing mist
        const layers = 4;
        for (let i = 0; i < layers; i++) {
            const phase = t * (0.12 + i * 0.03) + i * 1.3;
            const cx = originX + width * (0.2 + 0.6 * (0.5 + 0.5 * Math.sin(phase)));
            const cy = originY + height * (0.2 + 0.6 * (0.5 + 0.5 * Math.cos(phase * 0.9)));
            const r = Math.max(width, height) * (0.35 + 0.1 * Math.sin(phase * 0.7 + 1.7));
            
            const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
            // Soft blue tones with varying alpha
            grad.addColorStop(0.0, 'rgba(90, 170, 255, 0.10)');
            grad.addColorStop(0.4, 'rgba(70, 150, 245, 0.08)');
            grad.addColorStop(0.75, 'rgba(60, 130, 235, 0.05)');
            grad.addColorStop(1.0, 'rgba(60, 130, 235, 0.00)');
            
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.ellipse(cx, cy, r, r * 0.6, Math.sin(phase) * 0.6, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Gentle horizontal flow band across the region
        const bandOffset = (t * 20) % (width * 2);
        const bandGrad = ctx.createLinearGradient(originX + bandOffset - width, originY, originX + bandOffset, originY);
        bandGrad.addColorStop(0.0, 'rgba(120, 190, 255, 0.00)');
        bandGrad.addColorStop(0.5, 'rgba(120, 190, 255, 0.08)');
        bandGrad.addColorStop(1.0, 'rgba(120, 190, 255, 0.00)');
        ctx.fillStyle = bandGrad;
        ctx.fillRect(originX, originY, width, height);
        
        ctx.globalCompositeOperation = prevComp;
        ctx.restore();
    } catch (e) {
        console.warn('Blue mist draw failed:', e?.message || e);
    }
}
// Determine the current lightning host (first active, non-bankrupt player still in game)
function getLightningHostName() {
    try {
        if (!Array.isArray(players) || players.length === 0) return null;
        const candidates = players.filter(p => p && !p.bankrupt && p.activeInGame !== false && !p.removedFromGame);
        if (candidates.length > 0 && candidates[0].name) return candidates[0].name;
        // Fallback: first player with a name
        const firstNamed = players.find(p => p && p.name);
        return firstNamed ? firstNamed.name : null;
    } catch (_) {
        return null;
    }
}



// Flag to track if a player is currently moving (to prevent showing property buttons during movement)
let isPlayerMoving = false;
// Flag to prevent multiple dice rolls from overlapping
let isDiceRollInProgress = false;
let isDiceClickHandlerRunning = false;

// Enhanced dice click protection system
let lastDiceClickTime = 0;
let diceClickCount = 0;
let turnInProgress = false;
const DICE_CLICK_COOLDOWN = 1000; // 1 second minimum between dice clicks
// Tablet/touch duplicate suppression
let suppressNextMouseClickUntil = 0; // epoch ms until which mouse/click is ignored after touch
const DUPLICATE_CLICK_WINDOW_MS = 350; // tighter window to ignore duplicate triggers
const MAX_DICE_CLICKS_PER_TURN = 1; // Only allow 1 dice click per turn (except doubles)

// Development Deadlock Fix - Applied at game initialization
function applyDevelopmentDeadlockFix() {
    console.log('ðŸ—ï¸ Applying Development Deadlock Fix...');
    
    // Store original functions
    const originalUpdateInfoPanel = window.updateInfoPanel;
    
    // Enhanced info panel update that handles unaffordable development
    function enhancedUpdateInfoPanel(propertyId, playerName, options = {}) {
        console.log(`ðŸ—ï¸ Enhanced updateInfoPanel for ${propertyId} by ${playerName}`);
        
        // Check if this is a potential deadlock scenario
        const isOwnProperty = window.properties && window.properties[propertyId] && window.properties[propertyId].owner === playerName;
        
        if (isOwnProperty && window.isMultiplayerGame) {
            console.log(`ðŸ—ï¸ Player ${playerName} landed on own property ${propertyId}`);
            
            // Quick affordability check
            const player = window.players ? window.players.find(p => p && p.name === playerName) : null;
            const devInfo = window.getPropertyDevelopmentInfo ? window.getPropertyDevelopmentInfo(propertyId) : null;
            
            if (player && devInfo && devInfo.cost && player.money < devInfo.cost) {
                console.log(`ðŸ—ï¸ Player ${playerName} cannot afford development ($${player.money} < $${devInfo.cost}) - auto-progressing`);
                
                // Auto-progress after a short delay
                setTimeout(() => {
                    console.log(`ðŸ—ï¸ Auto-progressing turn for ${playerName}`);
                    
                    // Try multiple methods to progress the turn
                    if (window.nextPlayerTurn) {
                        window.nextPlayerTurn();
                    } else if (window.endTurn) {
                        window.endTurn();
                    } else if (window.currentPlayerIndex !== undefined && window.players) {
                        // Manual turn progression
                        const nextIndex = (window.currentPlayerIndex + 1) % window.players.length;
                        window.currentPlayerIndex = nextIndex;
                        
                        // Update the current player name
                        const nextPlayer = window.players[nextIndex];
                        if (nextPlayer && nextPlayer.name) {
                            window.currentPlayerName = nextPlayer.name;
                            console.log(`ðŸ—ï¸ Manually progressed to ${nextPlayer.name}'s turn`);
                        }
                        
                        // Enable dice for next player
                        if (window.enableDiceSection) {
                            window.enableDiceSection();
                        }
                        
                        // Update the game frame
                        if (window.updateGameFrame) {
                            window.updateGameFrame();
                        }
                    }
                }, 1500); // Give UI time to update
                
                // Still call original but return early to prevent deadlock
                const result = originalUpdateInfoPanel ? originalUpdateInfoPanel(propertyId, playerName, options) : null;
                return result;
            }
        }
        
        // Call original function for all other cases
        return originalUpdateInfoPanel ? originalUpdateInfoPanel(propertyId, playerName, options) : null;
    }
    
    // Apply the fix
    if (typeof window !== 'undefined') {
        window.updateInfoPanel = enhancedUpdateInfoPanel;
        
        console.log('ðŸ—ï¸ Development Deadlock Fix applied successfully!');
        
        // Add emergency unstick function
        window.emergencyUnstick = function() {
            console.log('ðŸš¨ Emergency unstick activated!');
            
            // Clear any timers
            if (window.autoActionTimer) {
                clearTimeout(window.autoActionTimer);
                window.autoActionTimer = null;
            }
            
            // Force turn progression
            if (window.currentPlayerIndex !== undefined && window.players && window.players.length > 0) {
                const nextIndex = (window.currentPlayerIndex + 1) % window.players.length;
                window.currentPlayerIndex = nextIndex;
                
                const nextPlayer = window.players[nextIndex];
                if (nextPlayer && nextPlayer.name) {
                    window.currentPlayerName = nextPlayer.name;
                    console.log(`ðŸš¨ Emergency: Forced progression to ${nextPlayer.name}'s turn`);
                }
                
                // Enable dice and update display
                if (window.enableDiceSection) {
                    window.enableDiceSection();
                }
                if (window.updateGameFrame) {
                    window.updateGameFrame();
                }
            }
            
            console.log('ðŸš¨ Emergency unstick completed!');
        };
        
        console.log('ðŸ—ï¸ Added window.emergencyUnstick() function for manual recovery');
    }
}

// Critical Firebase Data Corruption Fix - Applied at game initialization
function applyFirebaseDataCorruptionFix() {
    console.log('ðŸš¨ Applying Critical Firebase Data Corruption Fix...');
    
    // Store original functions
    const originalUpdateGameFromState = window.updateGameFromState;
    const originalUpdatePlayerData = window.updatePlayerData;

    // Enhanced player data validation and repair
    function validateAndRepairPlayerData(players) {
        if (!Array.isArray(players)) {
            console.log('ðŸ”§ Converting non-array players to array');
            if (typeof players === 'object' && players !== null) {
                // Convert object with numeric keys to array
                const keys = Object.keys(players).filter(key => !isNaN(key)).sort((a, b) => parseInt(a) - parseInt(b));
                players = keys.map(key => players[key]);
            } else {
                return [];
            }
        }

        return players.map((player, index) => {
            if (!player || typeof player !== 'object') {
                console.log(`ðŸ”§ Repairing null/invalid player at index ${index}`);
                return null; // Mark for removal
            }

            // Create a repaired copy
            const repairedPlayer = { ...player };

            // Fix undefined/null names
            if (!repairedPlayer.name || repairedPlayer.name === 'undefined' || repairedPlayer.name === 'null') {
                console.log(`ðŸ”§ Repairing undefined name for player ${index}`);
                repairedPlayer.name = `Player_${index + 1}`;
            }

            // Fix undefined/null userIds
            if (!repairedPlayer.userId || repairedPlayer.userId === 'undefined' || repairedPlayer.userId === 'null') {
                console.log(`ðŸ”§ Repairing undefined userId for player ${index}`);
                repairedPlayer.userId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            }

            // Ensure required fields exist
            if (typeof repairedPlayer.isHost !== 'boolean') {
                repairedPlayer.isHost = index === 0;
            }

            // Ensure position data exists
            if (typeof repairedPlayer.x !== 'number') repairedPlayer.x = 0;
            if (typeof repairedPlayer.y !== 'number') repairedPlayer.y = 0;
            if (!repairedPlayer.currentSquare) repairedPlayer.currentSquare = 'go';

            // Ensure money exists
            if (typeof repairedPlayer.money !== 'number') repairedPlayer.money = 12000;

            // Ensure properties array exists
            if (!Array.isArray(repairedPlayer.properties)) repairedPlayer.properties = [];

            // Ensure color exists
            if (!repairedPlayer.color) {
                const colors = ['#ff0000', '#0000ff', '#00ff00', '#ffff00'];
                repairedPlayer.color = colors[index % colors.length];
            }

            console.log(`ðŸ”§ Player ${index} repaired: ${repairedPlayer.name} (${repairedPlayer.userId})`);
            return repairedPlayer;
        }).filter(player => player !== null); // Remove null players
    }

    // Enhanced updateGameFromState with corruption protection
    function enhancedUpdateGameFromState(gameState) {
        console.log('ðŸ”§ Enhanced updateGameFromState with corruption protection');
        
        if (!gameState || typeof gameState !== 'object') {
            console.log('ðŸš¨ Invalid game state received, ignoring update');
            return;
        }

        // Validate and repair player data before processing
        if (gameState.players) {
            const originalPlayerCount = Array.isArray(gameState.players) ? gameState.players.length : Object.keys(gameState.players).length;
            console.log(`ðŸ”§ Original player count: ${originalPlayerCount}`);
            
            const repairedPlayers = validateAndRepairPlayerData(gameState.players);
            console.log(`ðŸ”§ Repaired player count: ${repairedPlayers.length}`);
            
            if (repairedPlayers.length === 0) {
                console.log('ðŸš¨ No valid players after repair - maintaining local state');
                return;
            }
            
            // Update the game state with repaired players
            gameState.players = repairedPlayers;
            
            // Log the repaired players
            repairedPlayers.forEach((player, index) => {
                console.log(`ðŸ”§ Repaired Player ${index}: ${player.name} (${player.userId}) - Host: ${player.isHost}`);
            });
        }

        // Call the original function with repaired data
        if (originalUpdateGameFromState) {
            return originalUpdateGameFromState(gameState);
        }
    }

    // Enhanced updatePlayerData with validation
    function enhancedUpdatePlayerData(playerIndex, updates) {
        console.log(`ðŸ”§ Enhanced updatePlayerData for player ${playerIndex}`);
        
        if (!window.players || !Array.isArray(window.players) || !window.players[playerIndex]) {
            console.log(`ðŸš¨ Invalid player data for index ${playerIndex}, skipping update`);
            return;
        }

        const player = window.players[playerIndex];
        
        // Validate player before updating
        if (!player.name || player.name === 'undefined' || !player.userId || player.userId === 'undefined') {
            console.log(`ðŸ”§ Repairing player ${playerIndex} before update`);
            
            if (!player.name || player.name === 'undefined') {
                player.name = `Player_${playerIndex + 1}`;
            }
            if (!player.userId || player.userId === 'undefined') {
                player.userId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            }
            
            console.log(`ðŸ”§ Player ${playerIndex} repaired: ${player.name} (${player.userId})`);
        }

        // Call original function
        if (originalUpdatePlayerData) {
            return originalUpdatePlayerData(playerIndex, updates);
        }
    }

    // Property sync stabilization with lightning strike awareness
    function stabilizePropertySync() {
        console.log('ðŸ  Stabilizing property sync...');
        
        // Ensure properties object exists
        if (!window.properties || typeof window.properties !== 'object') {
            console.log('ðŸ  Initializing properties object');
            window.properties = {};
        }

        // Track recent lightning strikes to avoid overriding their effects
        if (!window.recentLightningStrikes) {
            window.recentLightningStrikes = new Map();
        }

        // Clean up old lightning strike records (older than 30 seconds)
        const now = Date.now();
        for (const [propertyId, timestamp] of window.recentLightningStrikes.entries()) {
            if (now - timestamp > 30000) { // 30 seconds
                window.recentLightningStrikes.delete(propertyId);
            }
        }

        // Validate property ownership consistency (but respect lightning strikes)
        if (window.players && Array.isArray(window.players)) {
            window.players.forEach((player, index) => {
                if (player && Array.isArray(player.properties)) {
                    player.properties.forEach(propertyId => {
                        // Skip properties that were recently struck by lightning
                        if (window.recentLightningStrikes.has(propertyId)) {
                            console.log(`âš¡ Skipping property sync for ${propertyId} - recently struck by lightning`);
                            return;
                        }

                        if (window.properties[propertyId] && window.properties[propertyId].owner !== player.name) {
                            console.log(`ðŸ  Fixing property ownership mismatch: ${propertyId} should be owned by ${player.name}`);
                            window.properties[propertyId].owner = player.name;
                            window.properties[propertyId].ownerColor = player.color || '#ff0000';
                        }
                    });
                }
            });
        }
    }

    // Apply the enhancements
    if (typeof window !== 'undefined') {
        window.updateGameFromState = enhancedUpdateGameFromState;
        window.updatePlayerData = enhancedUpdatePlayerData;
        
        // Add periodic property sync stabilization
        setInterval(stabilizePropertySync, 5000); // Every 5 seconds
        
        console.log('ðŸ”§ Critical Firebase Data Corruption Fix applied successfully!');
        
        // Add emergency repair function
        window.emergencyRepairGameState = function() {
            console.log('ðŸš¨ Emergency game state repair initiated!');
            
            // Repair local players
            if (window.players && Array.isArray(window.players)) {
                window.players = validateAndRepairPlayerData(window.players);
                console.log('ðŸ”§ Local players repaired');
            }
            
            // Stabilize properties
            stabilizePropertySync();
            
            // Force visual update
            if (window.updateGameFrame) {
                window.updateGameFrame();
            }
            
            console.log('ðŸ”§ Emergency repair completed!');
        };
        
        // Add data corruption detection
        window.detectDataCorruption = function() {
            console.log('ðŸ” Detecting data corruption...');
            
            let issues = [];
            
            if (window.players && Array.isArray(window.players)) {
                window.players.forEach((player, index) => {
                    if (!player) {
                        issues.push(`Player ${index}: null/undefined`);
                    } else {
                        if (!player.name || player.name === 'undefined') {
                            issues.push(`Player ${index}: undefined name`);
                        }
                        if (!player.userId || player.userId === 'undefined') {
                            issues.push(`Player ${index}: undefined userId`);
                        }
                    }
                });
            } else {
                issues.push('Players array is invalid');
            }
            
            if (issues.length > 0) {
                console.log('ðŸš¨ Data corruption detected:', issues);
                return { corrupted: true, issues };
            } else {
                console.log('âœ… No data corruption detected');
                return { corrupted: false, issues: [] };
            }
        };
        
        // Add lightning strike tracking function
        window.trackLightningStrike = function(propertyId) {
            if (!window.recentLightningStrikes) {
                window.recentLightningStrikes = new Map();
            }
            window.recentLightningStrikes.set(propertyId, Date.now());
            console.log(`âš¡ Manually tracked lightning strike on ${propertyId}`);
        };
        
        // Add function to check recent lightning strikes
        window.checkRecentLightningStrikes = function() {
            if (!window.recentLightningStrikes || window.recentLightningStrikes.size === 0) {
                console.log('âš¡ No recent lightning strikes tracked');
                return;
            }
            
            console.log('âš¡ Recent lightning strikes:');
            const now = Date.now();
            for (const [propertyId, timestamp] of window.recentLightningStrikes.entries()) {
                const secondsAgo = Math.floor((now - timestamp) / 1000);
                console.log(`  - ${propertyId}: ${secondsAgo} seconds ago`);
            }
        };
        
        console.log('ðŸ”§ Added emergency functions:');
        console.log('  - window.emergencyRepairGameState()');
        console.log('  - window.detectDataCorruption()');
        console.log('  - window.trackLightningStrike(propertyId)');
        console.log('  - window.checkRecentLightningStrikes()');
    }
}

// Add UI element references
const vsAiBtn = document.getElementById('vs-ai-btn');
const vsHumanBtn = document.getElementById('vs-human-btn');
const aiOptions = document.getElementById('ai-options');
const multiplayerControls = document.querySelector('.multiplayer-controls');
const startAiGameBtn = document.getElementById('start-ai-game-btn');
const aiPlayerCountSelect = document.getElementById('ai-player-count');
const humanPlayerCountSelect = document.getElementById('human-player-count');

// Add game mode selection handlers
vsAiBtn.addEventListener('click', () => {
    gameMode = 'ai';
    vsAiBtn.classList.add('selected');
    vsHumanBtn.classList.remove('selected');
    aiOptions.style.display = 'block';
    startAiGameBtn.style.display = 'block';
    multiplayerControls.style.display = 'none';
});

vsHumanBtn.addEventListener('click', () => {
    gameMode = 'multiplayer';
    vsHumanBtn.classList.add('selected');
    vsAiBtn.classList.remove('selected');
    aiOptions.style.display = 'block';
    startAiGameBtn.style.display = 'none';
    multiplayerControls.style.display = 'flex';
});

// Add AI game start handler
startAiGameBtn.addEventListener('click', () => {
    const playerName = document.getElementById('player1-name').value.trim();
    if (!playerName) {
        showAdvisory('Please enter your name first', 'error');
        return;
    }
    const aiCount = parseInt(aiPlayerCountSelect.value, 10) || 0;
    const humanCount = parseInt(humanPlayerCountSelect.value, 10) || 1;
    startAIGame(playerName, aiCount, humanCount);
});

// Initialize mobile detection on page load
window.addEventListener('load', () => {
    detectMobile();
});

// Also detect on resize for responsive behavior
window.addEventListener('resize', () => {
    detectMobile();
    // Update bottom player display visibility on resize
    setTimeout(() => {
        if (typeof updateBottomPlayerDisplay === 'function') {
            updateBottomPlayerDisplay();
        }
    }, 100);
});

// Handle visual viewport changes for mobile browsers (address bar hiding/showing)
if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', () => {
        console.log('ðŸ“± Visual viewport changed - updating bottom player display');
        setTimeout(() => {
            if (typeof updateBottomPlayerDisplay === 'function') {
                updateBottomPlayerDisplay();
            }
        }, 50);
    });
}

// Function to start a game against AI
async function startAIGame(playerName, aiCount = 1, humanCount = 1) {
    try {
        // Reset game state
        isInitialRoll = true;
        consecutiveDoublesCount = 0;
        lastRollWasDoubles = false;
        isAITurnInProgress = false; // reset AI turn flag
        
        // Reset mobile pan position and show mobile panel if needed
        if (isMobile) {
            resetCanvasPan();
                    // Ensure mobile panel is shown for single-player games (now shows standard info panel)
        setTimeout(() => {
            if (window.showMobilePanel) {
                window.showMobilePanel();
            }
        }, 1000);
        }

        // Hide intro screen and show game container (guarded)
        const __intro = document.getElementById('intro-screen');
        const __game = document.getElementById('game-container');
        if (__intro) __intro.style.display = 'none';
        if (__game) __game.style.display = 'block';

        // Initialize the game board first
        await initGame();

        // Now positionsMap should be loaded
        const startPos = positionsMap.get('go');
        if (!startPos) throw new Error('Starting position "go" not found');

        // Limit to maximum of 4 total participants
        let totalRequested = aiCount + humanCount;
        if (totalRequested > 4) {
            const excess = totalRequested - 4;
            // Prefer dropping AI bots first
            aiCount = Math.max(0, aiCount - excess);
            totalRequested = aiCount + humanCount;
            if (totalRequested > 4) {
                humanCount = 4 - aiCount;
            }
        }

        const allTokenUrls = [
            'assets/images/t1.png', 'assets/images/t2.png', 'assets/images/t3.png',
            'assets/images/t4.png', 'assets/images/t5.png', 'assets/images/t6.png',
            'assets/images/t7.png', 'assets/images/t8.png', 'assets/images/t9.png'
        ];
        const totalPlayers = Math.max(2, Math.min(4, aiCount + humanCount));

        const tokenImages = await loadTokens(allTokenUrls.slice(0, totalPlayers));

        players = [];

        const humanNames = [playerName];
        for (let i = 1; i < humanCount; i++) {
            humanNames.push(`Human Player ${i + 1}`);
        }

        humanNames.forEach((name, idx) => {
            players.push({
                name,
                userId: 'user_' + Math.random().toString(36).substring(2, 10),
                image: tokenImages[idx],
                x: startPos.x,
                y: startPos.y,
                currentSquare: 'go',
                currentPathKey: "gamePath",
                currentIndexOnPath: 0,
                isMovingReverse: false,
                size: 62,
                money: 16500,
                isAI: false,
                properties: [],
                bankrupt: false,
                isCurrentPlayer: false,
                stealCards: 0,
                lightningBolts: 0,
                goPassCount: 0
            });
        });
        // Prefer bolts.png if available; override lightning bolt image when it loads
        try {
            const boltsImg = new Image();
            boltsImg.onload = () => {
                lightningBoltImage = boltsImg;
                lightningBoltImageLoaded = true;
            };
            boltsImg.onerror = () => {};
            boltsImg.src = 'assets/images/bolts.png';
        } catch (e) {}

        for (let i = 0; i < aiCount; i++) {
            const idx = humanNames.length + i;
            players.push({
                name: `AI Player ${i + 1}`,
                userId: 'ai_' + Math.random().toString(36).substring(2, 10),
                image: tokenImages[idx],
                x: startPos.x,
                y: startPos.y,
                currentSquare: 'go',
                currentPathKey: "gamePath",
                currentIndexOnPath: 0,
                isMovingReverse: false,
                size: 62,
                money: 16500,
                isAI: true,
                properties: [],
                bankrupt: false,
                isCurrentPlayer: false,
                stealCards: 0,
                lightningBolts: 0,
                goPassCount: 0
            });
        }

        // Assign colors to all players
        assignPlayerColors(players);

        // Update game_utils with player state
        setPlayers(players);

        // Ensure canvas is ready before updating game frame
        if (canvas && document.querySelector('canvas')) {
            // Update game frame to show initial positions
            await updateGameFrame();
        } else {
            console.warn('Canvas not ready yet, skipping initial updateGameFrame');
            // Set up a retry mechanism or wait for canvas to be ready
            const waitForCanvas = setInterval(() => {
                if (canvas && document.querySelector('canvas')) {
                    clearInterval(waitForCanvas);
                    updateGameFrame();
                }
            }, 100);
            
            // Clear the interval after 5 seconds to prevent infinite waiting
            setTimeout(() => clearInterval(waitForCanvas), 5000);
        }
        
        // Show info panel for AI game (UserIDs panel disabled)
        document.getElementById('info-panel').style.display = 'block';
        // showUserIDsPanel(); // Disabled - don't show UserIDs window
        // updateUserIDsPanel(players); // Disabled - don't update UserIDs window
        initializeInfoPanelChecks();
        
        // Start auto-roll timer for first turn
        startAutoRollTimer();
        
        // Start the gojail glow system
        startGojailGlowSystem();
        
        // Start the gojail graves shaking system
        startGojailGravesShakingSystem();
        
        // Reset and start the lightning system
        resetLightningSystem();
        startLightningSystem();
        

        
        // Initialize bottom player display
        if (typeof updateBottomPlayerDisplay === 'function') {
            updateBottomPlayerDisplay();
        }
        
        // Ensure bottom display is visible for single-player mode
        ensureBottomPlayerDisplayVisible();
    } catch (error) {
        console.error('Error starting AI game:', error);
        throw error;
    }
}

// NEW: Board Position Recorder State
let isRecordingBoardPositions = false;
let recordedPositionsData = [];
let currentRecordingPathIndex = 0;
let positionRecorderInstructionEl;
let boardPositionsJsonOutputEl;
let boardPositionsRecorderPanelEl;
let recordPositionsBtnEl; // The button to start recording, usually visible after game init
let cancelPositionRecordingBtnEl;
let boardPositionRecorderControlsEl; // Container for the record button
let recordSnakePathBtnEl; // Button for snake path

// Path Definitions
const gamePath = [
    'go', 't1', 't2', 't3', 't4', 't5', 't6', 't7', 't8', 't9',
    'jail', 'r1', 'r2', 'r3', 'r4', 'r5', 'r6', 'r7', 'r8', 'r9',
    'yingyang', 'b9', 'b8', 'b7', 'b6', 'b5', 'b4', 'b3', 'b2', 'b1',
    'gojail', 'l9', 'l8', 'l7', 'l6', 'l5', 'l4', 'l3', 'l2', 'l1'
];

// Property Groups and Costs
const propertyGroups = {
    blood: {
        positions: ['t5', 'b5', 'b6', 'l2', 'l4'],
        cost: 280,
        graveyardCost: 350, // 1.5 * property cost
        cryptCost: 2200, // 5 * property cost
        color: '#ff0000'
    },
    urine: {
        positions: ['b3', 'b7', 'r4'],
        cost: 320,
        graveyardCost: 420, // 1.5 * property cost
        cryptCost: 2250, // 5 * property cost
        color: '#ffa500'
    },
    drowning: {
        positions: ['t4', 't6'],
        cost: 450,
        graveyardCost: 515, // 1.5 * property cost
        cryptCost: 2509, // 5 * property cost
        color: '#87ceeb'
    },
    strangulation: {
        positions: ['b2', 'b4', 'b9', 'l7'],
        cost: 510,
        graveyardCost: 620, // 1.5 * property cost
        cryptCost: 3100, // 5 * property cost
        color: '#00008b'
    },
    cave: {
        positions: ['r3'],
        cost: 250,
        graveyardCost: 0, // Cannot develop
        cryptCost: 0, // Cannot develop
        color: '#8B4513' // Brown color for cave
    },
    werewolves: {
        positions: ['t3', 't7', 'r7', 'r8'],
        cost: 600,
        graveyardCost: 750, // 1.5 * property cost
        cryptCost: 3800, // 5 * property cost
        color: '#ffff00'
    },
    poison: {
        positions: ['r9', 'r5'],
        cost: 400,
        graveyardCost: 700, // 1.5 * property cost
        cryptCost: 3000, // 5 * property cost
        color: '#800080'
    },
    insanity: {
        positions: ['l1', 'l3', 'l8'],
        cost: 650,
        graveyardCost: 825, // 1.5 * property cost
        cryptCost: 3950, // 5 * property cost
        color: '#ff00ff'
    },
    waterboarding: {
        positions: ['t1', 't2', 't9'],
        cost: 550,
        graveyardCost: 725, // 1.5 * property cost
        cryptCost: 2750, // 5 * property cost
        color: '#40e0d0'
    },
    swamp: {
        positions: ['r1', 'r2', 'r6', 'l6'],
        cost: 980,
        graveyardCost: 1020, // 1.5 * property cost
        cryptCost: 4000, // 5 * property cost
        color: '#008000'
    },
    demon: {
        positions: ['l5', 'l9', 'b1', 'b8'],
        cost: 1000,
        graveyardCost: 2075, // 1.5 * property cost
        cryptCost: 4550, // 5 * property cost
        color: '#ff3333'
    }
};

// Player color system
const playerColors = ['#ff0000', '#0000ff', '#00ff00', '#ffff00', '#800080']; // Red, Blue, Green, Yellow, Purple

// Function to assign colors to players
function assignPlayerColors(playersArray) {
    playersArray.forEach((player, index) => {
        player.color = playerColors[index % playerColors.length];
        player.colorName = ['Red', 'Blue', 'Green', 'Yellow', 'Purple'][index % playerColors.length];
        console.log(`Assigned ${player.colorName} (${player.color}) to ${player.name}`);
    });
}

// Property ownership and development tracking
const propertyState = {};

// Initialize property state
console.log('Initializing property states');
for (const [group, info] of Object.entries(propertyGroups)) {
    console.log(`Initializing ${group} properties:`, info.positions);
    info.positions.forEach(position => {
        propertyState[position] = {
            owner: null,
            ownerColor: null,
            graveyards: 0, // 0-4 graveyards
            hasCrypt: false, // true if property has a crypt
            group: group,
            declined: false, // track if property was declined for purchase
            lastLightningStrike: null // timestamp of last lightning strike affecting this property
        };
    });
}
console.log('Property states initialized:', propertyState);

// Helper function to check if player owns all properties in a group
function ownsFullGroup(player, group) {
    // Use the detailed group ownership check for consistency
    const groupOwnership = checkDetailedGroupOwnership(player, group);
    
    // Enhanced logging for group ownership checks
    const playerName = player?.name || 'Unknown';
    console.log(`ðŸ  ownsFullGroup: ${playerName} owns ${groupOwnership.ownedCount}/${groupOwnership.totalCount} of ${group} group = ${groupOwnership.ownsFullGroup}`);
    
    return groupOwnership.ownsFullGroup;
}

// Helper function to check if player just completed a property set (3rd property)
function checkPropertySetCompletion(player, newProperty) {
    const propertyInfo = getPropertyInfo(newProperty);
    if (!propertyInfo) return false;
    
    // Get player name with fallback for corrupted data
    let playerName = player.name;
    if (!playerName || playerName === 'undefined') {
        // Try to get from window.localPlayerName if this is the current player
        if (window.localPlayerName && players[currentPlayerIndex] === player) {
            playerName = window.localPlayerName;
        } else {
            console.warn('checkPropertySetCompletion: Player name is undefined/corrupted:', player);
            return false;
        }
    }
    
    const group = propertyInfo.group;
    const groupPositions = propertyGroups[group].positions;
    
    // Count how many properties in this group the player owns (including the new one)
    const ownedInGroup = groupPositions.filter(pos => 
        propertyState[pos].owner === playerName
    ).length;
    
    // Check if this is exactly the 3rd property in the group (completion threshold)
    // Most groups need 3 properties, but demon group needs 4
    const completionThreshold = group === 'demon' ? 4 : 3;
    
    if (ownedInGroup === completionThreshold) {
        console.log(`[checkPropertySetCompletion] ${playerName} just completed the ${group} property set with ${newProperty}!`);
        return true;
    }
    
    return false;
}

// Cache for property info to avoid redundant lookups
const propertyInfoCache = {};

// Helper function to get property info with caching
function getPropertyInfo(square) {
    // Check cache first
    if (propertyInfoCache[square]) {
        // Update state (which can change) but keep cached static data
        propertyInfoCache[square].state = propertyState[square];
        return propertyInfoCache[square];
    }
    
    // Not in cache, perform lookup
    for (const [group, info] of Object.entries(propertyGroups)) {
        if (info.positions.includes(square)) {
            console.log('Found property group:', group, 'for square:', square, '(caching for future use)');
            const propertyData = {
                square,
                group,
                cost: info.cost,
                graveyardCost: info.graveyardCost,
                cryptCost: info.cryptCost,
                color: info.color,
                state: propertyState[square]
            };
            
            // Cache the property data (excluding state which changes)
            propertyInfoCache[square] = {
                square,
                group,
                cost: info.cost,
                graveyardCost: info.graveyardCost,
                cryptCost: info.cryptCost,
                color: info.color,
                state: propertyState[square]
            };
            
            console.log('Property data:', propertyData);
            console.log('Property state for square:', square, ':', propertyState[square]);
            return propertyData;
        }
    }
    // Only log if it's a property square that should exist but doesn't
    if (['t1', 't2', 't3', 't4', 't5', 't6', 't7', 't8', 't9', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'r1', 'r2', 'r3', 'r4', 'r5', 'r6', 'r7', 'r8', 'r9', 'l1', 'l2', 'l3', 'l4', 'l5', 'l6', 'l7', 'l8', 'l9'].includes(square)) {
        console.log('No property info found for square:', square);
    }
    return null;
}

// Function to check if a property can be developed
function canDevelopProperty(player, square) {
    const property = propertyState[square];
    
    // Enhanced player name resolution for multiplayer
    let playerName = player?.name;
    if (!playerName || playerName === 'undefined' || playerName === 'null') {
        // Multiple fallback strategies for multiplayer
        if (window.localPlayerName && players[currentPlayerIndex] === player) {
            playerName = window.localPlayerName;
            console.log(`canDevelopProperty: Using window.localPlayerName fallback: "${playerName}"`);
        } else if (isMultiplayerGame) {
            const inputName = document.getElementById('player1-name')?.value?.trim();
            if (inputName && players[currentPlayerIndex] === player) {
                playerName = inputName;
                console.log(`canDevelopProperty: Using input fallback: "${playerName}"`);
            }
        }
        
        if (!playerName) {
            console.warn('canDevelopProperty: Could not resolve player name:', player);
            return false;
        }
    }
    
    // Enhanced debug logging for property development checks
    console.log(`ðŸ—ï¸ canDevelopProperty: Checking ${square} for "${playerName}". Property owner: "${property?.owner}"`);
    
    if (!property || property.owner !== playerName) {
        console.log(`âŒ Ownership check failed: property=${!!property}, owner="${property?.owner}", expected="${playerName}"`);
        return false;
    }
    
    const propertyInfo = getPropertyInfo(square);
    if (!propertyInfo) {
        console.log(`âŒ No property info found for ${square}`);
        return false;
    }
    
    // Cave properties cannot be developed
    if (propertyInfo.group === 'cave') {
        console.log(`âŒ Cave properties cannot be developed`);
        return false;
    }
    
    // Check if already fully developed
    if (property.hasCrypt) {
        console.log(`âŒ Property ${square} already has crypt (fully developed)`);
        return false;
    }
    
    // Enhanced group ownership check with detailed logging - Modified for 3+ property development
    const groupOwnership = checkDetailedGroupOwnership(player, propertyInfo.group);
    
    // Allow development if player owns 3 or more properties in the set (instead of requiring full ownership)
    const developmentThreshold = 3;
    const canDevelop = groupOwnership.ownedCount >= developmentThreshold;
    
    if (!canDevelop) {
        console.log(`[canDevelopProperty] âŒ ${playerName} does not own enough properties in ${propertyInfo.group} group for development:`);
        console.log(`[canDevelopProperty]    Owned: ${groupOwnership.ownedProperties.join(', ')} (${groupOwnership.ownedCount}/${groupOwnership.totalCount})`);
        console.log(`[canDevelopProperty]    Required: ${developmentThreshold} properties minimum`);
        console.log(`[canDevelopProperty]    Missing: ${groupOwnership.missingProperties.join(', ')}`);
        groupOwnership.missingProperties.forEach(pos => {
            const owner = propertyState[pos]?.owner;
            console.log(`[canDevelopProperty]      ${pos}: owner is ${owner || 'Unowned'}`);
        });
        return false;
    }
    
    // Log successful development eligibility
    if (groupOwnership.ownsFullGroup) {
        console.log(`âœ… ${playerName} can develop ${square}: owns full ${propertyInfo.group} group (${groupOwnership.ownedCount}/${groupOwnership.totalCount}), graveyards=${property.graveyards}`);
    } else {
        console.log(`âœ… ${playerName} can develop ${square}: owns ${groupOwnership.ownedCount}/${groupOwnership.totalCount} properties in ${propertyInfo.group} group (3+ required), graveyards=${property.graveyards}`);
    }
    
    return true;
}

// Helper function for detailed group ownership checking
function checkDetailedGroupOwnership(player, group) {
    let playerName = player?.name;
    if (!playerName || playerName === 'undefined' || playerName === 'null') {
        if (window.localPlayerName && players[currentPlayerIndex] === player) {
            playerName = window.localPlayerName;
        } else if (isMultiplayerGame) {
            const inputName = document.getElementById('player1-name')?.value?.trim();
            if (inputName && players[currentPlayerIndex] === player) {
                playerName = inputName;
            }
        }
        
        if (!playerName) {
            return {
                ownsFullGroup: false,
                ownedProperties: [],
                missingProperties: propertyGroups[group]?.positions || [],
                ownedCount: 0,
                totalCount: propertyGroups[group]?.positions?.length || 0
            };
        }
    }
    
    const groupPositions = propertyGroups[group]?.positions || [];
    const ownedProperties = [];
    const missingProperties = [];
    
    groupPositions.forEach(pos => {
        console.log(`[checkDetailedGroupOwnership] Checking ${pos}: owner is "${propertyState[pos]?.owner}", expecting "${playerName}"`);
        if (propertyState[pos]?.owner === playerName) {
            ownedProperties.push(pos);
        } else {
            missingProperties.push(pos);
        }
    });
    
    const ownsFullGroup = ownedProperties.length === groupPositions.length;
    
    return {
        ownsFullGroup,
        ownedProperties,
        missingProperties,
        ownedCount: ownedProperties.length,
        totalCount: groupPositions.length
    };
}

// Function to get development cost
function getDevelopmentCost(square) {
    const propertyInfo = getPropertyInfo(square);
    if (!propertyInfo) return null;
    
    const property = propertyState[square];
    if (property.graveyards === 4 && !property.hasCrypt) {
        return {
            type: 'crypt',
            cost: propertyInfo.cryptCost
        };
    } else if (property.graveyards < 4) {
        return {
            type: 'graveyard',
            cost: propertyInfo.graveyardCost
        };
    }
    return null;
}

// Function to develop a property
function developProperty(player, square) {
    if (!canDevelopProperty(player, square)) return false;
    
    const property = propertyState[square];
    const developmentInfo = getDevelopmentCost(square);
    
    if (!developmentInfo) return false;
    
    // Check if player can afford it
    if (player.money < developmentInfo.cost) return false;
    
    // Apply development
    if (developmentInfo.type === 'crypt') {
        property.hasCrypt = true;
        // Remove graveyards when a crypt is built so only the crypt is shown
        property.graveyards = 0;
        // Play crypt sound
        playCryptSound();
    } else {
        property.graveyards++;
        // Play grave sound
        playGraveSound();
    }
    
    // Deduct cost
    player.money -= developmentInfo.cost;
    checkBankruptcy(player);
    return true;
}

const uPath = ['u1', 'u2', 'u3', 'u4', 'u5', 'u6'];
const snakePath1 = Array.from({ length: 19 }, (_, i) => `s${i + 1}`);
const snakePath2 = Array.from({ length: 19 }, (_, i) => `TT${i + 1}`);

// Map to store position coordinates
positionsMap = new Map();

// Paths Configuration
const paths = {
    gamePath: {
        array: gamePath,
        yOffsetLogic: true
    },
    uPath: {
        array: uPath,
        yOffsetLogic: false,
        entryTriggerDoublesOnSquares: ['go', 't1', 't2', 't3', 't4', 't5', 't6', 't7', 't8', 't9'],
        exitTargetForward: 'r4',
        exitTargetForwardIndex: -1 // Will be calculated in initGame
    },
    snakePath1: {
        array: snakePath1,
        yOffsetLogic: false,
        entryTriggerForwardLandOn: 't1',
        exitTargetForward: 'b1',
        exitTargetForwardIndex: -1,
        entryTriggerReverseDoublesOnSquares: ['b1', 'b2', 'b3', 'b4', 'yingyang'],
        exitTargetReverse: 't1',
        exitTargetReverseIndex: -1
    },
    snakePath2: {
        array: snakePath2,
        yOffsetLogic: false,
        entryTriggerForwardLandOn: 't6',
        exitTargetForward: 'b9',
        exitTargetForwardIndex: -1,
        entryTriggerReverseDoublesOnSquares: ['b5', 'b6', 'b7', 'b8', 'b9'],
        exitTargetReverse: 't6',
        exitTargetReverseIndex: -1
    }
};

// Audio setup for movement sounds
const NUM_PING_SOUNDS = 3; // Number of ping sound objects to cycle through
const pingSounds = Array.from({ length: NUM_PING_SOUNDS }, () => {
    const audio = new Audio('assets/sounds/ping.mp3');
    audio.volume = 0.2; // 20% volume
    return audio;
});
let currentPingIndex = 0;

// New sound effects
const pigSound = new Audio('assets/sounds/pig.mp3');
pigSound.volume = 0.3; // 30% volume
const bellSound = new Audio('assets/sounds/bell.mp3');
bellSound.volume = 0.3; // 30% volume
const omSound = new Audio('assets/sounds/om.mp3');
omSound.volume = 0.3; // 30% volume
const houseSound = new Audio('assets/sounds/house.mp3');
houseSound.volume = 0.3; // 30% volume
const gongSound = new Audio('assets/sounds/gong.mp3');
gongSound.volume = 0.3; // 30% volume
const screamSound = new Audio('assets/sounds/scream.mp3');
screamSound.volume = 0.3; // 30% volume
const zapSound = new Audio('assets/sounds/zap.mp3');
zapSound.volume = 0.3; // 30% volume
const jailSound = new Audio('assets/sounds/jail.mp3');
jailSound.volume = 0.3; // 30% volume

const strikeSound = new Audio('assets/sounds/strike.mp3');
strikeSound.volume = 0.5; // 50% volume

// Specific lightning sounds
const strikePlayerSound = new Audio('assets/sounds/strikeplayer.mp3');
strikePlayerSound.volume = 0.5; // 50% volume
const strikeHouseSound = new Audio('assets/sounds/strikehouse.mp3');
strikeHouseSound.volume = 0.5; // 50% volume

const graveSound = new Audio('assets/sounds/grave.mp3');
graveSound.volume = 0.4; // 40% volume

const cryptSound = new Audio('assets/sounds/crypt.mp3');
cryptSound.volume = 0.4; // 40% volume

const witchlaughSound = new Audio('assets/sounds/witchlaugh.mp3');
witchlaughSound.volume = 0.5; // 50% volume

const stealawardSound = new Audio('assets/sounds/stealaward.mp3');
stealawardSound.volume = 0.6; // 60% volume

const threeDublesSound = new Audio('assets/sounds/3doubles.mp3');
threeDublesSound.volume = 0.7; // 70% volume





// New sound effects for dice rolls and property sets
const diceRollSound = new Audio('assets/sounds/diceroll.mp3');
diceRollSound.volume = 0.3; // 30% volume
const doubleSound = new Audio('assets/sounds/double.mp3');
doubleSound.volume = 0.4; // 40% volume
const property3Sound = new Audio('assets/sounds/property3.mp3');
property3Sound.volume = 0.4; // 40% volume

// Ambient thunder sound
const thunderSound = new Audio('assets/sounds/thunder.mp3');
thunderSound.volume = 0.5; // 50% volume

// Ambient sound effects - wind and chimes
const wind1Sound = new Audio('assets/sounds/wind1.mp3');
wind1Sound.volume = 0.3; // 30% volume
const wind2Sound = new Audio('assets/sounds/wind2.mp3');
wind2Sound.volume = 0.3; // 30% volume
const chimesSound = new Audio('assets/sounds/chimes.mp3');
chimesSound.volume = 0.4; // 40% volume

// Ambient sound system
let ambientSoundSystem = {
    isActive: true,
    currentlyPlaying: null,
    sounds: [
        { 
            name: 'wind1', 
            audio: wind1Sound, 
            timer: null, 
            nextPlayTime: 0,
            minInterval: 60000, // 1 minute
            maxInterval: 300000 // 5 minutes
        },
        { 
            name: 'wind2', 
            audio: wind2Sound, 
            timer: null, 
            nextPlayTime: 0,
            minInterval: 60000, // 1 minute
            maxInterval: 300000 // 5 minutes
        },
        { 
            name: 'chimes', 
            audio: chimesSound, 
            timer: null, 
            nextPlayTime: 0,
            minInterval: 60000, // 1 minute
            maxInterval: 300000 // 5 minutes
        }
    ]
};

// Function to play the next available ping sound
async function playNextPing() {
    try {
        const pingSound = pingSounds[currentPingIndex];
        // Reset the sound to start if it's still playing
        pingSound.currentTime = 0;
        await pingSound.play();
        // Cycle to next sound object
        currentPingIndex = (currentPingIndex + 1) % NUM_PING_SOUNDS;
    } catch (error) {
        console.warn('Could not play movement sound:', error);
    }
}

// Function to play the pig sound
async function playPigSound() {
    try {
        pigSound.currentTime = 0;
        await pigSound.play();
    } catch (error) {
        console.warn('Could not play pig sound:', error);
    }
}

// Function to play the bell sound
async function playBellSound() {
    try {
        bellSound.currentTime = 0;
        await bellSound.play();
    } catch (error) {
        console.warn('Could not play bell sound:', error);
    }
}

// Function to play the om sound
async function playOmSound() {
    try {
        omSound.currentTime = 0;
        await omSound.play();
    } catch (error) {
        console.warn('Could not play om sound:', error);
    }
}

// Function to play the house sound
async function playHouseSound() {
    try {
        houseSound.currentTime = 0;
        await houseSound.play();
    } catch (error) {
        console.warn('Could not play house sound:', error);
    }
}

// Function to play the gong sound
async function playGongSound() {
    try {
        gongSound.currentTime = 0;
        await gongSound.play();
    } catch (error) {
        console.warn('Could not play gong sound:', error);
    }
}

// Function to play the scream sound
async function playScreamSound() {
    try {
        screamSound.currentTime = 0;
        await screamSound.play();
    } catch (error) {
        console.warn('Could not play scream sound:', error);
    }
}

// Function to play the zap sound
async function playZapSound() {
    try {
        zapSound.currentTime = 0;
        await zapSound.play();
    } catch (error) {
        console.warn('Could not play zap sound:', error);
    }
}

// Function to play the jail sound
async function playJailSound() {
    try {
        jailSound.currentTime = 0;
        await jailSound.play();
    } catch (error) {
        console.warn('Could not play jail sound:', error);
    }
}

// Function to play the strike sound
async function playStrikeSound() {
    try {
        strikeSound.currentTime = 0;
        await strikeSound.play();
    } catch (error) {
        console.warn('Could not play strike sound:', error);
    }
}

// Function to play the player strike sound
async function playStrikePlayerSound() {
    try {
        strikePlayerSound.currentTime = 0;
        await strikePlayerSound.play();
    } catch (error) {
        console.warn('Could not play strike player sound:', error);
    }
}

// Function to play the house/property strike sound
async function playStrikeHouseSound() {
    try {
        strikeHouseSound.currentTime = 0;
        await strikeHouseSound.play();
    } catch (error) {
        console.warn('Could not play strike house sound:', error);
    }
}

// Function to play the grave sound
async function playGraveSound() {
    try {
        graveSound.currentTime = 0;
        await graveSound.play();
    } catch (error) {
        console.warn('Could not play grave sound:', error);
    }
}

// Function to play the crypt sound
async function playCryptSound() {
    try {
        cryptSound.currentTime = 0;
        await cryptSound.play();
    } catch (error) {
        console.warn('Could not play crypt sound:', error);
    }
}

// Function to play the witchlaugh sound
async function playWitchlaughSound() {
    try {
        witchlaughSound.currentTime = 0;
        await witchlaughSound.play();
    } catch (error) {
        console.warn('Could not play witchlaugh sound:', error);
    }
}

// Function to play the steal award sound
async function playStealAwardSound() {
    try {
        stealawardSound.currentTime = 0;
        await stealawardSound.play();
    } catch (error) {
        console.warn('Could not play steal award sound:', error);
    }
}

// Function to play the 3 doubles sound
async function playThreeDoublesSound() {
    try {
        threeDublesSound.currentTime = 0;
        await threeDublesSound.play();
    } catch (error) {
        console.warn('Could not play 3 doubles sound:', error);
    }
}

// Ambient sound system functions
function getRandomInterval(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

async function playAmbientSound(soundObj) {
    if (!ambientSoundSystem.isActive) return;
    
    // Check if another ambient sound is currently playing
    if (ambientSoundSystem.currentlyPlaying && ambientSoundSystem.currentlyPlaying !== soundObj.name) {
        console.log(`ðŸŒ¬ï¸ Skipping ${soundObj.name} - ${ambientSoundSystem.currentlyPlaying} is currently playing`);
        scheduleNextAmbientSound(soundObj);
        return;
    }
    
    try {
        console.log(`ðŸŒ¬ï¸ Playing ambient sound: ${soundObj.name}`);
        ambientSoundSystem.currentlyPlaying = soundObj.name;
        
        soundObj.audio.currentTime = 0;
        await soundObj.audio.play();
        
        // Set up event listener to clear currentlyPlaying when sound ends
        soundObj.audio.onended = () => {
            console.log(`ðŸŒ¬ï¸ Ambient sound finished: ${soundObj.name}`);
            if (ambientSoundSystem.currentlyPlaying === soundObj.name) {
                ambientSoundSystem.currentlyPlaying = null;
            }
        };
        
        // Schedule the next play time for this sound
        scheduleNextAmbientSound(soundObj);
        
    } catch (error) {
        console.warn(`Could not play ambient sound ${soundObj.name}:`, error);
        ambientSoundSystem.currentlyPlaying = null;
        scheduleNextAmbientSound(soundObj);
    }
}

function scheduleNextAmbientSound(soundObj) {
    // Clear existing timer
    if (soundObj.timer) {
        clearTimeout(soundObj.timer);
    }
    
    // Calculate random interval between min and max
    const interval = getRandomInterval(soundObj.minInterval, soundObj.maxInterval);
    soundObj.nextPlayTime = Date.now() + interval;
    
    console.log(`ðŸŒ¬ï¸ Next ${soundObj.name} scheduled in ${Math.round(interval / 1000)} seconds`);
    
    // Set timer for next play
    soundObj.timer = setTimeout(() => {
        playAmbientSound(soundObj);
    }, interval);
}

function initializeAmbientSounds() {
    if (!ambientSoundSystem.isActive) return;
    
    console.log('ðŸŒ¬ï¸ Initializing ambient sound system...');
    
    // Schedule initial play times for each sound with staggered delays
    ambientSoundSystem.sounds.forEach((soundObj, index) => {
        // Stagger initial delays to prevent simultaneous playing
        const initialDelay = getRandomInterval(10000, 60000) + (index * 30000); // 10s-1min + stagger
        
        console.log(`ðŸŒ¬ï¸ Initial ${soundObj.name} scheduled in ${Math.round(initialDelay / 1000)} seconds`);
        
        soundObj.timer = setTimeout(() => {
            playAmbientSound(soundObj);
        }, initialDelay);
    });
}

function stopAmbientSounds() {
    console.log('ðŸŒ¬ï¸ Stopping ambient sound system...');
    ambientSoundSystem.isActive = false;
    
    ambientSoundSystem.sounds.forEach(soundObj => {
        if (soundObj.timer) {
            clearTimeout(soundObj.timer);
            soundObj.timer = null;
        }
        soundObj.audio.pause();
        soundObj.audio.currentTime = 0;
    });
    
    ambientSoundSystem.currentlyPlaying = null;
}

function startAmbientSounds() {
    console.log('ðŸŒ¬ï¸ Starting ambient sound system...');
    ambientSoundSystem.isActive = true;
    initializeAmbientSounds();
}

function toggleAmbientSounds() {
    if (ambientSoundSystem.isActive) {
        stopAmbientSounds();
    } else {
        startAmbientSounds();
    }
    return ambientSoundSystem.isActive;
}

// Debug function to check ambient sound status
function debugAmbientSounds() {
    console.log('ðŸŒ¬ï¸ === AMBIENT SOUND STATUS ===');
    console.log(`Active: ${ambientSoundSystem.isActive}`);
    console.log(`Currently Playing: ${ambientSoundSystem.currentlyPlaying || 'None'}`);
    
    ambientSoundSystem.sounds.forEach(soundObj => {
        const timeUntilNext = soundObj.nextPlayTime > 0 ? 
            Math.max(0, Math.round((soundObj.nextPlayTime - Date.now()) / 1000)) : 'Not scheduled';
        console.log(`${soundObj.name}: Next in ${timeUntilNext}s`);
    });
}





// Generic function to show flashing text messages
function showFlashMessage(text, color = '#ff0000', animationId = 'genericFlash') {
    // Create the flashing text element
    const flashElement = document.createElement('div');
    flashElement.id = `${animationId}-flash`;
    flashElement.innerHTML = text;
    // Detect mobile device and adjust font size accordingly
    const isMobileDevice = window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const fontSize = isMobileDevice ? '29px' : '36px'; // 20% smaller on mobile (36px * 0.8 = 28.8px â‰ˆ 29px)
    
    flashElement.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: 'Courier New', 'Lucida Console', 'Monaco', 'Consolas', monospace;
        font-size: ${fontSize};
        font-weight: bold;
        color: ${color};
        text-shadow: 
            0 0 10px ${color},
            0 0 20px ${color},
            0 0 30px ${color},
            2px 2px 4px rgba(0,0,0,0.8);
        z-index: 10000;
        pointer-events: none;
        animation: ${animationId} 2s ease-in-out;
        user-select: none;
    `;
    
    // Add CSS animation if not already defined
    if (!document.getElementById(`${animationId}-styles`)) {
        const style = document.createElement('style');
        style.id = `${animationId}-styles`;
        style.textContent = `
            @keyframes ${animationId} {
                0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
                40% { opacity: 0.7; transform: translate(-50%, -50%) scale(1); }
                60% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                80% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
                100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            }
        `;
        document.head.appendChild(style);
    }
    
    // Add to page
    document.body.appendChild(flashElement);
    
    // Remove after animation completes
    setTimeout(() => {
        if (flashElement.parentNode) {
            flashElement.parentNode.removeChild(flashElement);
        }
    }, 2000);
    
    console.log(`ðŸ”¥ ${text} flash effect displayed`);
}

// Function to show flashing "Dungeon" text when sent to jail (using generic function)
function showDungeonFlash() {
    showFlashMessage('DUNGEON', '#ff0000', 'dungeonFlash');
}

// Function to show flashing "Bonus!" text when passing GO
function showBonusFlash() {
    showFlashMessage('BONUS!', '#00ff00', 'bonusFlash');
}

// Function to show flashing "Yang!" text when landing on yin-yang
function showYangFlash() {
    showFlashMessage('YANG!', '#ff00ff', 'yangFlash');
}

// Function to show flashing "Teleport!" text when teleporting
function showTeleportFlash() {
    showFlashMessage('TELEPORT!', '#ffffff', 'teleportFlash');
}

// Function to create a tiny white screen flash for teleportation
function createTeleportScreenFlash() {
    // Create white flash overlay
    const whiteFlash = document.createElement('div');
    whiteFlash.id = 'teleport-white-flash';
    whiteFlash.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(255, 255, 255, 0.7);
        z-index: 9998;
        pointer-events: none;
        opacity: 0;
        animation: teleportWhiteFlash 0.15s ease-out;
    `;
    
    // Add CSS animation for white flash if not already added
    if (!document.getElementById('teleport-flash-styles')) {
        const style = document.createElement('style');
        style.id = 'teleport-flash-styles';
        style.textContent = `
            @keyframes teleportWhiteFlash {
                0% { 
                    opacity: 0; 
                }
                50% { 
                    opacity: 0.7; 
                }
                100% { 
                    opacity: 0; 
                }
            }
        `;
        document.head.appendChild(style);
    }
    
    // Add flash to body
    document.body.appendChild(whiteFlash);
    
    // Remove flash after animation completes
    setTimeout(() => {
        if (whiteFlash.parentNode) {
            whiteFlash.parentNode.removeChild(whiteFlash);
        }
    }, 150); // Remove after 150ms (animation duration)
    
    console.log('âœ¨ Teleport white screen flash created');
}

// Function to play the boy sound
async function playBoySound() {
    try {
        const audio = new Audio('assets/sounds/boy.mp3');
        audio.volume = 0.7;
        await audio.play();
        console.log('Boy sound played');
    } catch (error) {
        console.warn('Could not play boy sound:', error);
    }
}

async function playStealSound() {
    try {
        const audio = new Audio('assets/sounds/steal.mp3');
        audio.volume = 0.8;
        await audio.play();
        console.log('Steal sound played');
    } catch (error) {
        console.warn('Could not play steal sound:', error);
    }
}

// Function to play the steal crypt sound
async function playStealCryptSound() {
    try {
        const audio = new Audio('assets/sounds/stealcrypt.mp3');
        audio.volume = 0.8;
        await audio.play();
        console.log('Steal crypt sound played');
    } catch (error) {
        console.warn('Could not play steal crypt sound:', error);
    }
}

// Function to play dice roll sound
async function playDiceRollSound() {
    try {
        diceRollSound.currentTime = 0;
        await diceRollSound.play();
        console.log('Dice roll sound played');
    } catch (error) {
        console.warn('Could not play dice roll sound:', error);
    }
}

// Function to play double sound
async function playDoubleSound() {
    try {
        doubleSound.currentTime = 0;
        await doubleSound.play();
        console.log('Double sound played');
    } catch (error) {
        console.warn('Could not play double sound:', error);
    }
}

// Function to play property set completion sound
async function playProperty3Sound() {
    try {
        property3Sound.currentTime = 0;
        await property3Sound.play();
        console.log('Property set completion sound played');
    } catch (error) {
        console.warn('Could not play property3 sound:', error);
    }
}


// Function to play the thunder sound
async function playThunderSound() {
    try {
        thunderSound.currentTime = 0;
        await thunderSound.play();
    } catch (error) {
        console.warn('Could not play thunder sound:', error);
    }
}

// Scheduler: play thunder randomly once every 3 minutes
let thunderTimeoutId = null;
let thunderWindowTimeoutId = null;
let thunderSchedulerStarted = false;

function startRandomThunderScheduler() {
    if (thunderSchedulerStarted) return;
    thunderSchedulerStarted = true;

    const scheduleNextWindow = () => {
        const windowMs = 180000; // 3 minutes
        const delayWithinWindowMs = Math.floor(Math.random() * windowMs);
        // Schedule the one thunder play for this window
        thunderTimeoutId = setTimeout(async () => {
            await playThunderSound();
            // After playing, wait the remainder of the 3-minute window, then schedule the next window
            thunderWindowTimeoutId = setTimeout(() => {
                scheduleNextWindow();
            }, windowMs - delayWithinWindowMs);
        }, delayWithinWindowMs);
    };

    scheduleNextWindow();
}

function stopRandomThunderScheduler() {
    if (thunderTimeoutId) {
        clearTimeout(thunderTimeoutId);
        thunderTimeoutId = null;
    }
    if (thunderWindowTimeoutId) {
        clearTimeout(thunderWindowTimeoutId);
        thunderWindowTimeoutId = null;
    }
    thunderSchedulerStarted = false;
}



function showHandEffect() {
    const handEffect = document.getElementById('hand-effect');
    if (!handEffect) return;

    const canvas = document.querySelector('canvas');
    if (!canvas) return;

    // Get the Go square position
    const goPos = positionsMap.get('go');
    if (!goPos) {
        console.error('Go position not found for hand effect');
        return;
    }

    const scaleX = canvas.clientWidth / canvas.width;
    const scaleY = canvas.clientHeight / canvas.height;
    const canvasOffsetX = canvas.offsetLeft;
    const canvasOffsetY = canvas.offsetTop;

    const handSize = 80 * scaleX;
    handEffect.style.width = `${handSize}px`;
    handEffect.style.height = `${handSize}px`;
    handEffect.style.left = `${canvasOffsetX + goPos.x * scaleX - handSize / 2}px`;
    handEffect.style.top = `${canvasOffsetY + goPos.y * scaleY - handSize / 2}px`;
    handEffect.style.display = 'block';

    // Restart the animation by forcing a reflow
    const handImage = handEffect.querySelector('.hand-image');
    if (handImage) {
        handImage.src = 'assets/images/hand.png';
        handImage.style.animation = 'none';
        handImage.offsetHeight; // Trigger reflow
        handImage.style.animation = 'handImageAppear 20s ease-in-out';
    }

    // Hide the hand effect after 20 seconds (matches animation duration)
    setTimeout(() => {
        handEffect.style.display = 'none';
    }, 20000);
}

// Music state management - 11 states: Off, Oxy, Tube, Bag, Getyou, Yougonna, Creepy, Anub, Dragon, Ard, Rob
let currentMusicState = 'Off'; // 'Off', 'Oxy', 'Tube', 'Bag', 'Getyou', 'Yougonna', 'Creepy', 'Anub', 'Dragon', 'Ard', 'Rob'
let oxyMusic = null;
let tubeMusic = null;
let bagMusic = null;
let getyouMusic = null;
let yougonnaMusic = null;
let creepyMusic = null;
let anubMusic = null;
let dragonMusic = null;
let ardMusic = null;
let robMusic = null;

function cycleMusicState() {
    // Stop current music
    stopAllMusic();
    
    // Cycle to next state
    switch (currentMusicState) {
        case 'Off':
            currentMusicState = 'Oxy';
            playOxyMusic();
            break;
        case 'Oxy':
            currentMusicState = 'Tube';
            playTubeMusic();
            break;
        case 'Tube':
            currentMusicState = 'Bag';
            playBagMusic();
            break;
        case 'Bag':
            currentMusicState = 'Getyou';
            playGetyouMusic();
            break;
        case 'Getyou':
            currentMusicState = 'Yougonna';
            playYougonnaMusic();
            break;
        case 'Yougonna':
            currentMusicState = 'Creepy';
            playCreepyMusic();
            break;
        case 'Creepy':
            currentMusicState = 'Anub';
            playAnubMusic();
            break;
        case 'Anub':
            currentMusicState = 'Dragon';
            playDragonMusic();
            break;
        case 'Dragon':
            currentMusicState = 'Ard';
            playArdMusic();
            break;
        case 'Ard':
            currentMusicState = 'Rob';
            playRobMusic();
            break;
        case 'Rob':
            currentMusicState = 'Off';
            break;
    }
    
    // Update button appearance
    updateMusicButton();
    console.log('Music state changed to:', currentMusicState);
}

function stopAllMusic() {
    if (oxyMusic) {
        oxyMusic.pause();
        oxyMusic.currentTime = 0;
    }
    if (tubeMusic) {
        tubeMusic.pause();
        tubeMusic.currentTime = 0;
    }
    if (bagMusic) {
        bagMusic.pause();
        bagMusic.currentTime = 0;
    }
    if (getyouMusic) {
        getyouMusic.pause();
        getyouMusic.currentTime = 0;
    }
    if (yougonnaMusic) {
        yougonnaMusic.pause();
        yougonnaMusic.currentTime = 0;
    }
    if (creepyMusic) {
        creepyMusic.pause();
        creepyMusic.currentTime = 0;
    }
    if (anubMusic) {
        anubMusic.pause();
        anubMusic.currentTime = 0;
    }
    if (dragonMusic) {
        dragonMusic.pause();
        dragonMusic.currentTime = 0;
    }
    if (ardMusic) {
        ardMusic.pause();
        ardMusic.currentTime = 0;
    }
    if (robMusic) {
        robMusic.pause();
        robMusic.currentTime = 0;
    }
    if (backgroundMusic) {
        backgroundMusic.pause();
        backgroundMusic.currentTime = 0;
    }
    isMusicPlaying = false;
}

function playOxyMusic() {
    if (!oxyMusic) {
        oxyMusic = new Audio('assets/sounds/oxy.mp3');
        oxyMusic.loop = true;
    }
    oxyMusic.play().catch(e => console.error("Error playing oxy music:", e));
    isMusicPlaying = true;
}

function playTubeMusic() {
    if (!tubeMusic) {
        tubeMusic = new Audio('assets/sounds/tube.mp3');
        tubeMusic.loop = true;
    }
    tubeMusic.play().catch(e => console.error("Error playing tube music:", e));
    isMusicPlaying = true;
}

function playBagMusic() {
    if (!bagMusic) {
        bagMusic = new Audio('assets/sounds/bag.mp3');
        bagMusic.loop = true;
    }
    bagMusic.play().catch(e => console.error("Error playing bag music:", e));
    isMusicPlaying = true;
}

function playGetyouMusic() {
    if (!getyouMusic) {
        getyouMusic = new Audio('assets/sounds/getyou.mp3');
        getyouMusic.loop = true;
    }
    getyouMusic.play().catch(e => console.error("Error playing getyou music:", e));
    isMusicPlaying = true;
}

function playYougonnaMusic() {
    if (!yougonnaMusic) {
        yougonnaMusic = new Audio('assets/sounds/yougonna.mp3');
        yougonnaMusic.loop = true;
    }
    yougonnaMusic.play().catch(e => console.error("Error playing yougonna music:", e));
    isMusicPlaying = true;
}

function playCreepyMusic() {
    if (!creepyMusic) {
        creepyMusic = new Audio('assets/sounds/creepy.mp3');
        creepyMusic.loop = true;
    }
    creepyMusic.play().catch(e => console.error("Error playing creepy music:", e));
    isMusicPlaying = true;
}

function playAnubMusic() {
    if (!anubMusic) {
        anubMusic = new Audio('assets/sounds/anub.mp3');
        anubMusic.loop = true;
    }
    anubMusic.play().catch(e => console.error("Error playing anub music:", e));
    isMusicPlaying = true;
}

function playDragonMusic() {
    if (!dragonMusic) {
        dragonMusic = new Audio('assets/sounds/dragon.mp3');
        dragonMusic.loop = true;
    }
    dragonMusic.play().catch(e => console.error("Error playing dragon music:", e));
    isMusicPlaying = true;
}

function playArdMusic() {
    if (!ardMusic) {
        ardMusic = new Audio('assets/sounds/ard.mp3');
        ardMusic.loop = true;
    }
    ardMusic.play().catch(e => console.error("Error playing ard music:", e));
    isMusicPlaying = true;
}

function playRobMusic() {
    if (!robMusic) {
        robMusic = new Audio('assets/sounds/rob.mp3');
        robMusic.loop = true;
    }
    robMusic.play().catch(e => console.error("Error playing rob music:", e));
    isMusicPlaying = true;
}

function updateMusicButton() {
    const musicButton = document.getElementById('music-toggle');
    if (!musicButton) return;
    
    switch (currentMusicState) {
        case 'Off':
            musicButton.textContent = 'ðŸ”‡';
            musicButton.style.background = 'linear-gradient(135deg, #666 0%, #555 100%)';
            musicButton.style.borderColor = '#999';
            musicButton.style.color = 'white';
            break;
        case 'Oxy':
            musicButton.textContent = 'ðŸŽµ';
            musicButton.style.background = 'linear-gradient(135deg, #4CAF50 0%, #388E3C 100%)';
            musicButton.style.borderColor = '#2E7D32';
            musicButton.style.color = 'white';
            break;
        case 'Tube':
            musicButton.textContent = 'ðŸŽ¶';
            musicButton.style.background = 'linear-gradient(135deg, #FF9800 0%, #F57C00 100%)';
            musicButton.style.borderColor = '#E65100';
            musicButton.style.color = 'white';
            break;
        case 'Bag':
            musicButton.textContent = 'ðŸŽ¼';
            musicButton.style.background = 'linear-gradient(135deg, #9C27B0 0%, #7B1FA2 100%)';
            musicButton.style.borderColor = '#4A148C';
            musicButton.style.color = 'white';
            break;
        case 'Getyou':
            musicButton.textContent = 'ðŸŽ¤';
            musicButton.style.background = 'linear-gradient(135deg, #E91E63 0%, #C2185B 100%)';
            musicButton.style.borderColor = '#AD1457';
            musicButton.style.color = 'white';
            break;
        case 'Yougonna':
            musicButton.textContent = 'ðŸŽ§';
            musicButton.style.background = 'linear-gradient(135deg, #3F51B5 0%, #303F9F 100%)';
            musicButton.style.borderColor = '#1A237E';
            musicButton.style.color = 'white';
            break;
        case 'Creepy':
            musicButton.textContent = 'ðŸ‘»';
            musicButton.style.background = 'linear-gradient(135deg, #607D8B 0%, #455A64 100%)';
            musicButton.style.borderColor = '#37474F';
            musicButton.style.color = 'white';
            break;
        case 'Anub':
            musicButton.textContent = 'ðŸª';
            musicButton.style.background = 'linear-gradient(135deg, #A1887F 0%, #6D4C41 100%)';
            musicButton.style.borderColor = '#4E342E';
            musicButton.style.color = 'white';
            break;
        case 'Dragon':
            musicButton.textContent = 'ðŸ‰';
            musicButton.style.background = 'linear-gradient(135deg, #F44336 0%, #D32F2F 100%)';
            musicButton.style.borderColor = '#B71C1C';
            musicButton.style.color = 'white';
            break;
        case 'Ard':
            musicButton.textContent = 'ðŸª„';
            musicButton.style.background = 'linear-gradient(135deg, #FFC107 0%, #FFA000 100%)';
            musicButton.style.borderColor = '#FF6F00';
            musicButton.style.color = 'white';
            break;
        case 'Rob':
            musicButton.textContent = 'ðŸ¤–';
            musicButton.style.background = 'linear-gradient(135deg, #795548 0%, #5D4037 100%)';
            musicButton.style.borderColor = '#3E2723';
            musicButton.style.color = 'white';
            break;
    }
}

// Legacy function for backward compatibility
function toggleBackgroundMusic(play) {
    if (!play) {
        stopAllMusic();
        currentMusicState = 'Off';
        updateMusicButton();
    }
}

// Add event listener when DOM is loaded
document.addEventListener('DOMContentLoaded', async () => {
    console.log('DOM loaded, initializing game...');
    // Start ambient thunder scheduler
    startRandomThunderScheduler();
    
    // Get the start game button and other elements
    const startGameBtn = document.getElementById('start-game-btn');
    const introScreen = document.getElementById('intro-screen');
    const gameContainer = document.getElementById('game-container');

    if (!startGameBtn || !introScreen || !gameContainer) {
        console.error('Required elements not found:', {
            startGameBtn: !!startGameBtn,
            introScreen: !!introScreen,
            gameContainer: !!gameContainer
        });
        return;
    }

    // Note: Start game button event handler is now handled in initializeMultiplayerControls()
    // This old single-player handler has been removed to prevent conflicts

    // Add event listeners for eye recording buttons
    const saveEyesBtn = document.getElementById('save-eyes-btn');
    if (saveEyesBtn) {
        saveEyesBtn.addEventListener('click', () => {
            // Save eye positions to localStorage
            localStorage.setItem('eyePositions', JSON.stringify(eyePositions));
            // Hide the record export
            document.getElementById('record-export').style.display = 'none';
            // Re-enable game controls
            document.getElementById('info-panel').style.pointerEvents = 'auto';
            // Update the frame to show any current effects
            updateGameFrame();
        });
    }

    // Cancel eyes button
    const cancelEyesBtn = document.getElementById('cancel-eyes-btn');
    if (cancelEyesBtn) {
        cancelEyesBtn.addEventListener('click', () => {
            // Reset recording state
            isRecordingEyes = false;
            // Hide the record export
            document.getElementById('record-export').style.display = 'none';
            // Re-enable game controls
            document.getElementById('info-panel').style.pointerEvents = 'auto';
            // Remove instruction text if present
            const instructionEl = document.getElementById('instruction-text');
            if (instructionEl) {
                instructionEl.remove();
            }
            // Update the frame
            updateGameFrame();
        });
    }

    const recordEyesBtn = document.getElementById('record-eyes-btn');
    if (recordEyesBtn) {
        recordEyesBtn.style.display = 'none'; // Hide by default
    }
    const musicBar = document.querySelector('.music-toggle');
    if (musicBar) {
        let musicClickCount = 0;
        musicBar.addEventListener('click', () => {
            musicClickCount++;
            if (musicClickCount === 5 && recordEyesBtn) {
                recordEyesBtn.style.display = 'block';
            }
        });
    }

    // Initialize multiplayer controls
    await initializeMultiplayerControls();

    // Auto join from lobby if parameters provided
    const params = new URLSearchParams(window.location.search);
    const roomFromUrl = params.get('roomId');
    const playerFromUrl = params.get('player');
    const hostFlag = params.get('host') === '1';
    const uidFromUrl = params.get('uid');
    autoStartFlag = params.get('autostart') === '1';

    if (roomFromUrl && playerFromUrl) {
        window.localPlayerName = playerFromUrl;

        // Debug logging for player name URL parameter handling
        console.log(`ðŸŽ® URL Parameters - roomId: "${roomFromUrl}", player: "${playerFromUrl}"`);

        // If the name input still has the default value, replace it with the
        // player name passed from the lobby so turn checks work correctly.
        const nameInput = document.getElementById('player1-name');
        console.log(`ðŸŽ® Current nameInput value: "${nameInput ? nameInput.value : 'null'}"`);
        
        // ALWAYS override the input field when joining via URL with autostart to ensure correct player name
        if (nameInput && autoStartFlag) {
            console.log(`ðŸŽ® Autostart detected - forcing nameInput to URL parameter: "${playerFromUrl}"`);
            nameInput.value = playerFromUrl;
        } else if (nameInput && (!nameInput.value || nameInput.value === 'Player1')) {
            nameInput.value = playerFromUrl;
            console.log(`ðŸŽ® Set nameInput to URL parameter: "${playerFromUrl}"`);
        } else if (nameInput) {
            console.log(`ðŸŽ® Not overriding nameInput - already has value: "${nameInput.value}"`);
        }
        currentRoomId = roomFromUrl;
        isHost = hostFlag;
        isMultiplayerGame = true;

        // Ensure firebase module has the correct room reference before any subscriptions
        ensureGameRoomConnection(currentRoomId);
        console.log('Auto-join: room connection established', { roomId: currentRoomId });
        
        // Auto-start multiplayer game
        console.log('ðŸŽ® Auto-starting multiplayer game from URL parameters');
        
        // Set the player name from URL parameter
        if (playerFromUrl) {
            const nameInput = document.getElementById('player1-name');
            if (nameInput) {
                console.log(`ðŸŽ® Secondary name assignment - current value: "${nameInput.value}"`);
                nameInput.value = playerFromUrl;
                window.localPlayerName = playerFromUrl; // Also set the global variable
                console.log(`ðŸŽ® Set player name from URL (secondary): ${playerFromUrl}`);
            }
        }
        
        // Immediately hide intro screen and show game container
        const introScreen = document.getElementById('intro-screen');
        const gameContainer = document.getElementById('game-container');
        if (introScreen) introScreen.style.display = 'none';
        if (gameContainer) gameContainer.style.display = 'block';
        
                // Smart room joining logic - handle both host and guest cases
        if (!hostFlag) {
            // Guest player - try to join the existing room, create if it doesn't exist
            console.log('ðŸŽ® Guest player attempting to join room:', roomFromUrl);
            console.log(`ðŸŽ® Calling joinGameRoom with: roomId="${roomFromUrl}", playerName="${playerFromUrl}"`);
            joinGameRoom(roomFromUrl, playerFromUrl).then(data => {
                currentUserId = data.userId;
                subscribeToGameRoom();
                console.log('ðŸŽ® Guest player successfully joined existing room');
            }).catch(err => {
                console.log('ðŸŽ® Failed to join room:', err.message);
                
                // Check if it's a "room full" error or "room not found" error
                if (err.message.includes('Room is full')) {
                    console.log('ðŸŽ® Room is full, cannot join');
                    
                    // Use the new validation function to get detailed room information
                    if (window.validateRoomCapacity) {
                        window.validateRoomCapacity(roomFromUrl).then(roomInfo => {
                            if (roomInfo.valid) {
                                const errorMsg = `Room "${roomFromUrl}" is full (${roomInfo.currentPlayers}/${roomInfo.maxPlayers} players). Current players: ${roomInfo.players.map(p => p.name).join(', ')}`;
                                
                                if (roomInfo.hasInvalidPlayers) {
                                    const cleanupMsg = `Room has ${roomInfo.invalidPlayerCount} invalid players that can be cleaned up. Would you like to clean them up and try joining again?`;
                                    if (confirm(cleanupMsg)) {
                                        if (window.cleanupInvalidPlayers) {
                                            window.cleanupInvalidPlayers(roomFromUrl).then(cleanupResult => {
                                                if (cleanupResult.success && cleanupResult.cleanedCount > 0) {
                                                    showAdvisory(`Cleaned up ${cleanupResult.cleanedCount} invalid players. Room now has ${cleanupResult.remainingPlayers} players.`, 'info');
                                                    // Try joining again after cleanup
                                                    setTimeout(() => {
                                                        joinGameRoom(roomFromUrl, playerFromUrl).then(data => {
                                                            currentUserId = data.userId;
                                                            subscribeToGameRoom();
                                                            console.log('ðŸŽ® Successfully joined room after cleanup');
                                                        }).catch(joinErr => {
                                                            console.error('Failed to join after cleanup:', joinErr);
                                                            showAdvisory('Still unable to join room after cleanup.', 'error');
                                                        });
                                                    }, 1000);
                                                } else {
                                                    showAdvisory('No invalid players found to clean up.', 'info');
                                                }
                                            }).catch(cleanupErr => {
                                                console.error('Failed to cleanup room:', cleanupErr);
                                                showAdvisory('Failed to cleanup room: ' + cleanupErr.message, 'error');
                                            });
                                        }
                                    }
                                } else {
                                    showAdvisory(errorMsg, 'error');
                                }
                            } else {
                                showAdvisory(`Room "${roomFromUrl}" is full. Cannot join this game.`, 'error');
                            }
                        }).catch(debugErr => {
                            console.error('Failed to validate room capacity:', debugErr);
                            showAdvisory(`Room "${roomFromUrl}" is full. Cannot join this game.`, 'error');
                        });
                    } else {
                        // Fallback to old method if new function not available
                        showAdvisory(`Room "${roomFromUrl}" is full. Cannot join this game.`, 'error');
                    }
                } else if (err.message.includes('Room not found')) {
                    console.log('ðŸŽ® Room does not exist, creating new room as first guest');
                    // If join fails because room doesn't exist, create the room (first guest becomes de facto host)
                    console.log(`ðŸŽ® Calling createGameRoom with: playerName="${playerFromUrl}", roomName="${roomFromUrl}"`);
                    createGameRoom(playerFromUrl, 2, 0, null, roomFromUrl, roomFromUrl).then(createData => {
                        currentUserId = createData.userId;
                        isHost = true; // First player to create the room becomes the host
                        console.log('ðŸŽ® First guest created and joined new room as host');
                        subscribeToGameRoom();
                    }).catch(createErr => {
                        console.error('Failed to create room:', createErr);
                        
                        // If room creation fails because it already exists, try to join it
                        if (createErr.message && createErr.message.includes('already exists')) {
                            console.log('ðŸŽ® Room now exists, attempting to join instead...');
                            console.log(`ðŸŽ® Retry - Calling joinGameRoom with: roomId="${roomFromUrl}", playerName="${playerFromUrl}"`);
                            joinGameRoom(roomFromUrl, playerFromUrl).then(joinData => {
                                currentUserId = joinData.userId;
                                isHost = false;
                                console.log('ðŸŽ® Successfully joined existing room');
                                subscribeToGameRoom();
                            }).catch(joinErr => {
                                console.error('Failed to join after create failure:', joinErr);
                                showAdvisory('Unable to join room. It may be full or the game may have started.', 'error');
                                // Redirect back to room selection after 3 seconds
                                setTimeout(() => {
                                    window.location.href = 'available_rooms.html';
                                }, 3000);
                            });
                        } else {
                            showAdvisory('Failed to create room: ' + createErr.message, 'error');
                        }
                    });
                } else {
                    console.log('ðŸŽ® Unknown error joining room:', err.message);
                    showAdvisory('Failed to join room: ' + err.message, 'error');
                }
            });
        } else {
            // Host player - just subscribe to the room (room should already exist)
            console.log('ðŸŽ® Host player subscribing to room:', roomFromUrl);
            currentUserId = uidFromUrl || null;
            subscribeToGameRoom();
            console.log('ðŸŽ® Host player subscribed to room');
        }
    }

    // Auto start AI game if ai parameter provided and not joining a room
    const aiBots = parseInt(params.get('ai'), 10);
    const humanPlayers = parseInt(params.get('humans'), 10);
    if (!roomFromUrl && !isNaN(aiBots)) {
        const playerName = playerFromUrl || 'Player';
        const nameInput = document.getElementById('player1-name');
        if (nameInput && (!nameInput.value || nameInput.value === 'Player1')) {
            nameInput.value = playerName;
        }
        const humanCount = !isNaN(humanPlayers) ? humanPlayers : 1;
        startAIGame(playerName, aiBots, humanCount);
    }
});

// Add debug logging for positions loading
async function loadPositions() {
    try {
        const response = await fetch('positions_updated.json');
        if (!response.ok) {
            throw new Error('Failed to load positions: ' + response.statusText);
        }
        const positionsArray = await response.json();
        console.log('Loaded positions:', positionsArray.length, 'entries');
        
        // Create positions map
        positionsMap = new Map();
        positionsArray.forEach(p => {
            if (!p.name || typeof p.x !== 'number' || typeof p.y !== 'number') {
                console.error('Invalid position entry:', p);
                return;
            }
            positionsMap.set(p.name, { x: p.x, y: p.y });
        });
        
        console.log('Position map created with', positionsMap.size, 'entries');
        
        // Validate all required positions are present
        const requiredPositions = [
            ...gamePath,
            ...uPath,
            ...snakePath1,
            ...snakePath2
        ];
        
        const missingPositions = requiredPositions.filter(pos => !positionsMap.has(pos));
        if (missingPositions.length > 0) {
            console.error('Missing required positions:', missingPositions);
            throw new Error('Missing required positions: ' + missingPositions.join(', '));
        }
        
        // Log a few key positions for verification
        const keyPositions = ['go', 'jail', 'yingyang', 'gojail'];
        keyPositions.forEach(pos => {
            const coords = positionsMap.get(pos);
            console.log(`Key position ${pos}:`, coords ? `found at (${coords.x}, ${coords.y})` : 'NOT FOUND');
        });
        
        // Set the positions map in game_utils
        setPositionsMap(positionsMap);
        return positionsMap;
    } catch (error) {
        console.error('Error loading positions:', error);
        throw error;
    }
}

// Modified initGame function
async function initGame() {
    try {
        console.log('Initializing game...');
        
        // Check if game is already initialized - prevent duplicate initialization
        if (isGameInitialized && canvas && positionsMap && Object.keys(positionsMap).length > 0) {
            console.log('Game already fully initialized, skipping initGame');
            return;
        }
        
        // Check if initialization is already in progress
        if (isInitializing) {
            console.log('Game initialization already in progress, skipping duplicate initGame call');
            return;
        }
        
        // Set initialization flag
        isInitializing = true;
        console.log('Setting isInitializing = true');
        
        // Detect mobile and initialize touch controls
        detectMobile();
        
        // Apply development deadlock fix
        applyDevelopmentDeadlockFix();
        
        // Apply critical Firebase data corruption fix
        applyFirebaseDataCorruptionFix();
        
        // Mobile-specific initialization delay to ensure DOM is ready
        if (isMobile) {
            console.log('ðŸ“± Mobile device detected in initGame - adding initialization delay');
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // AGGRESSIVE duplicate prevention - remove ALL canvases from entire document
        const allCanvasesInDocument = document.querySelectorAll('canvas');
        if (allCanvasesInDocument.length > 0) {
            console.log('AGGRESSIVE CLEANUP: Removing', allCanvasesInDocument.length, 'canvas elements from entire document');
            allCanvasesInDocument.forEach(canvasEl => {
                console.log('Removing canvas:', canvasEl.id || 'no-id', 'from parent:', canvasEl.parentElement?.id || 'no-parent-id');
                canvasEl.remove();
            });
        }
        
        // Reset all canvas-related global variables
        canvas = null;
        ctx = null;
        console.log('Reset canvas global variables');

        // Load positions first
        console.log('Loading positions...');
        positionsMap = await loadPositions();
        console.log('Positions loaded successfully');

        // Initialize the game board
        const container = document.getElementById('game-container');
        console.log('Container found:', !!container);
        
        try {
            console.log('About to call renderBoard with board.png...');
            canvas = await renderBoard(container, 'assets/images/board.png', { width: 1000, height: 1000 });
            console.log('renderBoard completed successfully, canvas:', !!canvas);
            console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);
        } catch (renderError) {
            console.error('Error in renderBoard:', renderError);
            throw new Error('Failed to render board: ' + renderError.message);
        }
        
        // Load and store the board image for future use
        console.log('Loading board image for caching...');
        boardImage = new Image();
        boardImage.src = 'assets/images/board.png';
        await new Promise((resolve, reject) => {
            boardImage.onload = () => {
                console.log('Board image loaded for caching, dimensions:', boardImage.naturalWidth, 'x', boardImage.naturalHeight);
                resolve();
            };
            boardImage.onerror = (error) => {
                console.error('Failed to load board image for caching:', error);
                reject(error);
            };
        });

        // Outer background now handled by CSS body background for full-screen coverage
        // No need to load outerBackgroundImage anymore

        // Load and store the internal background image for layering behind the board
        console.log('Loading internal background image for layering...');
        backgroundImage = new Image();
        backgroundImage.src = 'assets/images/back5.png';

        // Load witch face image for gojail effect
        console.log('Loading witch face image...');
        witchFaceImage = new Image();
        witchFaceImage.src = 'assets/images/witchface.jpg';
        await new Promise((resolve, reject) => {
            backgroundImage.onload = () => {
                console.log('âœ… Internal background image loaded for layering, dimensions:', backgroundImage.naturalWidth, 'x', backgroundImage.naturalHeight);
                console.log('âœ… Internal background image src:', backgroundImage.src);
                console.log('âœ… Internal background image complete:', backgroundImage.complete);
                resolve();
            };
            backgroundImage.onerror = (error) => {
                console.error('âŒ Failed to load internal background image for layering:', error);
                console.error('âŒ Internal background image src:', backgroundImage.src);
                reject(error);
            };
        });

        // Load development images
        await loadDevelopmentImages();
        console.log('Board and development images loaded');
        
        // Set game start timestamp for deterministic multiplayer synchronization
        if (!window.gameStartTimestamp) {
            window.gameStartTimestamp = Date.now();
            console.log('Game start timestamp set:', window.gameStartTimestamp);
        }
        
        // Start snake path money spawning system
        if (snakePathMoneyTimer) {
            clearTimeout(snakePathMoneyTimer);
        }
        spawnSnakePathMoney(); // Spawn first money immediately
        // Enforce alternating bolt prizes across snake path money
        try {
            enforceAlternatingBoltPrizes();
            if (snakePathBoltTimer) clearInterval(snakePathBoltTimer);
            snakePathBoltTimer = setInterval(() => {
                enforceAlternatingBoltPrizes();
            }, 3000);
        } catch (_) {}
        console.log('Snake path money spawning system started for new game');
        
        // Add canvas click event listener for coordinate recording and property stealing
        if (canvas) {
            canvas.addEventListener('click', handleCanvasClick);
            console.log('Canvas click event listener added');
        }

        // Initialize music toggle (now a 3-state button)
        const musicToggle = document.getElementById('music-toggle');
        if (musicToggle) {
            musicToggle.addEventListener('click', () => {
                cycleMusicState();
            });
            
            // Add mobile touch support
            musicToggle.addEventListener('touchend', (e) => {
                e.preventDefault();
                cycleMusicState();
            }, { passive: false });
            
            // Initialize button appearance
            updateMusicButton();
        }

        // Initialize dice elements
        die1Element = document.getElementById('die1');
        die2Element = document.getElementById('die2');
        
        if (!die1Element || !die2Element) {
            throw new Error('Dice elements not found');
        }

        // Calculate exit target indices
        for (const pathKey in paths) {
            const pathConfig = paths[pathKey];
            if (pathConfig.exitTargetForward) {
                pathConfig.exitTargetForwardIndex = gamePath.indexOf(pathConfig.exitTargetForward);
            }
            if (pathConfig.exitTargetReverse) {
                pathConfig.exitTargetReverseIndex = gamePath.indexOf(pathConfig.exitTargetReverse);
            }
        }

        // Initialize dice click handler
        const diceSection = document.getElementById('dice-section');
        if (!diceSection) {
            throw new Error('Dice section not found');
        }

        diceSection.addEventListener('click', async () => {
            await handleDiceClick('main');
        });

        // Add universal touch support for dice section (works on all devices)
        diceSection.addEventListener('touchstart', handleDiceTouchStart, { passive: false });
        diceSection.addEventListener('touchend', handleDiceTouchEnd, { passive: false });
        console.log('Added universal touch event listeners to dice section');

        // Make the info panel draggable but don't show it yet
        const infoPanel = document.getElementById('info-panel');
        if (infoPanel) {
            makeElementDraggable(infoPanel);
        }

        // Add test shortcut for gojail glow effect (Ctrl + G)
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey && event.key === 'g') {
                console.log('Test shortcut activated - triggering gojail glow');
                activateGojailGlow();
            }
        });

        // Initialize ambient sound system
        console.log('ðŸŒ¬ï¸ Starting ambient sound system...');
        initializeAmbientSounds();
        
        // Set initialization flags
        isGameInitialized = true;
        isInitializing = false;
        console.log('Game initialization complete - isGameInitialized = true, isInitializing = false');
    } catch (error) {
        console.error('Error initializing game:', error);
        isInitializing = false; // Reset flag on error
        throw error;
    }
}

function rollDie() {
    return Math.floor(Math.random() * 6) + 1;
}

// --- NEW: Function to make the info panel draggable ---
function makeElementDraggable(elmnt) {
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    let isDragging = false;

    // Find the header element for dragging
    const header = elmnt.querySelector('#info-panel-header');
    const dragHandle = header || elmnt; // Fallback to entire panel if no header

    // Make the header draggable (or entire panel if no header)
    dragHandle.onmousedown = dragMouseDown;
    dragHandle.ontouchstart = dragMouseDown;

    function dragMouseDown(e) {
        // Don't start dragging if clicking on the minimize button
        if (e.target && e.target.id === 'minimize-info-panel') {
            return;
        }
        
        e.preventDefault();
        isDragging = true;
        // Get the initial cursor position
        pos3 = e.clientX || e.touches[0].clientX;
        pos4 = e.clientY || e.touches[0].clientY;
        // Set up events to stop dragging
        document.onmouseup = closeDragElement;
        document.ontouchend = closeDragElement;
        // Set up events to handle dragging
        document.onmousemove = elementDrag;
        document.ontouchmove = elementDrag;
    }

    function elementDrag(e) {
        if (!isDragging) return;
        e.preventDefault();
        // Calculate the new cursor position
        const currentX = e.clientX || e.touches[0].clientX;
        const currentY = e.clientY || e.touches[0].clientY;
        pos1 = pos3 - currentX;
        pos2 = pos4 - currentY;
        pos3 = currentX;
        pos4 = currentY;
        // Set the element's new position
        elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
        elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
    }

    function closeDragElement() {
        isDragging = false;
        // Stop moving when the mouse button or touch is released
        document.onmouseup = null;
        document.onmousemove = null;
        document.ontouchend = null;
        document.ontouchmove = null;
    }
}

// Function to determine first player
async function determineFirstPlayer() {
    let humanTotal, aiTotal;
    let attempts = 0;
    const diceRollInfoEl = document.getElementById('dice-roll-info');
    const turnInfoEl = document.getElementById('turn-info');
    
    do {
        if (attempts > 0) {
            turnInfoEl.textContent = "It's a tie! Rolling again...";
            await new Promise(resolve => setTimeout(resolve, 1500));
        }
        
        const humanDie1 = rollDie();
        const humanDie2 = rollDie();
        humanTotal = humanDie1 + humanDie2;
        await animateDice(humanDie1, humanDie2);
        await new Promise(resolve => setTimeout(resolve, 1000)); // Pause for human roll visibility
        
        const aiDie1 = rollDie();
        const aiDie2 = rollDie();
        aiTotal = aiDie1 + aiDie2;
        await animateDice(aiDie1, aiDie2);
        
        // Use actual player names instead of hardcoded "Player 1" and "AI"
        const humanPlayerName = players[0]?.name || "Player 1";
        const aiPlayerName = players[1]?.name || "AI";
        
        diceRollInfoEl.textContent = `${humanPlayerName} rolled ${humanTotal}, ${aiPlayerName} rolled ${aiTotal}`;
        attempts++;
    } while (humanTotal === aiTotal);
    
    // Use actual player names in the final message
    const humanPlayerName = players[0]?.name || "Player 1";
    const aiPlayerName = players[1]?.name || "AI";
    const message = humanTotal > aiTotal ? `${humanPlayerName} goes first!` : `${aiPlayerName} goes first!`;
    if (humanTotal > aiTotal) {
        currentPlayerIndex = 0;
        isAITurn = false;
    } else {
        currentPlayerIndex = 1;
        isAITurn = true;
    }

    players.forEach((p, index) => p.isCurrentPlayer = (index === currentPlayerIndex));
    await updateGameFrame();

    if (turnInfoEl) turnInfoEl.textContent = message;
    if (diceRollInfoEl) diceRollInfoEl.textContent = ``; // Clear dice roll info to avoid duplicate turn display

    // Set initial dice UI state correctly using enableDiceSection
    enableDiceSection();

    // Now that the first player and their turn type (AI/Human) are set, and UI is ready,
    // initiate their turn process.
    if (isAITurn) {
        // If AI is first, directly call handleAITurn after a short delay for message visibility.
        setTimeout(() => handleAITurn(), 1500); 
    } else {
        // If Human is first, start their auto-roll timer.
        startAutoRollTimer();
    }

    return message;
}

// Determine first player for multiplayer games by having each player roll the dice
async function determineFirstPlayerMultiplayer() {
    const diceRollInfoEl = document.getElementById('dice-roll-info');
    const turnInfoEl = document.getElementById('turn-info');
    let winners;

    // Validate players array
    if (!Array.isArray(players) || players.length === 0) {
        console.error('[determineFirstPlayerMultiplayer] Critical error: players array is invalid:', players);
        throw new Error('No players available for first player determination');
    }

    console.log('[determineFirstPlayerMultiplayer] Starting with players:', players.map(p => p.name));
    console.log('[determineFirstPlayerMultiplayer] Player objects:', players);

    do {
        winners = [];
        let highest = 0;

        for (const player of players) {
            if (!player || !player.name) {
                console.error('[determineFirstPlayerMultiplayer] Invalid player found:', player);
                continue;
            }
            
            const die1 = rollDie();
            const die2 = rollDie();
            const total = die1 + die2;
            await animateDice(die1, die2);
            if (diceRollInfoEl) diceRollInfoEl.textContent = `${player.name} rolled ${total}`;
            await new Promise(resolve => setTimeout(resolve, 1000));

            if (total > highest) {
                highest = total;
                winners = [player];
            } else if (total === highest) {
                winners.push(player);
            }
        }

        if (winners.length === 0) {
            console.error('[determineFirstPlayerMultiplayer] No winners found, defaulting to first player');
            winners = [players[0]];
            break;
        }

        if (winners.length > 1) {
            if (turnInfoEl) turnInfoEl.textContent = "It's a tie! Rolling again...";
            await new Promise(resolve => setTimeout(resolve, 1500));
        }
    } while (winners.length > 1);

    const winner = winners[0];
    if (!winner) {
        console.error('[determineFirstPlayerMultiplayer] Winner is undefined, defaulting to first player');
        currentPlayerIndex = 0;
    } else {
        console.log('[determineFirstPlayerMultiplayer] Winner object:', winner);
        console.log('[determineFirstPlayerMultiplayer] Winner name:', winner.name);
        // Use player name to find index instead of object reference
        currentPlayerIndex = players.findIndex(p => p.name.toLowerCase() === winner.name.toLowerCase());
        if (currentPlayerIndex === -1) {
            console.error('[determineFirstPlayerMultiplayer] Winner not found in players array, defaulting to index 0');
            console.error('[determineFirstPlayerMultiplayer] Winner name:', winner.name);
            console.error('[determineFirstPlayerMultiplayer] Available players:', players.map(p => p.name));
            currentPlayerIndex = 0;
        }
    }
    
    // Validate the final currentPlayerIndex
    if (currentPlayerIndex < 0 || currentPlayerIndex >= players.length) {
        console.error('[determineFirstPlayerMultiplayer] Invalid currentPlayerIndex, resetting to 0');
        currentPlayerIndex = 0;
    }

    console.log('[determineFirstPlayerMultiplayer] Set currentPlayerIndex to:', currentPlayerIndex, 'Player:', players[currentPlayerIndex]?.name);
    
    players.forEach((p, index) => p.isCurrentPlayer = (index === currentPlayerIndex));
    await updateGameFrame();
    enableDiceSection();
    if (diceRollInfoEl) diceRollInfoEl.textContent = '';
    
    const finalWinner = players[currentPlayerIndex];
    const message = `${finalWinner.name} goes first!`;
    if (turnInfoEl) turnInfoEl.textContent = message;
    return message;
}

// Function to handle AI turn
// Add a flag to prevent multiple simultaneous AI turns
let isAITurnInProgress = false;

async function handleAITurn() {
    console.log('[handleAITurn] Called.');

    if (isGameOver) {
        console.log('[handleAITurn] Game over detected. Aborting AI turn.');
        return;
    }
    
    // Prevent multiple simultaneous AI turns
    if (isAITurnInProgress) {
        console.warn('[handleAITurn] AI turn already in progress, aborting duplicate call.');
        return;
    }
    
    isAITurnInProgress = true;
    
    // Add safety timeout for AI turns to prevent hanging
    const aiTurnStartTime = Date.now();
    let aiTurnCompleted = false;
    
    const aiTurnTimeout = setTimeout(() => {
        if (!aiTurnCompleted && isAITurnInProgress) {
            console.error(`ðŸš¨ AI turn timeout after ${Date.now() - aiTurnStartTime}ms - forcing reset`);
            isAITurnInProgress = false;
            
            // Clear any other timeouts to prevent cascading
            clearTimeout(aiTurnTimeout);
            
            // Only advance turn if we're still stuck
            if (isAITurnInProgress) {
                console.log('ðŸ”„ Advancing to next turn due to timeout');
                nextTurn();
            }
        }
    }, 30000); // 30 second timeout for AI turns
    
    try {
        // Check all players for bankruptcy before turn starts
        console.log('[handleAITurn] Checking all players for bankruptcy before turn.');
        checkAllPlayersBankruptcy();
    
        const ai = players[currentPlayerIndex];

        if (!ai) {
            console.error('[handleAITurn] CRITICAL: AI player object is undefined at currentPlayerIndex:', currentPlayerIndex);
            // Clear the AI turn flag before exiting
            aiTurnCompleted = true;
            clearTimeout(aiTurnTimeout);
            isAITurnInProgress = false;
            nextTurn(); 
            return;
        }
        if (!ai.isAI) {
            console.warn(`[handleAITurn] WARNING: Called for player ${ai.name}, who is NOT an AI. Current isAITurn: ${isAITurn}. Aborting AI logic and attempting to correct via nextTurn().`);
            
            // Clear the timeout and flag
            aiTurnCompleted = true;
            clearTimeout(aiTurnTimeout);
            isAITurnInProgress = false;
            
            // Fix the global AI turn flag
            isAITurn = false;
            
            // Don't call nextTurn if we're already in the right turn
            const currentPlayer = players[currentPlayerIndex];
            if (currentPlayer && !currentPlayer.isAI) {
                console.log(`[handleAITurn] Already on human player ${currentPlayer.name} - no turn advance needed`);
                return;
            }
            
            nextTurn();
            return;
        }
        
        // Check if current AI player is bankrupt
        if (ai.bankrupt) {
            console.log(`[handleAITurn] AI ${ai.name} is bankrupt. Skipping turn.`);
            // Clear the AI turn flag before exiting
            aiTurnCompleted = true;
            clearTimeout(aiTurnTimeout);
            isAITurnInProgress = false;
            nextTurn();
            return;
        }

        // Consider using a steal card before rolling
        if (ai.stealCards > 0) {
            await aiUseStealCard(ai);
        }

    console.log(`[handleAITurn] AI Turn for: ${ai.name}.`);
    await new Promise(resolve => setTimeout(resolve, 1000)); 

    const die1 = rollDie();
    const die2 = rollDie();
    const totalRoll = die1 + die2;
    console.log(`[handleAITurn] ${ai.name} rolled: ${die1} + ${die2} = ${totalRoll}.`);
    
    // Play dice roll sound
    await playDiceRollSound();
    
    await animateDice(die1, die2);
    updateInfoPanel(die1, die2);
    console.log(`[handleAITurn] Moving ${ai.name} by ${totalRoll} spaces.`);
    const turnEnded = await moveToken(ai, totalRoll);
    if (turnEnded) {
        console.log(`[handleAITurn] ${ai.name} turn ended early (e.g., sent to jail). Exiting handleAITurn.`);
        // Clear the AI turn flag before exiting
        aiTurnCompleted = true;
        clearTimeout(aiTurnTimeout);
        isAITurnInProgress = false;
        return;
    }
    console.log(`[handleAITurn] ${ai.name} landed on: ${ai.currentSquare}.`);
    
    // Sync state to Firebase after movement in multiplayer mode (batched)
    if (isMultiplayerGame) {
        syncGameStateToFirebase(); // Use batched sync for AI movement
        console.log(`[handleAITurn] Scheduled sync after ${ai.name} movement.`);
    }
    
    // Special square handling is now done in checkGojailLanding after movement
    

    const landedPropertyInfo = getPropertyInfo(ai.currentSquare); 
    if (landedPropertyInfo) {
        console.log(`[handleAITurn] ${ai.name} landed on property: ${getPropertyDisplayName(landedPropertyInfo)}. Owner: ${landedPropertyInfo.state.owner || 'None'}.`);
        await handlePropertyLanding(ai, landedPropertyInfo); 

        if (!landedPropertyInfo.state.owner && ai.money >= landedPropertyInfo.cost) {
            console.log(`[handleAITurn] ${ai.name} evaluating purchase of unowned property: ${getPropertyDisplayName(landedPropertyInfo)}.`);
            const shouldBuy = calculateAIPurchaseStrategy(landedPropertyInfo);
            if (shouldBuy) {
                console.log(`[handleAITurn] ${ai.name} decided to BUY ${getPropertyDisplayName(landedPropertyInfo)} for Â£${landedPropertyInfo.cost}.`);
                ai.money -= landedPropertyInfo.cost;
                checkBankruptcy(ai);
                landedPropertyInfo.state.owner = ai.name;
                landedPropertyInfo.state.ownerColor = ai.color || getPlayerColor(ai.name);
                ai.properties.push(landedPropertyInfo.square);
                console.log(`[handleAITurn] Global propertyState for ${landedPropertyInfo.square} owner is now: ${propertyState[landedPropertyInfo.square].owner}`);
                
                // Check if this purchase completed a property set
                if (checkPropertySetCompletion(ai, landedPropertyInfo.square)) {
                    showAdvisory(`${ai.name} purchased ${getPropertyDisplayName(landedPropertyInfo)} and completed a property set!`, 'payment');
                    await playProperty3Sound(); // Play property set completion sound
                } else {
                    showAdvisory(`${ai.name} purchased ${getPropertyDisplayName(landedPropertyInfo)}`, 'payment');
                    await playHouseSound();
                }
                updateInfoPanel(); 
                await updateGameFrame();
            } else {
                console.log(`[handleAITurn] ${ai.name} decided NOT to buy ${getPropertyDisplayName(landedPropertyInfo)}.`);
                showAdvisory(`${ai.name} declined to purchase ${getPropertyDisplayName(landedPropertyInfo)}`, 'info');
            }
        } else if (landedPropertyInfo.state.owner) {
            console.log(`[handleAITurn] Property ${getPropertyDisplayName(landedPropertyInfo)} is already owned by ${landedPropertyInfo.state.owner}. No purchase action for AI.`);
        } else {
            console.log(`[handleAITurn] ${ai.name} cannot afford ${getPropertyDisplayName(landedPropertyInfo)} or it's not purchasable. Money: ${ai.money}, Cost: ${landedPropertyInfo.cost}`);
        }
        
        console.log(`[handleAITurn] ${ai.name} considering property development.`);
        await handleAIPropertyDevelopment(ai);
    } else {
        console.log(`[handleAITurn] ${ai.name} landed on a non-property square: ${ai.currentSquare}.`);
    }

    // Check if AI should use steal cards
    if (ai.stealCards > 0) {
        console.log(`[handleAITurn] ${ai.name} has ${ai.stealCards} steal card(s). Considering using one.`);
        await aiUseStealCard(ai);
    }

    console.log(`[handleAITurn] Updating game frame and info panel for ${ai.name} post-actions.`);
    await updateGameFrame();
    updateInfoPanel();

    if (die1 === die2) {
        lastRollWasDoubles = true;
        consecutiveDoublesCount++;
        console.log(`[handleAITurn] ${ai.name} rolled doubles. Consecutive doubles: ${consecutiveDoublesCount}.`);
        
        // Show green "Double!" message and play double sound
        showFlashMessage('DOUBLE!', '#00ff00', 'doubleFlash');
        await playDoubleSound();
        
        // Trigger eye glow animation
        setDoublesState(true);
        if (consecutiveDoublesCount === 3) {
            console.log(`[handleAITurn] ${ai.name} rolled 3 consecutive doubles. Going to jail.`);
            
            // Play 3 doubles sound
            await playThreeDoublesSound();
            
            await sendPlayerToJail(ai); // Use sendPlayerToJail
            consecutiveDoublesCount = 0;
            lastRollWasDoubles = false;
            console.log(`[handleAITurn] ${ai.name} sent to jail. Turn ends, calling nextTurn().`);
            // Mark AI turn as completed and clear timeout before calling nextTurn
            aiTurnCompleted = true;
            clearTimeout(aiTurnTimeout);
            isAITurnInProgress = false;
            nextTurn();
            return;
        } else {
            // Check if player is on special path - if so, immediate exit instead of normal movement
            const specialPathExit = await handleDoublesOnSpecialPath(ai);
            if (specialPathExit) {
                console.log(`[handleAITurn] ${ai.name} exited special path due to doubles. Continuing turn.`);
                // Continue with property logic at exit position, then handle doubles continuation
                const propertyInfo = getPropertyInfo(ai.currentSquare);
                if (propertyInfo) {
                    await handlePropertyLanding(ai, propertyInfo);
                    if (!propertyInfo.state.owner && ai.isAI) {
                        await handleAIPropertyPurchase(ai, propertyInfo);
                    }
                }
                
                // Schedule next turn for doubles
                showAdvisory("Doubles! AI rolls again!", 'turn');
                console.log(`[handleAITurn] ${ai.name} gets another turn due to doubles. Same player continues.`);
                
                // Clear the flag before scheduling the next turn to allow the callback to proceed
                isAITurnInProgress = false;
                
                setTimeout(async () => {
                    console.log(`[handleAITurn] setTimeout callback: Re-calling handleAITurn for ${ai.name} (doubles after special path exit).`);
                    const currentPlayer = players[currentPlayerIndex];
                    if (currentPlayer && currentPlayer.isAI && currentPlayer.name === ai.name) {
                        await handleAITurn();
                    } else {
                        console.warn(`[handleAITurn] setTimeout callback: Turn has changed, canceling scheduled AI turn. Current: ${currentPlayer?.name}, Expected: ${ai.name}`);
                    }
                }, 2000);
                return;
            }
            
            showAdvisory("Doubles! AI rolls again!", 'turn');
            console.log(`[handleAITurn] ${ai.name} gets another turn due to doubles. Same player continues.`);
            console.log(`[handleAITurn] Scheduling another AI turn in 2 seconds...`);
            
            // Clear the flag before scheduling the next turn to allow the callback to proceed
            isAITurnInProgress = false;
            
            setTimeout(async () => {
                console.log(`[handleAITurn] setTimeout callback: Re-calling handleAITurn for ${ai.name} (doubles).`);
                // Double-check that it's still this AI's turn before proceeding
                const currentPlayer = players[currentPlayerIndex];
                if (currentPlayer && currentPlayer.isAI && currentPlayer.name === ai.name) {
                    await handleAITurn();
                } else {
                    console.warn(`[handleAITurn] setTimeout callback: Turn has changed, canceling scheduled AI turn. Current: ${currentPlayer?.name}, Expected: ${ai.name}`);
                }
            }, 2000);
        }
        // Important: Return here to prevent nextTurn() from being called
        console.log(`[handleAITurn] Completed with doubles - turn continues with same player.`);
        return;
    } else { // Not a double - turn ends, advance to next player
        lastRollWasDoubles = false;
        consecutiveDoublesCount = 0;
        console.log(`[handleAITurn] ${ai.name} did not roll doubles. Turn ends. Calling nextTurn().`);
        // Mark AI turn as completed and clear timeout before calling nextTurn
        aiTurnCompleted = true;
        clearTimeout(aiTurnTimeout);
        isAITurnInProgress = false;
        nextTurn();
    }
    console.log('[handleAITurn] Completed.');
    
    } catch (error) {
        console.error('[handleAITurn] Error during AI turn:', error);
        // If there's an error, advance to next turn to prevent getting stuck
        aiTurnCompleted = true;
        clearTimeout(aiTurnTimeout);
        isAITurnInProgress = false;
        nextTurn();
    } finally {
        // Always clear the flag to prevent deadlocks
        // The flag is already cleared before scheduling doubles callbacks above
        if (isAITurnInProgress) {
            console.log('[handleAITurn] Clearing isAITurnInProgress flag in finally block');
            isAITurnInProgress = false;
        }
    }
}

// Function to count how many crypts a player currently owns
function countPlayerCrypts(player) {
    let cryptCount = 0;
    if (player.properties) {
        player.properties.forEach(square => {
            const state = propertyState[square];
            if (state && state.hasCrypt) {
                cryptCount++;
            }
        });
    }
    return cryptCount;
}

// Function to calculate AI purchase strategy (also used for AI analysis for human players)
function calculateAIPurchaseStrategy(propertyInfo) {
    const player = players[currentPlayerIndex];
    const displayName = getPropertyDisplayName(propertyInfo);
    const isActualAI = player.isAI;
    const logPrefix = isActualAI ? `AI ${player.name}` : `AI Analysis for ${player.name}`;
    
    // Basic affordability check
    if (player.money < propertyInfo.cost) {
        console.log(`${logPrefix} cannot afford ${displayName} (cost: Â£${propertyInfo.cost}, money: Â£${player.money})`);
        return false;
    }
    
    // Check crypt limit for AI players only
    if (isActualAI && propertyInfo.cryptCost > 0) {
        const currentCrypts = countPlayerCrypts(player);
        if (currentCrypts >= 2) {
            console.log(`${logPrefix} declining ${displayName} - already owns ${currentCrypts} crypts (max 2 per AI player)`);
            return false;
        }
    }
    
    // Calculate minimum cash reserve needed (based on potential rent payments)
    const minCashReserve = Math.max(500, player.money * 0.25); // Keep at least 25% of money or Â£500, whichever is higher
    const availableForPurchase = player.money - minCashReserve;
    
    // Don't buy if it would leave us below our minimum cash reserve
    if (propertyInfo.cost > availableForPurchase) {
        console.log(`${logPrefix} declining ${displayName} - would leave insufficient cash reserve. Cost: Â£${propertyInfo.cost}, Available: Â£${availableForPurchase}, Reserve needed: Â£${minCashReserve}`);
        return false;
    }
    
    // Check if we already own properties in this group
    const ownedInGroup = propertyGroups[propertyInfo.group].positions.filter(
        pos => propertyState[pos].owner === player.name
    ).length;
    
    // Strategic priority: Complete groups for development potential
    if (ownedInGroup > 0) {
        const totalInGroup = propertyGroups[propertyInfo.group].positions.length;
        const completionPercentage = (ownedInGroup + 1) / totalInGroup;
        
        // More likely to buy if it gets us closer to completing the group
        if (completionPercentage >= 0.75) { // 75% or more of group
            console.log(`${logPrefix} prioritizing ${displayName} - would complete ${Math.round(completionPercentage * 100)}% of ${propertyInfo.group} group`);
            return true;
        } else if (completionPercentage >= 0.5) { // 50% or more of group
            console.log(`${logPrefix} considering ${displayName} - would own ${Math.round(completionPercentage * 100)}% of ${propertyInfo.group} group`);
            return Math.random() < 0.7; // 70% chance
        }
    }
    
    // Conservative approach: Only buy if we have substantial money left after purchase
    const moneyAfterPurchase = player.money - propertyInfo.cost;
    const costToMoneyRatio = propertyInfo.cost / player.money;
    
    // Don't spend more than 40% of total money on a single property
    if (costToMoneyRatio > 0.4) {
        console.log(`${logPrefix} declining ${displayName} - too expensive relative to total money (${Math.round(costToMoneyRatio * 100)}% of total)`);
        return false;
    }
    
    // Buy if it's a good value (less than 20% of total money) and we have plenty left
    if (costToMoneyRatio < 0.2 && moneyAfterPurchase > minCashReserve * 2) {
        console.log(`${logPrefix} recommends buying ${displayName} - good value at ${Math.round(costToMoneyRatio * 100)}% of total money`);
        return true;
    }
    
    // Random chance (20%) to buy if none of the above conditions are met, but still conservative
    const randomBuy = Math.random() < 0.2;
    console.log(`${logPrefix} random purchase decision for ${displayName}: ${randomBuy} (cost ratio: ${Math.round(costToMoneyRatio * 100)}%)`);
    return randomBuy;
}

// Enhance AI property purchase function
async function handleAIPropertyPurchase(player, propertyInfo) {
    const shouldBuy = calculateAIPurchaseStrategy(propertyInfo);
    const displayName = getPropertyDisplayName(propertyInfo);
    
    if (shouldBuy) {
        player.money -= propertyInfo.cost;
        checkBankruptcy(player); // Check bankruptcy after spending money
        propertyState[propertyInfo.square].owner = player.name;
        propertyState[propertyInfo.square].declined = false;
        player.properties.push(propertyInfo.square);
        
        // Check if this purchase completed a property set
        if (checkPropertySetCompletion(player, propertyInfo.square)) {
            showAdvisory(`${player.name} purchased ${displayName} and completed a property set!`, 'payment');
            await playProperty3Sound(); // Play property set completion sound
        } else {
            showAdvisory(`${player.name} purchased ${displayName}`, 'payment');
            await playBellSound();
        }
        
        updateInfoPanel();
        console.log(`[handleAIPropertyPurchase] ${player.name} purchased ${displayName}. New money: Â£${player.money}`);
    } else {
        showAdvisory(`${player.name} declined to purchase ${displayName}`, 'info');
        propertyState[propertyInfo.square].declined = false;
        console.log(`[handleAIPropertyPurchase] ${player.name} declined to purchase ${displayName}`);
    }
}

// Function to handle AI property development
async function handleAIPropertyDevelopment(ai) {
    // Early exit if AI has very few properties or little money
    const ownedProperties = ai.properties || [];
    if (ownedProperties.length < 3 || ai.money < 500) {
        return; // Skip development logic entirely
    }
    
    // Calculate minimum cash reserve for development (more conservative)
    const minCashReserve = Math.max(800, ai.money * 0.35); // Keep at least 35% of money or Â£800
    const availableForDevelopment = ai.money - minCashReserve;
    
    if (availableForDevelopment < 200) {
        console.log(`AI ${ai.name} skipping development - insufficient funds after reserve. Available: Â£${availableForDevelopment}, Reserve: Â£${minCashReserve}`);
        return;
    }
    
    // Group properties by their group (only call getPropertyInfo once per property)
    const propertiesByGroup = {};
    const propertyInfoCache = {}; // Cache property info to avoid repeated lookups
    
    ownedProperties.forEach(square => {
        const propertyInfo = getPropertyInfo(square);
        if (!propertyInfo) return;
        
        propertyInfoCache[square] = propertyInfo; // Cache the info
        const group = propertyInfo.group;
        if (!propertiesByGroup[group]) {
            propertiesByGroup[group] = [];
        }
        propertiesByGroup[group].push(square);
    });
    
    // Prioritize groups by completion percentage and potential return
    const developmentPriorities = [];
    
    for (const [group, squares] of Object.entries(propertiesByGroup)) {
        // Allow development with 3+ properties for all groups (consistent with player development rules)
        if (squares.length < 3) continue;
        
        // Calculate development potential for this group
        const totalInGroup = propertyGroups[group].positions.length;
        const completionPercentage = squares.length / totalInGroup;
        
        // Add to priorities if we have enough properties
        developmentPriorities.push({
            group: group,
            squares: squares,
            completionPercentage: completionPercentage,
            priority: completionPercentage * 100 // Higher completion = higher priority
        });
    }
    
    // Sort by priority (highest first)
    developmentPriorities.sort((a, b) => b.priority - a.priority);
    
    // Develop properties in priority order, but be conservative about spending
    let totalSpentOnDevelopment = 0;
    const maxDevelopmentSpending = availableForDevelopment * 0.6; // Don't spend more than 60% of available funds
    
    for (const groupInfo of developmentPriorities) {
        for (const square of groupInfo.squares) {
            if (!canDevelopProperty(ai, square)) continue;
            
            const developmentCost = getDevelopmentCost(square);
            if (!developmentCost) continue;
            
            // Check if we can afford this development within our budget
            if (totalSpentOnDevelopment + developmentCost.cost > maxDevelopmentSpending) {
                console.log(`AI ${ai.name} stopping development - would exceed budget. Spent: Â£${totalSpentOnDevelopment}, Cost: Â£${developmentCost.cost}, Budget: Â£${maxDevelopmentSpending}`);
                break;
            }
            
            // Check crypt limit for AI players - limit to 2 crypts max per AI
            if (developmentCost.type === 'crypt') {
                const currentCrypts = countPlayerCrypts(ai);
                if (currentCrypts >= 2) {
                    console.log(`AI ${ai.name} skipping crypt development on ${square} - already owns ${currentCrypts} crypts (max 2 per AI player)`);
                    continue;
                }
            }
            
            // More conservative check: ensure we still have substantial money after this development
            const moneyAfterDevelopment = ai.money - developmentCost.cost;
            if (moneyAfterDevelopment < minCashReserve) {
                console.log(`AI ${ai.name} skipping development of ${square} - would leave insufficient reserve. After development: Â£${moneyAfterDevelopment}, Reserve needed: Â£${minCashReserve}`);
                continue;
            }
            
            const success = developProperty(ai, square);
            if (success) {
                totalSpentOnDevelopment += developmentCost.cost;
                const propertyInfo = propertyInfoCache[square]; // Use cached info
                const displayName = getPropertyDisplayName(propertyInfo);
                console.log(`AI ${ai.name} developed ${displayName} for Â£${developmentCost.cost}. Total development spending: Â£${totalSpentOnDevelopment}, Money remaining: Â£${ai.money}`);
                showAdvisory(
                    `${ai.name} developed ${displayName} with a ${developmentCost.type} for Â£${developmentCost.cost}`,
                    'development'
                );
                // Development sound is now played in developProperty function
                updateGameFrame();
                // Add a small delay between developments
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }
        
        // Stop if we've reached our spending limit
        if (totalSpentOnDevelopment >= maxDevelopmentSpending) {
            break;
        }
    }
    
    if (totalSpentOnDevelopment > 0) {
        console.log(`AI ${ai.name} completed development phase. Total spent: Â£${totalSpentOnDevelopment}, Money remaining: Â£${ai.money}`);
    }
}

// Function to rebuild player property arrays based on current propertyState ownership
function rebuildPlayerPropertyArrays() {
    console.log('ðŸ”§ Rebuilding player property arrays to match propertyState ownership...');
    
    if (!players || !Array.isArray(players)) {
        console.warn('rebuildPlayerPropertyArrays: No valid players array found');
        return;
    }
    
    // Clear all player property arrays first
    players.forEach(player => {
        if (player.properties) {
            const oldCount = player.properties.length;
            player.properties = [];
            console.log(`ðŸ”§ Cleared ${oldCount} properties from ${player.name}`);
        } else {
            player.properties = [];
        }
    });
    
    // Rebuild property arrays based on current ownership in propertyState
    Object.entries(propertyState).forEach(([square, state]) => {
        if (state.owner) {
            // Find the player who owns this property
            const ownerPlayer = players.find(p => p.name && p.name.toLowerCase() === state.owner.toLowerCase());
            if (ownerPlayer) {
                if (!ownerPlayer.properties.includes(square)) {
                    ownerPlayer.properties.push(square);
                    console.log(`ðŸ”§ Added ${square} to ${ownerPlayer.name}'s properties`);
                }
            } else {
                console.warn(`ðŸ”§ Could not find owner player "${state.owner}" for property ${square}`);
            }
        }
    });
    
    // Log final property counts
    players.forEach(player => {
        console.log(`ðŸ”§ ${player.name} final property count: ${player.properties.length} properties: [${player.properties.join(', ')}]`);
    });
    
    console.log('ðŸ”§ Player property arrays rebuilt successfully');
}

// Enhanced debug logging function
function debugLog(category, message, data = {}) {
    const timestamp = new Date().toISOString();
    const logMessage = `[${category}] ${message}`;
    
    console.log(logMessage);
    
    // Send to debug window if it exists
    try {
        const debugWindow = window.debugWindow || document.querySelector('iframe[src*="debug-turn-logic"]');
        if (debugWindow && debugWindow.contentWindow) {
            debugWindow.contentWindow.postMessage({
                type: 'debug-log',
                level: category.toLowerCase().includes('error') ? 'error' : 
                       category.toLowerCase().includes('warn') ? 'warning' : 'info',
                message: logMessage,
                data,
                timestamp
            }, '*');
        }
    } catch (e) {
        // Ignore if debug window not available
    }
}

// Modified takeTurn function
async function takeTurn() {
    const turnId = Math.random().toString(36).substr(2, 9);
    
    debugLog('TURN_START', `takeTurn Called [ID: ${turnId}]`, {
        turnId,
        currentPlayerIndex,
        playerName: players[currentPlayerIndex]?.name,
        isAI: players[currentPlayerIndex]?.isAI,
        isDiceRollInProgress,
        isNextTurnInProgress,
        lastRollWasDoubles,
        consecutiveDoublesCount,
        isGameOver
    });
    
    console.log(`[takeTurn] Called [ID: ${turnId}].`);
    console.log(`[takeTurn] Current player: ${players[currentPlayerIndex]?.name}, isDiceRollInProgress: ${isDiceRollInProgress} [ID: ${turnId}]`);
    
    if (isDiceRollInProgress) {
        console.log(`[takeTurn] Dice roll still in progress - aborting duplicate takeTurn call [ID: ${turnId}]`);
        return;
    }
    
    if (isGameOver) {
        console.log('[takeTurn] Game over detected. Aborting turn.');
        return;
    }
    
    // Set a safety flag to ensure this function completes
    const takeTurnStartTime = Date.now();
    let takeTurnCompleted = false;
    // Mirror to global for cross-scope safety checks
    if (typeof window !== 'undefined') { window.takeTurnCompleted = false; }
    
    // Safety timeout to detect if takeTurn gets stuck
    const takeTurnTimeout = setTimeout(() => {
        if (!takeTurnCompleted) {
            console.error(`ðŸš¨ takeTurn function timeout after ${Date.now() - takeTurnStartTime}ms - forcing reset`);
            isDiceRollInProgress = false;
            const diceSection = document.getElementById('dice-section');
            if (diceSection) {
                diceSection.style.pointerEvents = 'auto';
            }
        }
    }, 25000); // 25 second timeout for takeTurn
    clearAutoActionTimer(); // Clear any pending auto-action timer since player took action
    
    // Validate players array first
    if (!Array.isArray(players) || players.length === 0) {
        console.error('[takeTurn] Critical error: players array is invalid:', players);
        showAdvisory('Game error: No players found. Please restart the game.', 'error');
        clearTimeout(takeTurnTimeout);
        return;
    }
    
    // Validate currentPlayerIndex
    if (currentPlayerIndex < 0 || currentPlayerIndex >= players.length) {
        console.error('[takeTurn] Critical error: currentPlayerIndex out of bounds:', currentPlayerIndex, 'Players count:', players.length);
        currentPlayerIndex = 0; // Reset to first player as fallback
    }
    
    const player = players[currentPlayerIndex];

    if (!player) {
        console.error('[takeTurn] CRITICAL: Current player object is undefined at currentPlayerIndex:', currentPlayerIndex);
        console.error('[takeTurn] Players array:', players);
        
        // Try to find a valid player
        let foundValidPlayer = false;
        for (let i = 0; i < players.length; i++) {
            if (players[i] && !players[i].bankrupt) {
                console.log('[takeTurn] Recovering: Found valid player at index', i, ':', players[i].name);
                currentPlayerIndex = i;
                foundValidPlayer = true;
                break;
            }
        }
        
        if (!foundValidPlayer) {
            console.error('[takeTurn] No valid players found. Calling nextTurn to attempt recovery.');
            nextTurn(); // Attempt to recover
            return;
        }
    }
    
    // In multiplayer, check if it's actually this player's turn
    if (isMultiplayerGame) {
        const currentPlayer = players[currentPlayerIndex];
        const playerName = document.getElementById('player1-name').value.trim();
        
        if (!currentPlayer) {
            console.error('[takeTurn] Current player is undefined in multiplayer check');
            return;
        }
        
        if (currentPlayer.name !== playerName) {
            showAdvisory(`It's ${currentPlayer.name}'s turn, not yours!`, 'error');
            return;
        }
    }
    
    // Check all players for bankruptcy before turn starts
    console.log('[takeTurn] Checking all players for bankruptcy before turn.');
    checkAllPlayersBankruptcy();

    console.log(`[takeTurn] Current player: ${player.name}, Is AI: ${player.isAI}, Bankrupt: ${player.bankrupt}. Global isAITurn: ${isAITurn}.`);

    if (player.bankrupt) {
        console.log(`[takeTurn] Player ${player.name} is bankrupt. Calling nextTurn().`);
        nextTurn();
        return;
    }

    // This function should primarily handle human turns.
    // AI turns are supposed to be routed to handleAITurn() by nextTurn() or determineFirstPlayer().
    if (player.isAI || isAITurn) { // Double check consistency
        console.warn(`[takeTurn] WARNING: takeTurn() was called for AI player ${player.name} or global isAITurn is true. Routing to handleAITurn().`);
        
        // Check if AI turn is already in progress to prevent duplicate calls
        if (isAITurnInProgress) {
            console.warn(`[takeTurn] AI turn already in progress for ${player.name}. Aborting duplicate call.`);
            takeTurnCompleted = true;
            if (typeof window !== 'undefined') { window.takeTurnCompleted = true; }
            clearTimeout(takeTurnTimeout);
            return;
        }
        
        // Additional safety: clear any auto-action timers before starting AI turn
        clearAutoActionTimer();
        
        await handleAITurn();
        takeTurnCompleted = true;
        if (typeof window !== 'undefined') { window.takeTurnCompleted = true; }
        clearTimeout(takeTurnTimeout);
        return;
    }
    
    console.log(`[takeTurn] Human player ${player.name} is taking their turn.`);
    const die1 = rollDie();
    const die2 = rollDie();
    console.log(`[takeTurn] ${player.name} rolled: ${die1} + ${die2} = ${die1 + die2}.`);
    
    // Play dice roll sound
    await playDiceRollSound();
    
    await animateDice(die1, die2);
    updateInfoPanel(die1, die2); // Shows dice roll in UI
    
    console.log(`[takeTurn] Moving ${player.name} by ${die1 + die2} spaces.`);
    const turnEnded = await moveToken(player, die1 + die2);
    if (turnEnded) {
        console.log(`[takeTurn] ${player.name} turn ended early (e.g., sent to jail). Exiting takeTurn.`);
        return;
    }
    console.log(`[takeTurn] ${player.name} landed on: ${player.currentSquare}.`);
    
    // Wait for movement animation to fully complete before showing property details
    await new Promise(resolve => setTimeout(resolve, 300));
    
    // Sync state to Firebase after movement in multiplayer mode (batched)
    if (isMultiplayerGame) {
        syncGameStateToFirebase(); // Use batched sync for movement
        console.log(`[takeTurn] Scheduled sync after ${player.name} movement.`);
    }
    
    const currentPosition = player.currentSquare;
    
    // Special square handling is now done in checkGojailLanding after movement
    
    
    // Check for doubles FIRST before property logic
    const rolledDoubles = (die1 === die2);
    if (rolledDoubles) {
        lastRollWasDoubles = true;
        consecutiveDoublesCount++;
        console.log(`[takeTurn] ${player.name} rolled doubles. Consecutive doubles: ${consecutiveDoublesCount}.`);
        
        // Show green "Double!" message and play double sound
        showFlashMessage('DOUBLE!', '#00ff00', 'doubleFlash');
        await playDoubleSound();
        
        // Trigger eye glow animation
        setDoublesState(true);
        if (consecutiveDoublesCount === 3) {
            console.log(`[takeTurn] ${player.name} rolled 3 consecutive doubles. Going to jail.`);
            
            // Play 3 doubles sound
            await playThreeDoublesSound();
            
            await sendPlayerToJail(player); // Use sendPlayerToJail
            consecutiveDoublesCount = 0;
            lastRollWasDoubles = false;
            console.log(`[takeTurn] ${player.name} sent to jail. Turn ends, calling nextTurn().`);
            clearTimeout(takeTurnTimeout);
    isDiceRollInProgress = false; // Reset flag before calling nextTurn
            nextTurn();
            return;
        } else {
            // Check if player is on special path - if so, immediate exit instead of normal movement
            const specialPathExit = await handleDoublesOnSpecialPath(player);
            if (specialPathExit) {
                console.log(`[takeTurn] ${player.name} exited special path due to doubles. Continuing with property logic.`);
                // Continue with property logic at exit position
                const currentPosition = player.currentSquare;
                const propertyInfo = getPropertyInfo(currentPosition);
                
                if (propertyInfo) {
                    console.log(`[takeTurn] ${player.name} landed on property: ${getPropertyDisplayName(propertyInfo)} after special path exit. Owner: ${propertyInfo.state.owner || 'None'}. Calling handlePropertyLanding.`);
                    await handlePropertyLanding(player, propertyInfo);
                    
                    if (!propertyInfo.state.owner && !player.isAI) {
                        console.log(`[takeTurn] ${player.name} landed on unowned property after special path exit. Purchase decision pending. Doubles: ${rolledDoubles}`);
                        return; // Turn advancement handled by purchase/decline buttons
                    }
                    
                    // Check if player owns the property and can develop it
                    if (propertyInfo.state.owner === player.name && !player.isAI && canDevelopProperty(player, propertyInfo.square)) {
                        const devInfo = getDevelopmentCost(propertyInfo.square);
                        if (devInfo && player.money >= devInfo.cost) {
                            console.log(`[takeTurn] ${player.name} can develop their property after special path exit. Development decision pending. Doubles: ${rolledDoubles}`);
                            
                            // Disable dice section for development decision
                            const diceSection = document.getElementById('dice-section');
                            if (diceSection) {
                                console.log('[takeTurn] Disabling dice section (pointerEvents: none, class: dice-pulse-red) for development decision.');
                                diceSection.style.pointerEvents = 'none';
                                diceSection.classList.remove('dice-pulse', 'dice-pulse-blue');
                            }
                            
                            clearAutoRollTimer();
                            return; // Turn advancement handled by development/decline buttons
                        }
                    }
                } else {
                    console.log(`[takeTurn] ${player.name} landed on a non-property square: ${currentPosition} after special path exit.`);
                }
                
                // Handle doubles continuation after special path exit
                if (isMultiplayerGame) {
                    showAdvisory("Doubles! Click dice to roll again.", 'turn');
                    console.log(`[takeTurn] Multiplayer doubles after special path exit: Waiting for ${player.name} to click dice again.`);
                } else {
                    showAdvisory("Doubles! Auto-rolling again...", 'turn');
                    console.log(`[takeTurn] Single-player doubles after special path exit: Auto-rolling for ${player.name} after delay.`);
                    setTimeout(() => {
                        console.log(`[takeTurn] Auto-rolling for ${player.name} after doubles and special path exit`);
                        takeTurn();
                    }, 1500);
                }
                return;
            }
        }
    } else {
        lastRollWasDoubles = false;
        consecutiveDoublesCount = 0;
        console.log(`[takeTurn] ${player.name} did not roll doubles.`);
    }
    
    // Handle property logic
    const propertyInfo = getPropertyInfo(currentPosition);
    
    if (propertyInfo) {
        console.log(`[takeTurn] ${player.name} landed on property: ${getPropertyDisplayName(propertyInfo)}. Owner: ${propertyInfo.state.owner || 'None'}. Calling handlePropertyLanding.`);
        await handlePropertyLanding(player, propertyInfo);
        
        if (!propertyInfo.state.owner && !player.isAI) {
            console.log(`[takeTurn] ${player.name} landed on unowned property. Purchase decision pending. Doubles: ${rolledDoubles}`);
            // Return early to wait for purchase decision - the purchase/decline buttons will handle turn continuation
            // Turn advancement handled by purchase/decline buttons
            clearTimeout(takeTurnTimeout);
        isDiceRollInProgress = false; // Reset flag before early return
            return;
        }
        
        // Check if property is owned by someone else (rent was paid)
        if (propertyInfo.state.owner && propertyInfo.state.owner !== player.name) {
            console.log(`[takeTurn] ${player.name} landed on property owned by ${propertyInfo.state.owner}. Rent paid. Doubles: ${rolledDoubles}`);
            // Rent was already handled in handlePropertyLanding()
            // Continue to doubles check - no early return needed
        }
        // Check if player owns the property and can develop it
        else if (propertyInfo.state.owner === player.name && !player.isAI && canDevelopProperty(player, propertyInfo.square)) {
            const devInfo = getDevelopmentCost(propertyInfo.square);
            if (devInfo && player.money >= devInfo.cost) {
                console.log(`[takeTurn] ${player.name} can develop their property. Development decision pending. Doubles: ${rolledDoubles}`);
                
                // Disable dice section and clear any auto-roll timer to prevent buttons from disappearing
                const diceSection = document.getElementById('dice-section');
                if (diceSection) {
                    console.log('[takeTurn] Disabling dice section (pointerEvents: none, class: dice-pulse-red) for development decision.');
                    diceSection.style.pointerEvents = 'none';
                    diceSection.classList.remove('dice-pulse', 'dice-pulse-blue');
                    diceSection.classList.add('dice-pulse-red');
                }
                
                // Clear any existing auto-roll timer to prevent automatic turn advancement
                clearAutoRollTimer();
                
                // Show advisory message about development opportunity
                showAdvisory(`${player.name} can build a ${devInfo.type} for Â£${devInfo.cost}, skip development, or click dice to continue`, 'info');
                
                // Update the info panel to show development buttons
                updateInfoPanel(null, null, propertyInfo);
                await updateGameFrame();
                
                console.log('[takeTurn] Development decision pending. Turn flow paused, awaiting button click (handlePropertyDevelopment/handleDeclineDevelopment).');
                clearTimeout(takeTurnTimeout);
        isDiceRollInProgress = false; // Reset flag before early return
                return; // Turn advancement handled by development/decline buttons
            }
        }
    } else {
        console.log(`[takeTurn] ${player.name} landed on a non-property square: ${currentPosition}.`);
    }
    
    // Handle turn continuation based on doubles
    console.log(`[takeTurn] DOUBLES CHECK: die1=${die1}, die2=${die2}, rolledDoubles=${rolledDoubles}`);
    
    debugLog('DOUBLES_CHECK', `Doubles Check: die1=${die1}, die2=${die2}, rolledDoubles=${rolledDoubles}`, {
        turnId,
        die1,
        die2,
        rolledDoubles,
        playerName: player.name,
        isMultiplayerGame,
        consecutiveDoublesCount
    });
    
    if (rolledDoubles) {
        console.log(`[takeTurn] ${player.name} gets another turn (doubles). Handling continuation...`);
        
        debugLog('DOUBLES_CONTINUATION', `${player.name} gets another turn (doubles)`, {
            turnId,
            playerName: player.name,
            isMultiplayerGame,
            consecutiveDoublesCount
        });
        
        if (isMultiplayerGame) {
            // In multiplayer, show message and wait for manual dice click
            showAdvisory("Doubles! Click dice to roll again.", 'turn');
            console.log(`[takeTurn] Multiplayer doubles: Waiting for ${player.name} to click dice again.`);
            
            debugLog('MULTIPLAYER_DOUBLES_WAIT', `Waiting for ${player.name} to click dice again`, {
                turnId,
                playerName: player.name,
                action: 'waiting_for_click'
            });
            
            // Mark as completed and return - waiting for user click
            takeTurnCompleted = true;
            if (typeof window !== 'undefined') { window.takeTurnCompleted = true; }
            clearTimeout(takeTurnTimeout);
            isDiceRollInProgress = false;
            turnInProgress = false; // Reset turn in progress flag
            console.log(`[takeTurn] Completed (multiplayer doubles) - waiting for dice click.`);
            
            debugLog('TURN_END', `takeTurn completed - multiplayer doubles waiting`, {
                turnId,
                reason: 'multiplayer_doubles_wait'
            });
            
            return;
        } else {
            // In single-player, auto-roll after delay
            showAdvisory("Doubles! Auto-rolling again...", 'turn');
            console.log(`[takeTurn] Single-player doubles: Auto-rolling for ${player.name} after delay.`);
            setTimeout(() => {
                console.log(`[takeTurn] Auto-rolling for ${player.name} after doubles`);
                takeTurn();
            }, 1500);
            
            // Mark as completed and return - auto-roll scheduled
            takeTurnCompleted = true;
            if (typeof window !== 'undefined') { window.takeTurnCompleted = true; }
            clearTimeout(takeTurnTimeout);
            isDiceRollInProgress = false;
            turnInProgress = false; // Reset turn in progress flag
            console.log(`[takeTurn] Completed (single-player doubles) - auto-roll scheduled.`);
            return;
        }
    } else {
        // Not doubles - turn ends, advance to next player
        console.log(`[takeTurn] ${player.name} did not roll doubles (${die1}+${die2}=${die1+die2}). Turn ends. Calling nextTurn().`);
        
        debugLog('NO_DOUBLES_TURN_END', `${player.name} did not roll doubles - advancing to next player`, {
            turnId,
            playerName: player.name,
            dice: `${die1}+${die2}=${die1+die2}`,
            action: 'advancing_turn'
        });
        
        // Update game frame and sync before advancing turn
    console.log(`[takeTurn] Calling updateGameFrame for ${player.name}.`);
    await updateGameFrame();
    
    // Sync state to Firebase if in multiplayer mode
    if (isMultiplayerGame) {
        await syncGameStateToFirebase();
    }
    
        // Mark as completed and reset dice roll flag
        takeTurnCompleted = true;
        if (typeof window !== 'undefined') { window.takeTurnCompleted = true; }
        clearTimeout(takeTurnTimeout);
        isDiceRollInProgress = false;
        turnInProgress = false; // Reset turn in progress flag
        
        debugLog('TURN_END', `takeTurn completed - calling nextTurn`, {
            turnId,
            reason: 'no_doubles_advance_turn'
        });
        
        // Advance to next player
        nextTurn();
        return; // Important: Exit here to prevent further execution
    }
    
    // This code is no longer reachable - all paths above now return
    console.error(`[takeTurn] CRITICAL: Reached unreachable code! This should never happen.`);
}

// Emergency function to reset stuck dice roll state
function resetDiceRollState() {
    console.log(`[resetDiceRollState] Before reset: isDiceRollInProgress = ${isDiceRollInProgress}`);
    isDiceRollInProgress = false;
    console.log(`[resetDiceRollState] After reset: isDiceRollInProgress = ${isDiceRollInProgress}`);
    console.log('[resetDiceRollState] Dice should now be clickable again.');
}

// Make function available globally for emergency use
window.resetDiceRollState = resetDiceRollState;

// Debug functions for property development (available in console)
window.debugPropertyDevelopment = function(playerName = null) {
    const targetPlayer = playerName ? 
        players.find(p => p.name.toLowerCase() === playerName.toLowerCase()) : 
        players[currentPlayerIndex];
        
    if (!targetPlayer) {
        console.log('âŒ Player not found');
        return;
    }
    
    console.log(`ðŸ” Development debug for ${targetPlayer.name}:`);
    
    // Check all properties owned by this player
    Object.entries(propertyState).forEach(([square, state]) => {
        if (state.owner === targetPlayer.name) {
            const canDevelop = canDevelopProperty(targetPlayer, square);
            const propertyInfo = getPropertyInfo(square);
            const devInfo = getDevelopmentCost(square);
            const canAfford = devInfo && targetPlayer.money >= devInfo.cost;
            
            console.log(`  ${square} (${propertyInfo?.group}): ${canDevelop ? 'âœ… Can develop' : 'âŒ Cannot develop'}`);
            if (canDevelop && devInfo) {
                console.log(`    Development: ${devInfo.type} for Â£${devInfo.cost} (${canAfford ? 'Can afford' : 'Cannot afford'})`);
            }
        }
    });
    
    // Show group completion status
    console.log(`\nðŸ  Group ownership for ${targetPlayer.name}:`);
    Object.entries(propertyGroups).forEach(([groupName, groupInfo]) => {
        const groupOwnership = checkDetailedGroupOwnership(targetPlayer, groupName);
        if (groupOwnership.ownedCount > 0) {
            console.log(`  ${groupName}: ${groupOwnership.ownedCount}/${groupOwnership.totalCount} ${groupOwnership.ownsFullGroup ? 'âœ… COMPLETE' : 'âŒ Incomplete'}`);
            if (!groupOwnership.ownsFullGroup && groupOwnership.missingProperties.length > 0) {
                console.log(`    Missing: ${groupOwnership.missingProperties.join(', ')}`);
            }
        }
    });
};

window.forceRefreshDevelopment = function() {
    console.log('ðŸ”„ Force refreshing development UI...');
    
    // Force update info panel
    updateInfoPanel();
    
    // Check current player's development opportunities
    const currentPlayer = players[currentPlayerIndex];
    if (currentPlayer && isMultiplayerGame) {
        const localPlayerName = window.localPlayerName || document.getElementById('player1-name')?.value?.trim();
        if (localPlayerName && currentPlayer.name.toLowerCase() === localPlayerName.toLowerCase()) {
            // Check if current square can be developed
            if (canDevelopProperty(currentPlayer, currentPlayer.currentSquare)) {
                console.log(`ðŸ—ï¸ Current square ${currentPlayer.currentSquare} can be developed!`);
            }
            
            // List all developable properties
            const developableProperties = [];
            Object.entries(propertyState).forEach(([square, state]) => {
                if (state.owner === currentPlayer.name && canDevelopProperty(currentPlayer, square)) {
                    developableProperties.push(square);
                }
            });
            
            if (developableProperties.length > 0) {
                console.log(`ðŸ—ï¸ Developable properties: ${developableProperties.join(', ')}`);
            } else {
                console.log('âŒ No developable properties found');
            }
        }
    }
};

// Emergency function to check and fix dice clickability
function checkDiceClickability() {
    const diceSection = document.getElementById('dice-section');
    if (diceSection) {
        console.log('ðŸŽ² Dice section found:');
        console.log('  - Classes:', Array.from(diceSection.classList));
        console.log('  - Pointer events:', diceSection.style.pointerEvents);
        console.log('  - Parent element:', diceSection.parentElement?.id || 'unknown');
        console.log('  - isDiceRollInProgress:', isDiceRollInProgress);
        console.log('  - isDiceClickHandlerRunning:', isDiceClickHandlerRunning);
        
        if (diceSection.style.pointerEvents === 'none' && !isDiceRollInProgress && !isDiceClickHandlerRunning) {
            console.log('ðŸ”§ Fixing dice pointer events - setting to auto');
            diceSection.style.pointerEvents = 'auto';
        }
        
        return {
            found: true,
            classes: Array.from(diceSection.classList),
            pointerEvents: diceSection.style.pointerEvents,
            parent: diceSection.parentElement?.id,
            rollInProgress: isDiceRollInProgress,
            handlerRunning: isDiceClickHandlerRunning
        };
    } else {
        console.log('âŒ Dice section not found');
        return { found: false };
    }
}

// Make function available globally for debugging
window.checkDiceClickability = checkDiceClickability;

// Emergency dice fix function - available globally
window.emergencyDiceFix = function() {
    console.log('ðŸš¨ EMERGENCY DICE FIX - Running...');
    
    try {
        // Reset all blocking flags
        isDiceRollInProgress = false;
        isDiceClickHandlerRunning = false;
        isPlayerMoving = false;
        if (typeof isRecordingEyes !== 'undefined') isRecordingEyes = false;
        
        // Reset dice click protection counters
        diceClickCount = 0;
        turnInProgress = false;
        lastDiceClickTime = 0;
        
        console.log('âœ… All blocking flags reset');
        
        // Fix dice element
        const diceSection = document.getElementById('dice-section');
        if (diceSection) {
            diceSection.style.pointerEvents = 'auto';
            removeAllDicePulseClasses(diceSection);
            const currentPlayer = players[currentPlayerIndex];
            const playerPulseClass = getPlayerDicePulseClassByPlayer(currentPlayer);
            diceSection.classList.add(playerPulseClass);
            console.log(`âœ… Dice element fixed with player color: ${playerPulseClass}`);
        }
        
        // Call enableDiceSection
        if (typeof enableDiceSection === 'function') {
            enableDiceSection();
            console.log('âœ… enableDiceSection called');
        }
        
        console.log('ðŸŽ‰ Emergency dice fix completed!');
        return true;
        
    } catch (error) {
        console.error('âŒ Emergency dice fix failed:', error);
        return false;
    }
};

// Auto-recovery mechanism for stuck dice (runs every 30 seconds)
let diceAutoRecoveryInterval;
function startDiceAutoRecovery() {
    if (diceAutoRecoveryInterval) clearInterval(diceAutoRecoveryInterval);
    
    diceAutoRecoveryInterval = setInterval(() => {
        // Only check if we're not in an active turn
        if (!isDiceRollInProgress && !isDiceClickHandlerRunning && !isPlayerMoving) {
            const diceSection = document.getElementById('dice-section');
            
            // Check if dice should be clickable but isn't
            if (diceSection && diceSection.style.pointerEvents === 'none') {
                // Check if it's a human player's turn and not in a property decision
                const currentPlayer = players && players[currentPlayerIndex];
                const hasPropertyDecision = document.querySelector('.purchase-button, .decline-button, .develop-button');
                
                if (currentPlayer && !currentPlayer.isAI && !hasPropertyDecision && !isAITurn) {
                    console.log('ðŸ”§ Auto-recovery: Dice should be clickable but isn\'t - fixing...');
                    diceSection.style.pointerEvents = 'auto';
                    
                    // Check if dice doesn't have any player color pulse
                    const hasPlayerColorPulse = ['dice-pulse-player-red', 'dice-pulse-player-blue', 'dice-pulse-player-green', 'dice-pulse-player-yellow', 'dice-pulse-player-purple'].some(cls => diceSection.classList.contains(cls));
                    
                    if (!hasPlayerColorPulse) {
                        removeAllDicePulseClasses(diceSection);
                        const currentPlayer = players[currentPlayerIndex];
                        const playerPulseClass = getPlayerDicePulseClassByPlayer(currentPlayer);
                        diceSection.classList.add(playerPulseClass);
                        console.log(`ðŸ”§ Auto-recovery: Applied player color pulse: ${playerPulseClass}`);
                    }
                    
                    // Additional check: if player is on unowned property but no buttons are showing
                    const propertyInfo = getPropertyInfo(currentPlayer.currentSquare);
                    if (propertyInfo && !propertyInfo.state.owner && !propertyInfo.special) {
                        // Only trigger on the active player's browser: require name match with local player
                        const localName = (window.localPlayerName || document.getElementById('player1-name')?.value || '').toLowerCase();
                        if (currentPlayer.name && currentPlayer.name.toLowerCase() === localName) {
                            console.log('ðŸ”§ Auto-recovery: Player on unowned property but no buttons - forcing property decision (active local player)...');
                            updateInfoPanel(null, null, propertyInfo);
                        } else {
                            console.log('ðŸ”§ Auto-recovery: Skipped forcing property decision on non-local player context');
                        }
                    }
                }
            }
        }
    }, 30000); // Check every 30 seconds
}

// Start auto-recovery when the game loads
if (typeof window !== 'undefined') {
    window.addEventListener('load', startDiceAutoRecovery);
    // Also start it now if already loaded
    if (document.readyState === 'complete') {
        startDiceAutoRecovery();
    }
}

// Unified dice click handler function
async function handleDiceClick(source = 'main') {
    const clickId = Math.random().toString(36).substr(2, 9);
    const currentTime = Date.now();

    // Ignore synthetic/duplicate mouse clicks immediately following a touch event (tablet double-fire)
    if ((source === 'minimized-click' || source === 'individual-die-click' || source === 'main') && currentTime < suppressNextMouseClickUntil) {
        console.log(`ðŸš« Dice click ignored - duplicate post-touch within ${DUPLICATE_CLICK_WINDOW_MS}ms (source: ${source}) [ID: ${clickId}]`);
        return false;
    }
    console.log(`ðŸŽ² DICE CLICKED (${source}) [ID: ${clickId}] - Starting validation...`);
    
    // ENHANCED PROTECTION: Check multiple conditions to prevent rapid clicking exploits
    
    // 1. Check if another dice click handler is already running or dice roll is in progress
    if (isDiceClickHandlerRunning || isDiceRollInProgress) {
        console.log(`ðŸš« Dice click ignored - handler already running (handlerRunning: ${isDiceClickHandlerRunning}, rollInProgress: ${isDiceRollInProgress}) (source: ${source}) [ID: ${clickId}]`);
        return false; // Return false to indicate click was ignored
    }
    
    // 2. Check cooldown period to prevent rapid clicking
    if (currentTime - lastDiceClickTime < DICE_CLICK_COOLDOWN) {
        const remainingCooldown = DICE_CLICK_COOLDOWN - (currentTime - lastDiceClickTime);
        console.log(`ðŸš« Dice click ignored - cooldown active (${remainingCooldown}ms remaining) (source: ${source}) [ID: ${clickId}]`);
        showAdvisory(`Please wait ${Math.ceil(remainingCooldown / 1000)} second(s) before rolling again`, 'warning');
        return false;
    }
    
    // 3. Check if turn is already in progress (additional protection)
    if (turnInProgress && !lastRollWasDoubles) {
        console.log(`ðŸš« Dice click ignored - turn already in progress and no doubles (source: ${source}) [ID: ${clickId}]`);
        
        // Safety mechanism: Reset turnInProgress if it's been stuck for too long
        const currentTime = Date.now();
        if (!window.lastTurnStartTime || (currentTime - window.lastTurnStartTime) > 10000) {
            console.log(`ðŸ”„ Resetting stuck turnInProgress flag after 10 seconds [ID: ${clickId}]`);
            turnInProgress = false;
            window.lastTurnStartTime = null;
            // Also reset other turn-related flags
            isDiceRollInProgress = false;
            isDiceClickHandlerRunning = false;
            takeTurnCompleted = false;
            // Try the dice click again
            return handleDiceClick(source, clickId + '_retry');
        }
        
        showAdvisory('Turn already in progress', 'warning');
        return false;
    }
    
    // 4. Check dice click count per turn (prevent multiple rolls unless doubles)
    if (diceClickCount >= MAX_DICE_CLICKS_PER_TURN && !lastRollWasDoubles) {
        console.log(`ðŸš« Dice click ignored - maximum clicks per turn reached (${diceClickCount}/${MAX_DICE_CLICKS_PER_TURN}) (source: ${source}) [ID: ${clickId}]`);
        showAdvisory('You have already rolled this turn', 'warning');
        return false;
    }
    
    // 5. Reset dice click count if this is a doubles roll (allows continued rolling)
    if (lastRollWasDoubles) {
        diceClickCount = 0;
        console.log(`ðŸŽ² Doubles detected - resetting dice click count for continued rolling (source: ${source}) [ID: ${clickId}]`);
    }
    
    // Mark that this handler is now running and update tracking
    isDiceClickHandlerRunning = true;
    turnInProgress = true;
    window.lastTurnStartTime = currentTime;
    lastDiceClickTime = currentTime;
    diceClickCount++;
    console.log(`ðŸ”’ Dice click handler started by ${source} [ID: ${clickId}] - Click count: ${diceClickCount}`);
    
    // Validate players array and currentPlayerIndex first
    if (!Array.isArray(players) || players.length === 0) {
        console.error(`Dice click handler (${source}) [ID: ${clickId}] - players array is invalid:`, players);
        showAdvisory('Game error: No players found. Please restart the game.', 'error');
        isDiceClickHandlerRunning = false;
        console.log(`ðŸ”“ Dice click handler stopped by ${source} [ID: ${clickId}] - validation failed`);
        return false;
    }
    
    if (currentPlayerIndex < 0 || currentPlayerIndex >= players.length) {
        console.error(`Dice click handler (${source}) - currentPlayerIndex out of bounds:`, currentPlayerIndex, 'Players count:', players.length);
        currentPlayerIndex = 0; // Reset to first player as fallback
    }
    
    const activePlayer = players[currentPlayerIndex];
    if (!activePlayer) {
        console.error(`Dice click handler (${source}) [ID: ${clickId}] - current player is undefined at index:`, currentPlayerIndex);
        showAdvisory('Game error: Current player is undefined. Please restart the game.', 'error');
        isDiceClickHandlerRunning = false;
        console.log(`ðŸ”“ Dice click handler stopped by ${source} [ID: ${clickId}] - player validation failed`);
        return false;
    }
    
    console.log(`Dice click handler (${source}) - Current state:`, {
        isAITurn,
        isRecordingEyes,
        currentPlayerIndex,
        currentPlayer: activePlayer.name
    });

    // Prevent clicking if recording eyes
    if (isRecordingEyes) {
        console.log(`Cannot roll - recording eyes (source: ${source}) [ID: ${clickId}]`, { isRecordingEyes });
        isDiceClickHandlerRunning = false;
        console.log(`ðŸ”“ Dice click handler stopped by ${source} [ID: ${clickId}] - recording eyes`);
        return false;
    }
    
    // In multiplayer, check if it's the current player's turn
    if (isMultiplayerGame) {
        let playerName = document.getElementById('player1-name').value.trim();
        
        // If player name is empty, try to get it from the stored local player name
        if (!playerName && window.localPlayerName) {
            playerName = window.localPlayerName;
        }
        
        // Check if this browser belongs to the current player by comparing names (case-insensitive)
        const isMyTurn = activePlayer && activePlayer.name.toLowerCase() === playerName.toLowerCase();
        
        if (!isMyTurn) {
            console.log(`Cannot roll - not your turn in multiplayer (source: ${source}) [ID: ${clickId}]`, { 
                currentPlayer: activePlayer.name, 
                yourName: playerName,
                currentPlayerIndex: currentPlayerIndex,
                isMyTurn: isMyTurn
            });
            
            // Show clearer turn information
            const turnMessage = activePlayer ? 
                `Waiting for ${activePlayer.name}'s turn (You are ${playerName})` : 
                'Waiting for another player\'s turn';
            showAdvisory(turnMessage, 'info');
            isDiceClickHandlerRunning = false;
            console.log(`ðŸ”“ Dice click handler stopped by ${source} [ID: ${clickId}] - not your turn`);
            return false;
        }
    }
    
    // Prevent clicking if it's AI's turn (only for AI vs Human games)
    if (!isMultiplayerGame && isAITurn) {
        console.log(`Cannot roll - AI turn (source: ${source}) [ID: ${clickId}]`, { isAITurn });
        isDiceClickHandlerRunning = false;
        console.log(`ðŸ”“ Dice click handler stopped by ${source} [ID: ${clickId}] - AI turn`);
        return false;
    }

    console.log(`âœ… DICE CLICK VALIDATED (${source}) [ID: ${clickId}] - Proceeding with roll...`);
    
    // Get dice section for pointer events and visual feedback
    const diceSection = document.getElementById('dice-section');
    if (diceSection) {
        diceSection.style.pointerEvents = 'none';
        // Add visual feedback that dice are processing
        diceSection.classList.add('dice-processing');
        diceSection.style.opacity = '0.6';
        console.log(`ðŸ”’ Dice section disabled with visual feedback (source: ${source}) [ID: ${clickId}]`);
    }
    
    // Now set the dice roll flag to prevent takeTurn() conflicts
    isDiceRollInProgress = true;
    console.log(`ðŸ”’ Dice roll flag set by ${source} [ID: ${clickId}] - ready to call takeTurn()`);
    
    // Add safety timeout to prevent permanent stuck state
    const diceRollTimeout = setTimeout(() => {
        if (isDiceRollInProgress || isDiceClickHandlerRunning) {
            console.warn(`ðŸš¨ Dice timeout - forcing reset (source: ${source}) [ID: ${clickId}]`);
            isDiceRollInProgress = false;
            isDiceClickHandlerRunning = false;
            if (diceSection) {
                diceSection.style.pointerEvents = 'auto';
            }
        }
    }, 30000); // 30 second timeout
    
    try {
        // Check if player is on an unpurchased property or can develop a property they own
        const playerOnTurn = players[currentPlayerIndex];
        const propertyInfo = getPropertyInfo(playerOnTurn.currentSquare);
        
        // Check if property is unowned AND not already declined by this player (manually or auto-declined)
        const isUnownedProperty = propertyInfo && !propertyInfo.state.owner;
        const hasAlreadyDeclined = (propertyInfo && propertyInfo.state.declined && propertyInfo.state.declinedBy === playerOnTurn.name) ||
                                  (playerDeclinedProperties.has(playerOnTurn.name) && 
                                   (playerDeclinedProperties.get(playerOnTurn.name).has(propertyInfo?.square) ||
                                    playerDeclinedProperties.get(playerOnTurn.name).has(`auto_${propertyInfo?.square}`)));
        const hasUnpurchasedProperty = isUnownedProperty && !hasAlreadyDeclined && !playerOnTurn.isAI;
        
        const canDevelop = propertyInfo && propertyInfo.state.owner === playerOnTurn.name && !playerOnTurn.isAI && canDevelopProperty(playerOnTurn, propertyInfo.square);
        const hasDevelopmentOption = canDevelop && getDevelopmentCost(propertyInfo.square) && playerOnTurn.money >= getDevelopmentCost(propertyInfo.square).cost;
        
        console.log(`Dice click check (${source}) [ID: ${clickId}]:`, {
            currentPlayer: playerOnTurn.name,
            currentSquare: playerOnTurn.currentSquare,
            propertyInfo: propertyInfo ? propertyInfo.square : null,
            isUnownedProperty,
            hasAlreadyDeclined,
            hasUnpurchasedProperty,
            hasDevelopmentOption,
            isAITurn
        });

        // Extra guard: never treat as unpurchased if state shows an owner (defensive)
        if (hasUnpurchasedProperty && (!propertyInfo.state.owner)) {
            console.log(`âŒ Player clicked dice with unpurchased property - BLOCKING dice roll until purchase decision made (source: ${source})`);
            showAdvisory(`Please make a purchase decision for ${getPropertyDisplayName(propertyInfo)} before rolling dice again`, 'info');
            
            // DO NOT mark property as declined automatically
            // DO NOT continue the turn - force explicit purchase decision
            
            // Restore dice roll flag and exit without calling takeTurn
            isDiceRollInProgress = false;
            console.log(`ðŸ”„ Restored isDiceRollInProgress state (source: ${source}) [ID: ${clickId}]`);
            // Keep dice disabled until purchase decision is made
            const diceSection = document.getElementById('dice-section');
            if (diceSection) {
                diceSection.style.pointerEvents = 'none';
                diceSection.classList.remove('dice-pulse');
                diceSection.classList.add('dice-pulse-red');
                console.log(`ðŸ”’ Dice disabled until purchase decision made (source: ${source})`);
            }
            
            // Show the property decision UI so player can make the purchase decision
            console.log(`ðŸ  Triggering property decision UI for unpurchased property: ${propertyInfo}`);
            const currentPlayer = players[currentPlayerIndex];
            updateInfoPanelInternal(null, null, propertyInfo);
            
            // Add a fallback timer to ensure purchase decision can be made
            setTimeout(() => {
                // Check if purchase decision still pending after 2 seconds
                const stillNeedsPurchaseDecision = !propertyInfo.state.owner && 
                    currentPlayer.currentSquare === propertyInfo.square &&
                    currentPlayerIndex === players.findIndex(p => p.name === currentPlayer.name);
                
                // Also check if player just landed on property (not sitting there)
                const playerJustLanded = currentPlayer.isMoving || 
                    (currentPlayer.movementTimestamp && Date.now() - currentPlayer.movementTimestamp < 10000);
                
                if (stillNeedsPurchaseDecision && playerJustLanded) {
                    console.log(`âš ï¸ Purchase decision still pending after 2s - adding fallback UI`);
                    
                    // Add emergency purchase buttons to the main game area
                    addEmergencyPurchaseButtons(propertyInfo, currentPlayer, currentPlayerIndex);
                } else if (stillNeedsPurchaseDecision && !playerJustLanded) {
                    console.log(`ðŸš« Player has been sitting on property - not showing emergency purchase UI`);
                }
            }, 2000);
            
            return; // Exit without calling takeTurn
        }

        if (hasDevelopmentOption) {
            console.log(`ðŸŽ² Player clicked dice with development option - treating as "skip further development" (source: ${source})`);
            const cost = getDevelopmentCost(propertyInfo.square);
            showAdvisory(`Skipping further development on ${getPropertyDisplayName(propertyInfo)}. Continuing turn...`, 'info');
            
            // Clear development buttons and continue turn
            updateInfoPanel();
            
            // Restore dice roll flag and continue with turn
            isDiceRollInProgress = false;
            console.log(`ðŸ”„ Restored isDiceRollInProgress state (source: ${source}) [ID: ${clickId}]`);
            
            // Continue with the turn since player chose to skip development
            console.log(`ðŸŽ² Player chose to skip development, continuing turn...`);
        }

                clearAutoRollTimer(); // Clear any existing timer
        
        // Temporarily allow takeTurn to run by clearing the flag
        const wasInProgress = isDiceRollInProgress;
        isDiceRollInProgress = false;
        console.log(`ðŸ”„ Temporarily cleared isDiceRollInProgress to allow takeTurn() (source: ${source}) [ID: ${clickId}]`);
        
        try {
            if (isInitialRoll && !isMultiplayerGame) {
                // Handle initial roll to determine first player (only for AI games)
                const message = await determineFirstPlayer();
                showAdvisory(message, 'turn');
                isInitialRoll = false; // Set to false after initial roll
                updateDicePulsing(); // Update dice visual state
                if (isAITurn) {
                    // If AI goes first, start their turn
                    setTimeout(async () => {
                        await handleAITurn();
                    }, 1500);
                }
            } else {
                // Handle regular turn (or multiplayer first turn)
                if (isInitialRoll && isMultiplayerGame) {
                    // For multiplayer, skip initial roll determination
                    isInitialRoll = false;
                    updateDicePulsing();
                }
                await takeTurn();
            }
        } finally {
            // Restore the flag state
            isDiceRollInProgress = wasInProgress;
            console.log(`ðŸ”„ Restored isDiceRollInProgress state (source: ${source}) [ID: ${clickId}]`);
        }
        
    } catch (error) {
        console.error(`ðŸš¨ Error in dice roll handler (${source}) [ID: ${clickId}]:`, error);
        showAdvisory('Error during dice roll. Please try again.', 'error');
    } finally {
        // Always clear the safety timeout and reset both flags
        if (typeof diceRollTimeout !== 'undefined') {
            clearTimeout(diceRollTimeout);
        }
        isDiceRollInProgress = false;
        isDiceClickHandlerRunning = false;
        // Reset turn in progress flag if turn didn't complete properly
        if (!takeTurnCompleted) {
            turnInProgress = false;
            console.log(`ðŸ”„ Reset turnInProgress flag due to incomplete turn [ID: ${clickId}]`);
        }
        if (diceSection) {
            diceSection.style.pointerEvents = 'auto';
            // Restore visual state
            diceSection.classList.remove('dice-processing');
            diceSection.style.opacity = '';
            console.log(`ðŸ”“ Dice section restored with visual feedback (source: ${source}) [ID: ${clickId}]`);
        }
        console.log(`ðŸ”“ All dice flags reset - completed (source: ${source}) [ID: ${clickId}]`);
    }
    
    return true; // Return true to indicate click was processed
}

// Function to ensure info panel is visible and properly positioned
function ensureInfoPanelVisible() {
    const infoPanel = document.getElementById('info-panel');
    if (!infoPanel) return;

    // Only show info panel if game is initialized and intro screen is hidden
    const introScreen = document.getElementById('intro-screen');
    if (!isGameInitialized || (introScreen && introScreen.style.display !== 'none')) {
        infoPanel.style.display = 'none';
        return;
    }

    // Force display block and high z-index
    if (infoPanel.style.display === 'none' || !infoPanel.style.display) {
        console.log('Info panel was hidden, making it visible');
        infoPanel.style.display = 'block';
    }
    
    // Ensure z-index is high enough
    if (!infoPanel.style.zIndex || parseInt(infoPanel.style.zIndex) < 1001) {
        infoPanel.style.zIndex = '1001';
    }

    // Check if panel is off-screen and reset position if needed
    const rect = infoPanel.getBoundingClientRect();
    if (rect.right < 0 || rect.bottom < 0 || rect.left > window.innerWidth || rect.top > window.innerHeight) {
        console.log('Info panel was off-screen, resetting position');
        infoPanel.style.top = '20px';
        infoPanel.style.right = '260px';
        infoPanel.style.left = '';
    }
}

// Start periodic check to ensure info panel stays visible during gameplay
function startInfoPanelVisibilityCheck() {
    setInterval(ensureInfoPanelVisible, 1000); // Check every second
}

// Only start visibility check when game is initialized
function initializeInfoPanelChecks() {
    startInfoPanelVisibilityCheck();
    window.addEventListener('resize', ensureInfoPanelVisible);
}

// Store the current property info to preserve development buttons
let currentPropertyInfo = null;

// Update info panel function
function updateInfoPanel(die1 = null, die2 = null, propertyInfo = null) {
    // Clear any pending timeout
    if (updateInfoPanelTimeout) {
        clearTimeout(updateInfoPanelTimeout);
    }
    
    // If propertyInfo is provided, store it for future reference
    if (propertyInfo !== null) {
        currentPropertyInfo = propertyInfo;
    }
    
    // If no propertyInfo provided but we have development buttons visible, preserve them
    if (propertyInfo === null && hasDevelopmentButtonsVisible() && currentPropertyInfo) {
        console.log('ðŸ—ï¸ Preserving development buttons - using stored propertyInfo');
        propertyInfo = currentPropertyInfo;
    }
    
    // Debounce the update to prevent excessive calls
    updateInfoPanelTimeout = setTimeout(() => {
        updateInfoPanelInternal(die1, die2, propertyInfo);
        
        // Update the bottom player display whenever the info panel is updated
        if (typeof updateBottomPlayerDisplay === 'function') {
            updateBottomPlayerDisplay();
        }
    }, 50); // 50ms debounce
}

// Function to update the info panel title with current player's color
function updateInfoPanelTitle() {
    const headerSpan = document.querySelector('#info-panel-header span');
    if (!headerSpan) {
        console.warn('Info panel header span not found');
        return;
    }
    
    // Get current player
    const currentPlayer = players[currentPlayerIndex];
    if (!currentPlayer) {
        headerSpan.textContent = 'Player Info';
        return;
    }
    
    // In multiplayer, show the local player's color, not the current turn player
    let displayPlayer = currentPlayer;
    if (isMultiplayerGame) {
        const localPlayerName = window.localPlayerName || document.getElementById('player1-name')?.value;
        if (localPlayerName) {
            const localPlayer = players.find(p => p.name.toLowerCase() === localPlayerName.toLowerCase());
            if (localPlayer) {
                displayPlayer = localPlayer;
            }
        }
    }
    
    // Update title with player's color
    const playerColorName = displayPlayer.colorName || 'Player';
    headerSpan.textContent = `Player ${playerColorName}`;
    
    console.log(`Updated info panel title to: Player ${playerColorName}`);
}

// Internal function that does the actual work
function updateInfoPanelInternal(die1 = null, die2 = null, propertyInfo = null) {
    ensureInfoPanelVisible(); // Make sure panel is visible
    
    // Update info panel title with current player's color
    updateInfoPanelTitle();
    
    // Define mobile device detection
    const isMobileDevice = window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    const infoPanel = document.getElementById('info-panel');
    const diceContent = document.getElementById('dice-content');
    let propertyInfoContent = document.getElementById('property-info-content');
    let playerInfoContent = document.getElementById('player-info-content');
    
    // CRITICAL FIX: Create missing elements if they don't exist
    if (!propertyInfoContent) {
        console.warn('ðŸš¨ property-info-content element not found, creating it...');
        propertyInfoContent = document.createElement('div');
        propertyInfoContent.id = 'property-info-content';
        
        // Find the info panel content to append to
        const infoPanelContent = document.getElementById('info-panel-content');
        if (infoPanelContent) {
            infoPanelContent.appendChild(propertyInfoContent);
            console.log('âœ… Created and appended property-info-content to info-panel-content');
        } else {
            // Fallback: append to body
            document.body.appendChild(propertyInfoContent);
            console.log('âš ï¸ Created property-info-content and appended to body (fallback)');
        }
    }
    
    if (!playerInfoContent) {
        console.warn('ðŸš¨ player-info-content element not found, creating it...');
        playerInfoContent = document.createElement('div');
        playerInfoContent.id = 'player-info-content';
        
        // Find the info panel content to append to
        const infoPanelContent = document.getElementById('info-panel-content');
        if (infoPanelContent) {
            infoPanelContent.appendChild(playerInfoContent);
            console.log('âœ… Created and appended player-info-content to info-panel-content');
        } else {
            // Fallback: append to body
            document.body.appendChild(playerInfoContent);
            console.log('âš ï¸ Created player-info-content and appended to body (fallback)');
        }
    }
    
    // Check if panel is minimized and handle property decision mode
    const isMinimized = infoPanel && infoPanel.classList.contains('minimized');

    if (!propertyInfoContent || !playerInfoContent) {
        console.error('Required info panel elements not found even after creation attempt:', {
            propertyInfoContent: !!propertyInfoContent,
            playerInfoContent: !!playerInfoContent
        });
        return;
    }

    // Get current game state safely
    if (!Array.isArray(players) || players.length === 0 || !players[currentPlayerIndex]) {
        console.warn('[updateInfoPanel] Current player not available', {
            playersLength: Array.isArray(players) ? players.length : 'n/a',
            currentPlayerIndex
        });
        return;
    }

    const currentPlayer = players[currentPlayerIndex];
    
    // If no property info provided, get it from current player's square
    if (!propertyInfo) {
        propertyInfo = getPropertyInfo(currentPlayer.currentSquare);
    }
    
    // Update property info section if there's property info
    if (propertyInfo) {
        const state = propertyInfo.state;
        console.log(`[updateInfoPanelInternal] ðŸž PROPERTY CHECK for ${propertyInfo.square}: Owner is ${state?.owner}`);
        const owner = players.find(p => p.name.toLowerCase() === (state.owner || '').toLowerCase());
        const rentInfo = calculateRent(propertyInfo);
        const canAffordProperty = currentPlayer.money >= propertyInfo.cost;
        
        // Create purchase button HTML if property is unowned and player can afford it
        let purchaseButton = '';
        let declineButton = '';
        let developButton = '';
        
        // In multiplayer mode, only show property info and action buttons to the player whose turn it is
        let shouldShowPropertyInfo = true;
        let shouldShowButtons = true;
        
        if (isMultiplayerGame) {
            const playerName = document.getElementById('player1-name').value.trim();
            const localPlayerName = window.localPlayerName;
            
            console.log('[updateInfoPanel] Multiplayer visibility check:', {
                currentPlayerName: currentPlayer.name,
                inputPlayerName: playerName,
                localPlayerName: localPlayerName,
                isHost: isHost,
                currentPlayerIsHost: currentPlayer.isHost
            });
            
            // More precise player matching for multiplayer
            const inputPlayerName = (playerName || '').toLowerCase();
            const localPlayerNameLower = (localPlayerName || '').toLowerCase();
            const currentPlayerNameLower = currentPlayer.name.toLowerCase();
            
            // Primary match: by name
            let isMyTurn = (currentPlayerNameLower === inputPlayerName) || 
                          (currentPlayerNameLower === localPlayerNameLower);
            
            // CRITICAL FIX: Also check if the local player just landed on an unowned property
            // This handles the case where a player moves and lands on a property but currentPlayerIndex hasn't advanced yet
            // BUT only if they are still moving or just finished moving (not if they've been sitting there)
            if (!isMyTurn && propertyInfo && !propertyInfo.state.owner) {
                // Find the local player in the players array
                const localPlayer = players.find(p => 
                    p.name.toLowerCase() === inputPlayerName || 
                    p.name.toLowerCase() === localPlayerNameLower
                );
                
                // Check if the local player is on the same square as the property being displayed
                // AND they are currently moving or just finished moving (indicated by isMoving flag or recent movement)
                if (localPlayer && localPlayer.currentSquare === propertyInfo.square) {
                    // Check if the player is currently moving or just moved
                    const isCurrentlyMoving = localPlayer.isMoving;
                    const recentMovement = localPlayer.movementTimestamp && 
                        (Date.now() - localPlayer.movementTimestamp) < 10000; // Within last 10 seconds
                    
                    console.log(`[updateInfoPanel] ðŸ” MULTIPLAYER DEBUG: Player ${localPlayer.name} movement check:`, {
                        isMoving: localPlayer.isMoving,
                        movementTimestamp: localPlayer.movementTimestamp,
                        timeSinceMovement: localPlayer.movementTimestamp ? Date.now() - localPlayer.movementTimestamp : 'N/A',
                        isCurrentlyMoving,
                        recentMovement,
                        willShowUI: isCurrentlyMoving || recentMovement
                    });
                    
                    // ENHANCED: If movement flags are missing but it's the current player's turn and they're on unowned property,
                    // allow purchase UI to show (this handles cases where movement flags were lost)
                    const isCurrentPlayerTurn = currentPlayerNameLower === localPlayer.name.toLowerCase();
                    
                    if (isCurrentlyMoving || recentMovement || isCurrentPlayerTurn) {
                        if (isCurrentPlayerTurn && !isCurrentlyMoving && !recentMovement) {
                            console.log(`[updateInfoPanel] ðŸ”§ MULTIPLAYER FALLBACK: It's ${localPlayer.name}'s turn and they're on unowned property ${propertyInfo.square} - showing purchase UI despite missing movement flags`);
                        } else {
                            console.log(`[updateInfoPanel] ðŸŽ¯ MULTIPLAYER FIX: Local player ${localPlayer.name} just landed on unowned property ${propertyInfo.square} - showing purchase UI`);
                        }
                        isMyTurn = true;
                    } else {
                        console.log(`[updateInfoPanel] ðŸš« MULTIPLAYER: Local player ${localPlayer.name} is on ${propertyInfo.square} but not recently moved and not their turn - not showing purchase UI`);
                    }
                }
            }
            
            // Fallback: if no name match but names exist, don't use host status
            // Host status should not be used for turn determination
            if (!isMyTurn && (!inputPlayerName || !localPlayerNameLower)) {
                console.warn(`[updateInfoPanel] Could not determine player identity - no valid player name found`);
                isMyTurn = false; // Default to false for safety
            }
            
            console.log(`[updateInfoPanel] Player identity check:`, {
                currentPlayerName: currentPlayerNameLower,
                inputPlayerName: inputPlayerName,
                localPlayerName: localPlayerNameLower,
                isMyTurn: isMyTurn,
                reason: isMyTurn ? 'name match' : 'no match'
            });
            
            // Only show property info to the player whose turn it is, OR if they own the property being viewed
            const currentLocalPlayerName = window.localPlayerName || document.getElementById('player1-name')?.value?.trim();
            const isMyProperty = propertyInfo && propertyInfo.state.owner && currentLocalPlayerName && 
                               propertyInfo.state.owner.toLowerCase() === currentLocalPlayerName.toLowerCase();
            
            shouldShowPropertyInfo = isMyTurn || isMyProperty;
            shouldShowButtons = isMyTurn;
            
            // CRITICAL FIX: Only consider purchase UI for truly unowned properties
            if (propertyInfo && (!propertyInfo.state.owner) && !currentPlayer.isAI && isMyTurn) {
                // Check if player has already declined this property purchase
                const hasDeclinedThisProperty = playerDeclinedProperties.has(currentPlayer.name) && 
                                               (playerDeclinedProperties.get(currentPlayer.name).has(propertyInfo.square) ||
                                                playerDeclinedProperties.get(currentPlayer.name).has(`auto_${propertyInfo.square}`));
                
                // Check if player just landed on this property (not just sitting there)
                const isCurrentlyMoving = currentPlayer.isMoving;
                const recentMovement = currentPlayer.movementTimestamp && 
                    (Date.now() - currentPlayer.movementTimestamp) < 5000; // Within last 5 seconds
                const justLanded = isCurrentlyMoving || recentMovement;
                
                console.log(`[updateInfoPanel] Property decline check for ${currentPlayer.name} on ${propertyInfo.square}:`, {
                    hasPlayerDeclines: playerDeclinedProperties.has(currentPlayer.name),
                    declinedProperties: playerDeclinedProperties.has(currentPlayer.name) ? Array.from(playerDeclinedProperties.get(currentPlayer.name)) : [],
                    hasDeclinedThisProperty: hasDeclinedThisProperty,
                    isCurrentlyMoving: isCurrentlyMoving,
                    recentMovement: recentMovement,
                    justLanded: justLanded
                });
                
                // ENHANCED: Add fallback for missing movement flags
                const shouldShowDueToTurn = isMyTurn && !hasDeclinedThisProperty && !state.owner;
                
                if (!hasDeclinedThisProperty && (justLanded || shouldShowDueToTurn) && !state.owner) {
                    if (justLanded) {
                        console.log('[updateInfoPanel] ðŸš¨ CRITICAL: Forcing property purchase UI for unowned property (player just landed)');
                    } else if (shouldShowDueToTurn) {
                        console.log('[updateInfoPanel] ðŸ”§ FALLBACK: Forcing property purchase UI for unowned property (player turn, movement flags missing)');
                    }
                    shouldShowPropertyInfo = true;
                    shouldShowButtons = true;
                } else {
                    if (hasDeclinedThisProperty) {
                        console.log('[updateInfoPanel] ðŸš« Property already declined by player - not showing purchase UI');
                    } else if (!justLanded && !shouldShowDueToTurn) {
                        console.log('[updateInfoPanel] ðŸš« Player has been sitting on property or not their turn - not showing purchase UI');
                    }
                    shouldShowPropertyInfo = false;
                    shouldShowButtons = false;
                }
            }
            
            console.log('[updateInfoPanel] shouldShowPropertyInfo:', shouldShowPropertyInfo, 'shouldShowButtons:', shouldShowButtons);
        }
        
        // Don't show buttons if current player is bankrupt
        if (currentPlayer.bankrupt) {
            shouldShowButtons = false;
        }
        
        // Hide all buttons during movement animations
        if (isPlayerMoving) {
            shouldShowButtons = false;
        }
        
        // Global pending decision fallback: if a pending decision exists for local player on this square, force UI
        try {
            const pending = (typeof window !== 'undefined') ? window.pendingPropertyDecision : null;
            const localName = (window.localPlayerName || document.getElementById('player1-name')?.value || '').toLowerCase();
            if (
                pending && propertyInfo &&
                pending.square === propertyInfo.square &&
                pending.playerName && pending.playerName.toLowerCase() === localName &&
                // Only honor pending decision if it's still the same turn
                typeof pending.turnIndex === 'number' && pending.turnIndex === currentPlayerIndex
            ) {
                console.log('[updateInfoPanel] âœ… Pending decision fallback active - forcing purchase UI for', pending);
                shouldShowPropertyInfo = true;
                shouldShowButtons = true;
            }
        } catch (e) {
            console.warn('[updateInfoPanel] Pending decision fallback check failed:', e);
        }

        // Only display property info if it should be shown to this player
        if (!shouldShowPropertyInfo) {
            console.log('ðŸš« Clearing property info panel - shouldShowPropertyInfo=false');
            propertyInfoContent.innerHTML = '';
            // Skip the rest of property info processing
        } else {
        
        // Check if player has already declined this property purchase (manually or auto-declined)
        const hasDeclinedPurchase = playerDeclinedProperties.has(currentPlayer.name) && 
                                   (playerDeclinedProperties.get(currentPlayer.name).has(propertyInfo.square) ||
                                    playerDeclinedProperties.get(currentPlayer.name).has(`auto_${propertyInfo.square}`));

        // Additional multiplayer safety check for purchase buttons
        const shouldShowPurchaseButtons = shouldShowButtons && 
            (!isMultiplayerGame || (isMultiplayerGame && shouldShowPropertyInfo));

        if (propertyInfo && !state.owner && !currentPlayer.isAI && shouldShowPurchaseButtons && !hasDeclinedPurchase) {
            console.log(`ðŸ’° Showing purchase options for ${propertyInfo.square} to ${currentPlayer.name} (canAfford: ${canAffordProperty})`);
            
            // If panel is minimized, show property decision in minimized content and temporarily restore
            if (isMinimized) {
                console.log('ðŸ“± Panel is minimized - showing property decision in special minimized mode');
                showMinimizedPropertyDecision(propertyInfo, currentPlayer, currentPlayerIndex, canAffordProperty);
                return; // Exit early to prevent normal property info display
            }
            
            if (canAffordProperty) {
                                purchaseButton = `
                <button onclick="handlePropertyPurchase('${propertyInfo.square}', ${currentPlayerIndex})" 
                        ontouchstart="this.style.transform='scale(0.95)'" 
                        ontouchend="this.style.transform='scale(1)'"
                        style="margin-top: 10px; background-color: #00008b; color: white; border: 1px solid #0066ff; padding: 2px 6px; border-radius: 4px; cursor: pointer; font-family: 'Courier New', 'Lucida Console', 'Monaco', 'Consolas', monospace; font-weight: bold; text-shadow: 0 0 4px #00ff00; box-shadow: 0 0 8px rgba(0, 102, 255, 0.5); min-height: 20px; min-width: 60px; touch-action: manipulation;">
                    Purchase Â£${propertyInfo.cost}
                </button>`;
            }
            declineButton = `
                <button onclick="handleDeclinePurchase('${propertyInfo.square}', ${currentPlayerIndex})"
                        ontouchstart="this.style.transform='scale(0.95)'" 
                        ontouchend="this.style.transform='scale(1)'"
                        style="margin-top: 10px; margin-left: 10px; background-color: #f44336; color: white; border: 1px solid #ff6666; padding: 2px 6px; border-radius: 4px; cursor: pointer; font-family: 'Courier New', 'Lucida Console', 'Monaco', 'Consolas', monospace; font-weight: bold; text-shadow: 0 0 4px #ff0000; box-shadow: 0 0 8px rgba(255, 68, 54, 0.5); min-height: 20px; min-width: 60px; touch-action: manipulation;">
                    Decline
                </button>`;
        } else if (state.owner && !currentPlayer.isAI) {
            // In multiplayer, check if this property is owned by the local player (not necessarily the current player)
            let showDevelopmentForThisPlayer = false;
            let propertyOwnerIndex = -1;
            
            if (isMultiplayerGame) {
                const localPlayerName = window.localPlayerName || document.getElementById('player1-name')?.value?.trim();
                if (localPlayerName && state.owner.toLowerCase() === localPlayerName.toLowerCase()) {
                    // This property is owned by the local player - show development options
                    showDevelopmentForThisPlayer = true;
                    // Find the owner's player index
                    propertyOwnerIndex = players.findIndex(p => p.name.toLowerCase() === localPlayerName.toLowerCase());
                    console.log(`ðŸ—ï¸ Multiplayer development check: Local player ${localPlayerName} owns ${propertyInfo.square}`);
                }
            } else {
                // Single player mode - use the current player
                if (state.owner.toLowerCase() === currentPlayer.name.toLowerCase()) {
                    showDevelopmentForThisPlayer = true;
                    propertyOwnerIndex = currentPlayerIndex;
                }
            }
            
            if (showDevelopmentForThisPlayer && propertyOwnerIndex >= 0) {
                const propertyOwner = players[propertyOwnerIndex];
                
                // Check if player has already declined development for this property
                const hasDeclinedDevelopment = playerDeclinedProperties.has(propertyOwner.name) && 
                                             playerDeclinedProperties.get(propertyOwner.name).has(`dev_${propertyInfo.square}`);
                
                // Enhanced development button logic with better debugging
                const canDevelop = canDevelopProperty(propertyOwner, propertyInfo.square);
                console.log(`ðŸ—ï¸ Development check for ${propertyInfo.square}: canDevelop=${canDevelop}, hasDeclined=${hasDeclinedDevelopment}, owner=${propertyOwner.name}`);
                
                if (canDevelop && !hasDeclinedDevelopment) {
                    const devInfo = getDevelopmentCost(propertyInfo.square);
                    const canAfford = devInfo && propertyOwner.money >= devInfo.cost;
                    
                    console.log(`ðŸ—ï¸ Development cost check: devInfo=${!!devInfo}, cost=${devInfo?.cost}, playerMoney=${propertyOwner.money}, canAfford=${canAfford}`);
                    
                    if (devInfo && canAfford) {
                        console.log(`âœ… Showing development button for ${propertyInfo.square}: Build ${devInfo.type} for Â£${devInfo.cost}`);
                        developButton = `
                            <button onclick="handlePropertyDevelopment('${propertyInfo.square}', ${propertyOwnerIndex})" 
                                    ontouchstart="this.style.transform='scale(0.95)'" 
                                    ontouchend="this.style.transform='scale(1)'"
                                    style="margin-top: 10px; background-color: #9C27B0; color: white; border: 1px solid #bb33cc; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-family: 'Courier New', 'Lucida Console', 'Monaco', 'Consolas', monospace; font-weight: bold; text-shadow: 0 0 4px #ff00ff; box-shadow: 0 0 8px rgba(156, 39, 176, 0.5); min-height: 36px; min-width: 36px; touch-action: manipulation;">
                                Build ${devInfo.type} for Â£${devInfo.cost}
                            </button>
                            <button onclick="handleDeclineDevelopment('${propertyInfo.square}', ${propertyOwnerIndex})" 
                                    ontouchstart="this.style.transform='scale(0.95)'" 
                                    ontouchend="this.style.transform='scale(1)'"
                                    style="margin-top: 10px; margin-left: 10px; background-color: #666; color: white; border: 1px solid #888; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-family: 'Courier New', 'Lucida Console', 'Monaco', 'Consolas', monospace; font-weight: bold; text-shadow: 0 0 4px #ccc; box-shadow: 0 0 8px rgba(102, 102, 102, 0.5); min-height: 36px; min-width: 36px; touch-action: manipulation;">
                                Develop Later
                            </button>`;
                    } else {
                        console.log(`âŒ Cannot show development button for ${propertyInfo.square}: devInfo=${!!devInfo}, cost=${devInfo?.cost}, canAfford=${canAfford}`);
                    }
                } else {
                    console.log(`âŒ Cannot show development button for ${propertyInfo.square}: canDevelop=${canDevelop}, hasDeclined=${hasDeclinedDevelopment}`);
                }
            }
        }

        // Enhanced property info display with rent breakdown
        let rentDisplay;
        if (state.owner && state.owner.toLowerCase() !== currentPlayer.name.toLowerCase()) {
            // Property is owned by someone else - highlight RENT!
            rentDisplay = `<span style="color: red; font-size: 18px; font-weight: bold;">RENT: Â£${rentInfo.amount}</span>`;
        } else {
            // Property is unowned or owned by current player
            rentDisplay = `Rent: Â£${rentInfo.amount}`;
        }
        
        if (rentInfo.breakdown && rentInfo.breakdown.length > 0) {
            rentDisplay += `<br><small style="color: #ccc;">${rentInfo.breakdown.join('<br>')}</small>`;
        }
        if (rentInfo.multiplier > 1) {
            rentDisplay += `<br><small style="color: #ffaa00;">Total multiplier: ${rentInfo.multiplier}x</small>`;
        }

        const autoPurchaseEnabled = (localStorage.getItem('autoPurchaseEnabled') || 'false') === 'true';
        const autoPurchaseToggle = `
            <label style="display:inline-flex; align-items:center; gap:6px; margin-top:8px; font-size:12px; color:#ddd; cursor:pointer;">
                <input type="checkbox" id="auto-purchase-toggle" ${autoPurchaseEnabled ? 'checked' : ''} style="transform: scale(1.2); cursor:pointer;" />
                Auto purchase if affordable
            </label>`;

        propertyInfoContent.innerHTML = `
            <div style="background: rgba(255, 255, 255, 0.1); padding: 10px; border-radius: 4px; margin-top: 10px; text-align: center;">
                <div style="font-weight: bold; color: ${propertyInfo.color}; font-family: 'Courier New', 'Lucida Console', 'Monaco', 'Consolas', monospace; font-size: 14px; text-shadow: 0 0 8px ${propertyInfo.color}; letter-spacing: 1px;">
                    ${getPropertyDisplayNameWithoutNumber(propertyInfo)}
                </div>
                <div style="font-size: 12px; margin-top: 8px; font-family: 'Courier New', 'Lucida Console', 'Monaco', 'Consolas', monospace; text-align: center; line-height: 1.4;">
                    Cost: Â£${propertyInfo.cost}<br>
                    ${owner ? `Owner: ${owner.name}` : 'Unowned'}<br>
                    ${rentDisplay}
                </div>
                <div style="display: flex; justify-content: center; gap: 10px; margin-top: 10px; flex-wrap: wrap;">
                    ${purchaseButton}
                    ${declineButton}
                    ${developButton}
                </div>
                <div style="margin-top:6px;">${autoPurchaseToggle}</div>
            </div>
        `;
        
        // Add mobile touch event handlers for better mobile compatibility
        setTimeout(() => {
            // Wire auto purchase toggle
            const toggle = document.getElementById('auto-purchase-toggle');
            if (toggle) {
                toggle.addEventListener('change', (e) => {
                    const enabled = e.target.checked;
                    localStorage.setItem('autoPurchaseEnabled', enabled ? 'true' : 'false');
                    console.log('âš™ï¸ Auto purchase set to', enabled);
                });

                // If enabled and purchase button exists, auto-click it to mimic blue button behavior
                try {
                    const enabledNow = toggle.checked;
                    if (enabledNow && purchaseButton) {
                        // Ensure turn validity and affordability before clicking
                        const canAffordNow = players[currentPlayerIndex]?.money >= (propertyInfo?.cost || Infinity);
                        const isMyTurnNow = !isMultiplayerGame || (players[currentPlayerIndex]?.name?.toLowerCase() === (window.localPlayerName || document.getElementById('player1-name')?.value || '').toLowerCase());
                        if (canAffordNow && isMyTurnNow) {
                            const btn = propertyInfoContent.querySelector('button[onclick^="handlePropertyPurchase("]');
                            if (btn) {
                                console.log('ðŸ›’ Auto-purchase toggle enabled: auto-clicking Purchase');
                                setTimeout(() => btn.click(), 50);
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Auto-click purchase failed:', e);
                }
            }

            const buttons = propertyInfoContent.querySelectorAll('button');
            buttons.forEach(button => {
                // Add visual feedback for touch (start)
                button.addEventListener('touchstart', function(e) {
                    this.style.transform = 'scale(0.95)';
                    this.style.opacity = '0.8';
                }, { passive: true });
                
                // Single touchend handler that handles both click triggering and visual feedback
                button.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Reset visual feedback
                    this.style.transform = 'scale(1)';
                    this.style.opacity = '1';
                    
                    // Trigger the click event after visual feedback
                    setTimeout(() => {
                        this.click();
                    }, 10);
                }, { passive: false });
            });
            
            // Start auto-action timer if buttons are present for human players
            if (buttons.length > 0 && !currentPlayer.isAI && shouldShowButtons) {
                if (developButton) {
                    startAutoActionTimer('develop');
                } else if (purchaseButton || declineButton) {
                    startAutoActionTimer('purchase');
                }
            }
        }, 50);
        } // Close the shouldShowPropertyInfo else block
    } else {
    console.log('ðŸš« Clearing property info panel - no property info to display');
    propertyInfoContent.innerHTML = '';
        }

    // Update player info section with consistent player ordering
    let playerInfoHTML = '<div style="margin-bottom: 2px;">'; // Reduced margin
    
    // Sort players for consistent display: current player first, then alphabetically by name
    const sortedPlayers = [...players].sort((a, b) => {
        // Current player always first
        const aIsCurrent = players.indexOf(a) === currentPlayerIndex;
        const bIsCurrent = players.indexOf(b) === currentPlayerIndex;
        
        if (aIsCurrent && !bIsCurrent) return -1;
        if (!aIsCurrent && bIsCurrent) return 1;
        
        // Then sort alphabetically by name
        return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
    });
    
    // Player info panels are now completely handled by bottom-player-display
    // Hide the player-info-content container since we're not using it anymore
    playerInfoContent.style.display = 'none';
    playerInfoContent.innerHTML = '';

    // Check for money changes and trigger flash animations
    checkMoneyChangesAndPulse();

    // Update dice section if dice values are provided
    if (die1 !== null && die2 !== null) {
        const die1Element = document.getElementById('die1');
        const die2Element = document.getElementById('die2');
        
        if (die1Element && die2Element) {
            die1Element.textContent = die1;
            die2Element.textContent = die2;
        }
    }
}

// Function to ensure bottom player display is visible on all mobile devices
function ensureBottomPlayerVisibility(bottomPlayerDisplay) {
    if (!bottomPlayerDisplay) return;
    
    // Enhanced mobile device detection
    const isMobileDevice = window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const isTabletDevice = (window.innerWidth > 768 && window.innerWidth <= 1024) || 
                          /(tablet|ipad|playbook|silk)|(android(?!.*mobi))/i.test(navigator.userAgent);
    const isLandscape = window.innerWidth > window.innerHeight;
    
    if (isMobileDevice || isTabletDevice) {
        // Calculate dynamic viewport height to account for browser UI
        const viewportHeight = window.visualViewport ? window.visualViewport.height : window.innerHeight;
        const screenHeight = window.screen.height;
        const browserUIHeight = Math.max(0, screenHeight - viewportHeight);
        
        // Apply mobile-specific styling
        bottomPlayerDisplay.style.position = 'fixed';
        bottomPlayerDisplay.style.bottom = '0';
        bottomPlayerDisplay.style.left = '0';
        bottomPlayerDisplay.style.right = '0';
        bottomPlayerDisplay.style.zIndex = '1000';
        
        // Dynamic height calculation based on device and orientation
        let maxHeight, minHeight;
        if (isLandscape && window.innerHeight <= 500) {
            // Landscape mobile - more compact
            maxHeight = '45vh';
            minHeight = '50px';
        } else if (isMobileDevice) {
            // Portrait mobile
            maxHeight = window.innerWidth <= 480 ? '40vh' : '35vh';
            minHeight = window.innerWidth <= 480 ? '90px' : '80px';
        } else {
            // Tablet
            maxHeight = '25vh';
            minHeight = '70px';
        }
        
        bottomPlayerDisplay.style.maxHeight = maxHeight;
        bottomPlayerDisplay.style.minHeight = minHeight;
        
        // Ensure it's above any browser UI
        bottomPlayerDisplay.style.transform = 'translateZ(0)';
        bottomPlayerDisplay.style.willChange = 'transform';
        
        // Add safe area padding if supported
        if (CSS.supports('padding-bottom', 'env(safe-area-inset-bottom)')) {
            const basePadding = isMobileDevice ? '4px' : '6px';
            bottomPlayerDisplay.style.paddingBottom = `calc(${basePadding} + env(safe-area-inset-bottom, 0px))`;
        }
        
        console.log(`ðŸ“± Enhanced mobile visibility applied - Device: ${isMobileDevice ? 'Mobile' : 'Tablet'}, Landscape: ${isLandscape}, Height: ${minHeight}-${maxHeight}`);
    }
}

// Function to ensure bottom display is visible for all game modes (multiplayer, mobile, standard)
function ensureBottomPlayerDisplayVisible() {
    const bottomPlayerDisplay = document.getElementById('bottom-player-display');
    
    if (bottomPlayerDisplay) {
        // Force display to be visible for all game modes
        bottomPlayerDisplay.style.display = 'block';
        
        const gameType = isMultiplayerGame ? 'multiplayer' : 'single-player';
        console.log(`âœ… Bottom player display ensured visible for ${gameType} mode`);
        
        // Also update the content to make sure it shows current state
        setTimeout(() => {
            if (typeof updateBottomPlayerDisplay === 'function') {
                updateBottomPlayerDisplay();
            }
        }, 100);
    } else {
        console.warn('âš ï¸ Bottom player display element not found');
    }
}

// Function to update the bottom player display
function updateBottomPlayerDisplay() {
    const bottomPlayerDisplay = document.getElementById('bottom-player-display');
    const bottomPlayerContent = document.getElementById('bottom-player-content');
    
    if (!bottomPlayerDisplay || !bottomPlayerContent) {
        console.log('Bottom player display elements not found');
        return;
    }
    
    // Enhanced mobile visibility handling
    ensureBottomPlayerVisibility(bottomPlayerDisplay);
    
    // Show the bottom player display if it's hidden
    if (bottomPlayerDisplay.style.display === 'none') {
        bottomPlayerDisplay.style.display = 'block';
    }
    
    // Clear existing content
    bottomPlayerContent.innerHTML = '';
    
    // Check if we have players
    if (!players || players.length === 0) {
        bottomPlayerDisplay.style.display = 'none';
        return;
    }
    
    // Detect mobile device for responsive styling
    const isMobileDevice = window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    // Create player items for the bottom display
    players.forEach((player, index) => {
        const isCurrentPlayer = index === currentPlayerIndex;
        
        // Create player item container - single line layout
        const playerItem = document.createElement('div');
        playerItem.className = `bottom-player-item ${isCurrentPlayer ? 'current-player' : ''}`;
        playerItem.style.cssText = `
            width: 100%;
            display: flex; 
            align-items: center; 
            gap: ${isMobileDevice ? '6px' : '10px'}; 
            padding: ${isMobileDevice ? '4px 6px' : '6px 10px'}; 
            margin-bottom: ${isMobileDevice ? '2px' : '3px'};
            background: ${isCurrentPlayer ? 'rgba(255, 255, 255, 0.25)' : 'rgba(255, 255, 255, 0.12)'};
            border: ${isCurrentPlayer ? '2px solid rgba(255, 255, 255, 0.4)' : '1px solid rgba(255, 255, 255, 0.2)'};
            border-radius: 4px;
            font-size: ${isMobileDevice ? '11px' : '12px'};
            line-height: 1.2;
            overflow: hidden;
            flex-wrap: wrap;
        `;
        
        // Create star indicator and token
        const tokenSection = document.createElement('span');
        tokenSection.style.cssText = `display: flex; align-items: center; gap: 4px; flex-shrink: 0;`;
        
        // Star indicator
        const starSpan = document.createElement('span');
        starSpan.className = 'bottom-player-star';
        starSpan.textContent = 'â˜…';
        starSpan.style.cssText = `color: ${player.color || '#ffd700'}; font-size: ${isMobileDevice ? '12px' : '14px'}; text-shadow: 0 0 4px ${player.color || '#ffd700'};`;
        tokenSection.appendChild(starSpan);
        
        // Token image if available
        if (player.image && player.image.src) {
            const tokenImg = document.createElement('img');
            tokenImg.src = player.image.src;
            tokenImg.alt = `${player.name} token`;
            tokenImg.style.cssText = `width: ${isMobileDevice ? '16px' : '20px'}; height: ${isMobileDevice ? '16px' : '20px'}; border-radius: 2px;`;
            tokenSection.appendChild(tokenImg);
        }
        
        // Player name
        const nameSpan = document.createElement('span');
        nameSpan.className = 'bottom-player-name';
        nameSpan.textContent = player.name || 'Unknown';
        nameSpan.style.cssText = `
            font-weight: bold; 
            color: ${player.color || '#fff'}; 
            text-shadow: 0 0 4px ${player.color || '#fff'};
            flex-shrink: 0;
            min-width: ${isMobileDevice ? '50px' : '70px'};
        `;
        
        // Money display
        const moneySpan = document.createElement('span');
        moneySpan.className = 'bottom-player-money';
        if (player.bankrupt || player.money <= 0) {
            moneySpan.textContent = 'BANKRUPT';
            moneySpan.style.cssText = 'color: #ff4444; font-weight: bold; flex-shrink: 0;';
        } else {
            moneySpan.textContent = `Â£${player.money || 0}`;
            moneySpan.style.cssText = 'color: #90EE90; font-weight: bold; flex-shrink: 0;';
        }
        
        // Properties display
        const propertiesSpan = document.createElement('span');
        propertiesSpan.className = 'bottom-player-properties';
        propertiesSpan.style.cssText = `
            flex: 1; 
            overflow: hidden; 
            text-overflow: ellipsis; 
            white-space: nowrap;
            font-size: ${isMobileDevice ? '10px' : '11px'};
            color: #ccc;
            min-width: 0;
        `;
        
        // Build properties list
        if (Array.isArray(player.properties) && player.properties.length > 0) {
            // Group properties by color/group and aggregate developments for compact display
            const ownedGroups = {};
            
            player.properties.forEach(square => {
                const propInfo = getPropertyInfo(square);
                if (!propInfo) return;
                
                const groupName = propInfo.group;
                if (!ownedGroups[groupName]) {
                    ownedGroups[groupName] = {
                        color: propInfo.color,
                        properties: [],
                        totalGraveyards: 0,
                        totalCrypts: 0
                    };
                }
                
                const state = propInfo.state || {};
                ownedGroups[groupName].properties.push({
                    graveyards: Number(state.graveyards || 0),
                    hasCrypt: !!state.hasCrypt
                });
                ownedGroups[groupName].totalGraveyards += Number(state.graveyards || 0);
                if (state.hasCrypt) ownedGroups[groupName].totalCrypts += 1;
            });
            
            // Format properties for display with aggregation
            const propertyDisplays = Object.entries(ownedGroups)
                .sort(([a], [b]) => a.localeCompare(b))
                .map(([groupName, groupData]) => {
                    const totalInGroup = (propertyGroups[groupName] && propertyGroups[groupName].positions) ? propertyGroups[groupName].positions.length : groupData.properties.length;
                    const ownedCount = groupData.properties.length;
                    const ownsSet = ownedCount === totalInGroup && totalInGroup > 0;
                    
                    // Dot sizing: enlarge single dot if set is complete
                    const dotSize = ownsSet ? (isMobileDevice ? 18 : 20) : (isMobileDevice ? 12 : 14);
                    let dotsHtml = '';
                    if (ownsSet) {
                        dotsHtml = `<span style="color: ${groupData.color}; font-weight: bold; font-size: ${dotSize}px; line-height: 1;">â—</span>`;
                    } else {
                        // One dot per owned property
                        dotsHtml = new Array(ownedCount).fill(0)
                            .map(() => `<span style="color: ${groupData.color}; font-weight: bold; font-size: ${dotSize}px; line-height: 1;">â—</span>`)
                            .join('');
                    }
                    
                    // Red X markers for properties recently lost due to lightning in this group
                    let lostHtml = '';
                    try {
                        const positions = (propertyGroups[groupName] && propertyGroups[groupName].positions) ? propertyGroups[groupName].positions : [];
                        const lostProps = positions.filter(pos => {
                            const st = propertyState[pos];
                            if (!st) return false;
                            const struckRecently = st.lastLightningStrike && (Date.now() - st.lastLightningStrike < 15000);
                            const ownedByPlayer = st.owner && st.owner.toLowerCase() === (player.name || '').toLowerCase();
                            return struckRecently && !ownedByPlayer;
                        }).length;
                        if (lostProps > 0) {
                            const xSize = isMobileDevice ? 12 : 14;
                            lostHtml = ' ' + new Array(lostProps).fill(0)
                                .map(() => `<span title="Lost due to lightning" style="color: #ff4444; font-weight: bold; font-size: ${xSize}px; line-height: 1;">âœ•</span>`)
                                .join('');
                        }
                    } catch (_) { /* ignore */ }
                    
                    // Aggregate development badges (space-saving)
                    let devHtml = '';
                    if (groupData.totalGraveyards > 0) {
                        devHtml += `<span style="margin-left: 2px;">ðŸª¦${groupData.totalGraveyards > 1 ? groupData.totalGraveyards : ''}</span>`;
                    }
                    if (groupData.totalCrypts > 0) {
                        devHtml += `<span style="margin-left: 2px;">ðŸ°${groupData.totalCrypts > 1 ? groupData.totalCrypts : ''}</span>`;
                    }
                    
                    return `${dotsHtml}${lostHtml}${devHtml}`;
                });
            
            // Join property groups with small spacing to separate groups
            propertiesSpan.innerHTML = propertyDisplays.join('<span style="margin: 0 2px;"></span>');
            propertiesSpan.title = `${player.properties.length} properties owned`;
        } else {
            propertiesSpan.textContent = 'Nada!';
            propertiesSpan.style.fontStyle = 'italic';
        }
        
        // Steal cards indicator
        let stealCardsSpan = null;
        if (player.stealCards && player.stealCards > 0) {
            stealCardsSpan = document.createElement('span');
            stealCardsSpan.style.cssText = `
                color: #00ff00; 
                font-size: ${isMobileDevice ? '10px' : '11px'}; 
                flex-shrink: 0;
                text-shadow: 0 0 4px #00ff00;
            `;
            stealCardsSpan.innerHTML = `<img src="assets/images/spades.png" style="width: 12px; height: 12px; vertical-align: middle; margin-right: 2px;">${player.stealCards}`;
            stealCardsSpan.title = `${player.stealCards} steal card${player.stealCards > 1 ? 's' : ''}`;
        }

        // Lightning bolts indicator
        let lightningBoltsSpan = null;
        if (player.lightningBolts && player.lightningBolts > 0) {
            lightningBoltsSpan = document.createElement('span');
            lightningBoltsSpan.style.cssText = `
                color: #ffff00;
                font-size: ${isMobileDevice ? '10px' : '11px'};
                flex-shrink: 0;
                text-shadow: 0 0 4px #ffff66;
                margin-left: 4px;
                background: rgba(255, 255, 0, 0.1);
                border-radius: 3px;
                padding: 1px 3px;
                border: 1px solid rgba(255, 255, 0, 0.3);
            `;
            const boltIcon = lightningBoltImageLoaded ? `<img src="assets/images/bolts.png" style="width: 12px; height: 12px; vertical-align: middle; margin-right: 2px; filter: drop-shadow(0 0 2px #ffff00);">` : 'âš¡ ';
            lightningBoltsSpan.innerHTML = `${boltIcon}${player.lightningBolts}`;
            lightningBoltsSpan.title = `${player.lightningBolts} lightning bolt${player.lightningBolts > 1 ? 's' : ''}`;
        }
        
        // Assemble the player item
        playerItem.appendChild(tokenSection);
        if (stealCardsSpan) playerItem.appendChild(stealCardsSpan);
        if (lightningBoltsSpan) playerItem.appendChild(lightningBoltsSpan);
        playerItem.appendChild(nameSpan);
        playerItem.appendChild(moneySpan);
        playerItem.appendChild(propertiesSpan);
        
        bottomPlayerContent.appendChild(playerItem);
    });
}

// Function to show dice after property decision is made (for doubles continuation)
function showDiceAfterPropertyDecision() {
    console.log('ðŸ“± Showing dice after property decision for doubles continuation');
    
    const infoPanel = document.getElementById('info-panel');
    const minimizedContent = document.getElementById('minimized-content');
    const isMinimized = infoPanel && infoPanel.classList.contains('minimized');
    
    if (isMinimized && minimizedContent) {
        // Clear the property decision content and show standard minimized state with dice
        minimizeToStandardState();
        
        // Ensure dice are enabled and visible
        setTimeout(() => {
            const diceSection = document.getElementById('dice-section');
            if (diceSection) {
                diceSection.style.pointerEvents = 'auto';
                
                console.log('ðŸ“± Dice enabled for doubles continuation');
                
                // Show advisory message
                showAdvisory('Doubles! Click dice to roll again...', 'turn');
            }
        }, 100);
    } else {
        // If not minimized, just enable dice normally
        enableDiceSection();
        showAdvisory('Doubles! Click dice to roll again...', 'turn');
    }
}

// Function to determine if dice should be shown in minimized property decision
function shouldShowDiceInMinimizedPropertyDecision(propertyInfo, currentPlayer) {
    // If property is owned, show dice (player can continue after paying rent)
    if (propertyInfo.state.owner) {
        console.log('ðŸ“± Property is owned - showing dice (player can continue after paying rent)');
        return true;
    }
    
    // If property is unowned and player rolled doubles, show dice (doubles allow another roll)
    if (!propertyInfo.state.owner && lastRollWasDoubles) {
        console.log('ðŸ“± Unowned property but player rolled doubles - showing dice');
        return true;
    }
    
    // If property is unowned and player did NOT roll doubles, hide dice (must make purchase decision first)
    if (!propertyInfo.state.owner && !lastRollWasDoubles) {
        console.log('ðŸ“± Unowned property and no doubles - hiding dice (must decide on purchase first)');
        return false;
    }
    
    // Default case: show dice
    return true;
}

// Function to add emergency purchase buttons when normal UI fails
function addEmergencyPurchaseButtons(propertyInfo, currentPlayer, currentPlayerIndex) {
    console.log('ðŸš¨ Adding emergency purchase buttons as fallback');
    
    // Remove any existing emergency buttons first
    const existingEmergency = document.getElementById('emergency-purchase-buttons');
    if (existingEmergency) {
        existingEmergency.remove();
    }
    
    const canAffordProperty = currentPlayer.money >= propertyInfo.cost;
    const displayName = getPropertyDisplayName(propertyInfo);
    
    // Create emergency button container
    const emergencyContainer = document.createElement('div');
    emergencyContainer.id = 'emergency-purchase-buttons';
    emergencyContainer.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid #ff6600;
        border-radius: 8px;
        padding: 20px;
        text-align: center;
        z-index: 10000;
        color: white;
        font-family: 'Courier New', monospace;
        box-shadow: 0 0 20px rgba(255, 102, 0, 0.5);
    `;
    
    const purchaseButton = canAffordProperty ? `
        <button onclick="handleEmergencyPurchase('${propertyInfo.square}', ${currentPlayerIndex})"
                style="background: #00008b; color: white; border: 1px solid #0066ff; padding: 10px 20px; margin: 5px; border-radius: 4px; cursor: pointer; font-family: monospace; font-weight: bold; font-size: 14px;">
            Purchase Â£${propertyInfo.cost}
        </button>` : '';
    
    const declineButton = `
        <button onclick="handleEmergencyDecline('${propertyInfo.square}', ${currentPlayerIndex})"
                style="background: #f44336; color: white; border: 1px solid #ff6666; padding: 10px 20px; margin: 5px; border-radius: 4px; cursor: pointer; font-family: monospace; font-weight: bold; font-size: 14px;">
            Decline
        </button>`;
    
    emergencyContainer.innerHTML = `
        <div style="font-size: 18px; font-weight: bold; color: #ff6600; margin-bottom: 15px;">
            ðŸš¨ PURCHASE DECISION REQUIRED
        </div>
        <div style="font-size: 14px; margin-bottom: 10px; color: ${propertyInfo.color}; font-weight: bold;">
            ${displayName}
        </div>
        <div style="font-size: 12px; margin-bottom: 15px; line-height: 1.4;">
            Cost: Â£${propertyInfo.cost}<br>
            Your money: Â£${currentPlayer.money}<br>
            ${canAffordProperty ? 'âœ… You can afford this property' : 'âŒ You cannot afford this property'}
        </div>
        <div>
            ${purchaseButton}
            ${declineButton}
        </div>
        <div style="font-size: 10px; margin-top: 10px; color: #ccc;">
            Emergency UI - Make your decision to continue
        </div>
    `;
    
    document.body.appendChild(emergencyContainer);
    
    console.log('ðŸš¨ Emergency purchase buttons added to screen');
}

// Emergency purchase handlers
window.handleEmergencyPurchase = function(square, playerIndex) {
    console.log('ðŸš¨ Emergency purchase triggered');
    
    // Remove emergency UI
    const emergencyContainer = document.getElementById('emergency-purchase-buttons');
    if (emergencyContainer) {
        emergencyContainer.remove();
    }
    
    // Call the regular purchase handler
    handlePropertyPurchase(square, playerIndex);
};

window.handleEmergencyDecline = function(square, playerIndex) {
    console.log('ðŸš¨ Emergency decline triggered');
    
    // Remove emergency UI
    const emergencyContainer = document.getElementById('emergency-purchase-buttons');
    if (emergencyContainer) {
        emergencyContainer.remove();
    }
    
    // Call the regular decline handler
    handleDeclinePurchase(square, playerIndex);
};

// Debug function to help with purchase decision issues
window.debugPurchaseDecision = function() {
    console.log('ðŸ” PURCHASE DECISION DEBUG INFO:');
    
    if (!players || currentPlayerIndex === undefined) {
        console.log('âŒ Game state not available');
        return;
    }
    
    const currentPlayer = players[currentPlayerIndex];
    const propertyInfo = getPropertyInfo(currentPlayer.currentSquare);
    
    console.log('Current Player:', currentPlayer.name);
    console.log('Current Square:', currentPlayer.currentSquare);
    console.log('Property Info:', propertyInfo);
    console.log('Property Owner:', propertyInfo?.state?.owner || 'None');
    console.log('Player Money:', currentPlayer.money);
    console.log('Property Cost:', propertyInfo?.cost || 'N/A');
    console.log('Can Afford:', propertyInfo ? currentPlayer.money >= propertyInfo.cost : 'N/A');
    
    // Check UI elements
    const infoPanel = document.getElementById('info-panel');
    const minimizedContent = document.getElementById('minimized-content');
    const purchaseButtons = document.querySelectorAll('button[onclick*="Purchase"], button[onclick*="handlePropertyPurchase"], button[onclick*="handleMinimizedPropertyPurchase"]');
    const declineButtons = document.querySelectorAll('button[onclick*="Decline"], button[onclick*="handleDeclinePurchase"], button[onclick*="handleMinimizedDeclinePurchase"]');
    
    console.log('Info Panel Minimized:', infoPanel?.classList.contains('minimized') || false);
    console.log('Purchase Buttons Found:', purchaseButtons.length);
    console.log('Decline Buttons Found:', declineButtons.length);
    
    // Check button visibility
    purchaseButtons.forEach((btn, i) => {
        const rect = btn.getBoundingClientRect();
        console.log(`Purchase Button ${i+1}: visible=${rect.width > 0 && rect.height > 0}, clickable=${btn.style.pointerEvents !== 'none'}`);
    });
    
    declineButtons.forEach((btn, i) => {
        const rect = btn.getBoundingClientRect();
        console.log(`Decline Button ${i+1}: visible=${rect.width > 0 && rect.height > 0}, clickable=${btn.style.pointerEvents !== 'none'}`);
    });
    
    // Check dice state
    const diceSection = document.getElementById('dice-section');
    if (diceSection) {
        console.log('Dice Disabled:', diceSection.style.pointerEvents === 'none');
        console.log('Dice Classes:', Array.from(diceSection.classList).join(', '));
    }
    
    console.log('ðŸ”§ Available fixes:');
    console.log('- forcePurchaseDecision() - Force show purchase UI');
    console.log('- forceDeclineProperty() - Auto-decline current property');
    console.log('- forceEnableDice() - Force enable dice');
    console.log('- showEmergencyPurchaseUI() - Show emergency purchase buttons');
    
    return {
        currentPlayer,
        propertyInfo,
        canAfford: propertyInfo ? currentPlayer.money >= propertyInfo.cost : false,
        buttonsFound: purchaseButtons.length + declineButtons.length,
        panelMinimized: infoPanel?.classList.contains('minimized') || false
    };
};

// Quick fix functions for console use
window.forcePurchaseDecision = function() {
    const currentPlayer = players[currentPlayerIndex];
    const propertyInfo = getPropertyInfo(currentPlayer.currentSquare);
    if (propertyInfo && !propertyInfo.state.owner) {
        updateInfoPanel(null, null, propertyInfo);
        console.log('âœ… Purchase decision UI forced');
    } else {
        console.log('âŒ No unowned property to make decision for');
    }
};

window.forceDeclineProperty = function() {
    const currentPlayer = players[currentPlayerIndex];
    const propertyInfo = getPropertyInfo(currentPlayer.currentSquare);
    if (propertyInfo && !propertyInfo.state.owner) {
        handleDeclinePurchase(propertyInfo.square, currentPlayerIndex);
        console.log('âœ… Property auto-declined');
    } else {
        console.log('âŒ No unowned property to decline');
    }
};

window.forceEnableDice = function() {
    const diceSection = document.getElementById('dice-section');
    if (diceSection) {
        diceSection.style.pointerEvents = 'auto';
        removeAllDicePulseClasses(diceSection);
        const currentPlayer = players[currentPlayerIndex];
        const playerPulseClass = getPlayerDicePulseClassByPlayer(currentPlayer);
        diceSection.classList.add(playerPulseClass);
        isDiceRollInProgress = false;
        console.log(`âœ… Dice force-enabled with player color: ${playerPulseClass}`);
    } else {
        console.log('âŒ Dice section not found');
    }
};

window.showEmergencyPurchaseUI = function() {
    const currentPlayer = players[currentPlayerIndex];
    const propertyInfo = getPropertyInfo(currentPlayer.currentSquare);
    if (propertyInfo && !propertyInfo.state.owner) {
        addEmergencyPurchaseButtons(propertyInfo, currentPlayer, currentPlayerIndex);
        console.log('âœ… Emergency purchase UI shown');
    } else {
        console.log('âŒ No unowned property for emergency UI');
    }
};

// Test function for Grave Tax message
window.testGraveTax = function() {
    console.log('ðŸ§ª Testing Grave Tax message...');
    
    // Show the Grave Tax message
    showAdvisory('Grave Tax!', 'tax');
    
    setTimeout(() => {
        const currentPlayer = players[currentPlayerIndex];
        if (currentPlayer) {
            showAdvisory(`${currentPlayer.name} is sent to Jail and charged Â£100!`, 'payment');
        } else {
            showAdvisory('Player is sent to Jail and charged Â£100!', 'payment');
        }
    }, 2500);
    
    console.log('âœ… Grave Tax message sequence initiated');
};

// Test function to simulate gojail landing
window.testGojailLanding = function() {
    console.log('ðŸ§ª Testing gojail landing...');
    
    const currentPlayer = players[currentPlayerIndex];
    if (!currentPlayer) {
        console.log('âŒ No current player found');
        return;
    }
    
    // Move player to gojail
    const gojailPos = positionsMap.get('gojail');
    if (gojailPos) {
        currentPlayer.currentSquare = 'gojail';
        currentPlayer.x = gojailPos.x;
        currentPlayer.y = gojailPos.y;
        
        console.log(`ðŸ“ Moved ${currentPlayer.name} to gojail`);
        updateGameFrame();
        
        // Trigger the gojail landing
        setTimeout(() => {
            checkGojailLanding(currentPlayer);
        }, 500);
    } else {
        console.log('âŒ Gojail position not found');
    }
};

// Function to show property decision in minimized mode
function showMinimizedPropertyDecision(propertyInfo, currentPlayer, currentPlayerIndex, canAffordProperty) {
    const infoPanel = document.getElementById('info-panel');
    const minimizedContent = document.getElementById('minimized-content');
    const propertyInfoContent = document.getElementById('property-info-content');
    
    if (!minimizedContent) {
        console.error('Minimized content not found - cannot show property decision');
        return;
    }
    
    // Hide the property-info-content section while in minimized property decision mode
    if (propertyInfoContent) {
        propertyInfoContent.style.display = 'none';
        propertyInfoContent.setAttribute('data-was-visible-before-minimized', propertyInfoContent.style.display !== 'none' ? 'true' : 'false');
    }
    

    
    // Player info content is permanently hidden since we use bottom-player-display now
    const playerInfoContent = document.getElementById('player-info-content');
    if (playerInfoContent) {
        playerInfoContent.style.display = 'none';
        // Don't track visibility since it should always stay hidden
    }
    
    // Store the original minimized content to restore later
    const originalContent = minimizedContent.innerHTML;
    
    // Preserve dice section and turn-info if they exist in minimized content
    const diceSection = minimizedContent.querySelector('#dice-section');
    const turnInfo = minimizedContent.querySelector('#turn-info');
    
    // Also check for dice section in other locations if not in minimized content
    let preservedDiceSection = diceSection || document.getElementById('dice-section');
    
    // Create property decision content for minimized mode
    const state = propertyInfo.state;
    const owner = players.find(p => p.name.toLowerCase() === (state.owner || '').toLowerCase());
    const rentInfo = calculateRent(propertyInfo);
    
    // Create purchase and decline buttons
    let purchaseButton = '';
    let declineButton = '';
    
    if (canAffordProperty) {
        purchaseButton = `
            <button onclick="handleMinimizedPropertyPurchase('${propertyInfo.square}', ${currentPlayerIndex})" 
                    ontouchstart="this.style.transform='scale(0.95)'" 
                    ontouchend="this.style.transform='scale(1)'"
                    style="background-color: #00008b; color: white; border: 1px solid #0066ff; padding: 2px 4px; border-radius: 3px; cursor: pointer; font-family: 'Courier New', 'Lucida Console', 'Monaco', 'Consolas', monospace; font-weight: bold; text-shadow: 0 0 2px #00ff00; box-shadow: 0 0 4px rgba(0, 102, 255, 0.5); font-size: 9px; touch-action: manipulation; flex: 1; max-width: 120px;">
                Buy Â£${propertyInfo.cost}
            </button>`;
    }
    
    declineButton = `
        <button onclick="handleMinimizedDeclinePurchase('${propertyInfo.square}', ${currentPlayerIndex})"
                ontouchstart="this.style.transform='scale(0.95)'" 
                ontouchend="this.style.transform='scale(1)'"
                style="background-color: #f44336; color: white; border: 1px solid #ff6666; padding: 2px 4px; border-radius: 3px; cursor: pointer; font-family: 'Courier New', 'Lucida Console', 'Monaco', 'Consolas', monospace; font-weight: bold; text-shadow: 0 0 2px #ff0000; box-shadow: 0 0 4px rgba(255, 68, 54, 0.5); font-size: 9px; touch-action: manipulation; flex: 1; max-width: 120px;">
            Decline
        </button>`;
    
    // Replace minimized content with property decision
    const autoPurchaseEnabled = (localStorage.getItem('autoPurchaseEnabled') || 'false') === 'true';
    const autoPurchaseToggle = `
        <label style="display:inline-flex; align-items:center; gap:4px; margin-top:6px; font-size:10px; color:#ddd; cursor:pointer;">
            <input type="checkbox" id="auto-purchase-toggle-min" ${autoPurchaseEnabled ? 'checked' : ''} style="transform: scale(1.1); cursor:pointer;" />
            Auto purchase
        </label>`;

    const minimizedHTML = `
        <div style="text-align: center; padding: 5px;">
            <div style="font-weight: bold; color: ${propertyInfo.color}; font-size: 12px; text-shadow: 0 0 4px ${propertyInfo.color}; margin-bottom: 5px;">
                ${getPropertyDisplayNameWithoutNumber(propertyInfo)}
            </div>
            <div style="font-size: 10px; margin-bottom: 8px; line-height: 1.3;">
                Cost: Â£${propertyInfo.cost}<br>
                ${owner ? `Owner: ${owner.name}` : 'Unowned'}<br>
                Rent: Â£${rentInfo.amount}
            </div>
            <div style="display: flex; justify-content: center; gap: 3px; flex-wrap: nowrap;">
                ${purchaseButton}
                ${declineButton}
            </div>
            <div>${autoPurchaseToggle}</div>
        </div>
    `;
    
    // Use safe innerHTML setting if available, otherwise fall back to regular innerHTML
    if (typeof window.safeSetInnerHTML === 'function') {
        window.safeSetInnerHTML(minimizedContent, minimizedHTML);
    } else {
        minimizedContent.innerHTML = minimizedHTML;
    }
    
    console.log(`ðŸ“± Minimized purchase UI created - buttons: ${purchaseButton ? 'BUY' : ''}${declineButton ? ' DECLINE' : ''}`);
    
    // Add enhanced touch event handlers for better mobile compatibility
    setTimeout(() => {
        const toggleMin = document.getElementById('auto-purchase-toggle-min');
        if (toggleMin) {
            toggleMin.addEventListener('change', (e) => {
                const enabled = e.target.checked;
                localStorage.setItem('autoPurchaseEnabled', enabled ? 'true' : 'false');
                console.log('âš™ï¸ Auto purchase (min) set to', enabled);
            });

            // If enabled and purchase button exists, auto-click it in minimized UI
            try {
                const enabledNow = toggleMin.checked;
                if (enabledNow && purchaseButton) {
                    const canAffordNow = players[currentPlayerIndex]?.money >= (propertyInfo?.cost || Infinity);
                    const isMyTurnNow = !isMultiplayerGame || (players[currentPlayerIndex]?.name?.toLowerCase() === (window.localPlayerName || document.getElementById('player1-name')?.value || '').toLowerCase());
                    if (canAffordNow && isMyTurnNow) {
                        const btn = minimizedContent.querySelector('button[onclick^="handleMinimizedPropertyPurchase("]');
                        if (btn) {
                            console.log('ðŸ›’ Auto-purchase (min) enabled: auto-clicking Purchase');
                            setTimeout(() => btn.click(), 50);
                        }
                    }
                }
            } catch (e) {
                console.warn('Auto-click purchase (min) failed:', e);
            }
        }

        const buttons = minimizedContent.querySelectorAll('button');
        console.log(`ðŸ“± Adding touch handlers to ${buttons.length} minimized buttons`);
        
        buttons.forEach((button, index) => {
            // Enhanced touch handling for mobile
            button.addEventListener('touchstart', function(e) {
                console.log(`ðŸ“± Touch start on minimized button ${index + 1}`);
                this.style.transform = 'scale(0.95)';
                this.style.opacity = '0.8';
            }, { passive: true });
            
            button.addEventListener('touchend', function(e) {
                console.log(`ðŸ“± Touch end on minimized button ${index + 1} - triggering click`);
                e.preventDefault();
                e.stopPropagation();
                this.style.transform = 'scale(1)';
                this.style.opacity = '1';
                
                // Trigger the onclick handler manually if needed
                const onclickAttr = this.getAttribute('onclick');
                if (onclickAttr) {
                    console.log(`ðŸ“± Executing onclick: ${onclickAttr}`);
                    try {
                        eval(onclickAttr);
                    } catch (error) {
                        console.error(`ðŸ“± Error executing onclick: ${error.message}`);
                    }
                }
            }, { passive: false });
            
            // Add click event as backup
            button.addEventListener('click', function(e) {
                console.log(`ðŸ“± Click event on minimized button ${index + 1}`);
                e.preventDefault();
                e.stopPropagation();
            }, { passive: false });
        });
    }, 100);
    
    // Determine if dice should be shown based on game state
    const shouldShowDice = shouldShowDiceInMinimizedPropertyDecision(propertyInfo, currentPlayer);
    console.log(`ðŸ“± Dice visibility decision: ${shouldShowDice ? 'SHOW' : 'HIDE'} (rolled doubles: ${lastRollWasDoubles}, unowned property: ${!propertyInfo.state.owner})`);
    
    // Always preserve the dice section, but only show it if appropriate
    let finalDiceSection = preservedDiceSection;
    
    // Temporarily store dice section in a safe location if it shouldn't be shown
    let tempDiceParent = null;
    if (!shouldShowDice && finalDiceSection) {
        // Move dice to a temporary hidden location to preserve it
        tempDiceParent = document.createElement('div');
        tempDiceParent.style.display = 'none';
        tempDiceParent.id = 'temp-dice-storage';
        document.body.appendChild(tempDiceParent);
        tempDiceParent.appendChild(finalDiceSection);
        console.log('ðŸ“± Dice section temporarily hidden but preserved for later use');
    }
    
    if (shouldShowDice && finalDiceSection) {
        console.log('ðŸ“± Ensuring dice section is present in minimized property decision');
        
        // Preserve current pulse classes and pointer events
        const currentClasses = Array.from(finalDiceSection.classList);
        const currentPointerEvents = finalDiceSection.style.pointerEvents;
        
        // Store original parent info if not already stored
        if (!finalDiceSection.getAttribute('data-original-parent-id')) {
            finalDiceSection.setAttribute('data-original-parent-id', finalDiceSection.parentElement?.id || 'info-panel-content');
        }
        
        // Apply minimized styling while preserving functionality
        const isMobileDevice = window.innerWidth <= 768;
        const diceScale = isMobileDevice ? '0.6' : '0.8';
        const marginTop = isMobileDevice ? '3px' : '5px';
        
        finalDiceSection.style.cssText = `margin-top: ${marginTop}; transform: scale(${diceScale}); transform-origin: left center; position: relative; z-index: 100;`;
        // Always ensure dice are clickable in minimized mode (don't preserve 'none' state)
        finalDiceSection.style.pointerEvents = 'auto';
        
        // Ensure individual dice elements are also clickable
        const die1 = finalDiceSection.querySelector('#die1');
        const die2 = finalDiceSection.querySelector('#die2');
        if (die1) {
            die1.style.pointerEvents = 'auto';
            die1.style.cursor = 'pointer';
            die1.style.zIndex = '101';
        }
        if (die2) {
            die2.style.pointerEvents = 'auto';
            die2.style.cursor = 'pointer';
            die2.style.zIndex = '101';
        }
        console.log('ðŸ“± Dice section pointer events set to auto in minimized property decision');
        
        // Restore all classes (including pulse classes)
        finalDiceSection.className = 'dice-section'; // Reset base class
        currentClasses.forEach(cls => {
            if (cls !== 'dice-section') { // Don't duplicate base class
                finalDiceSection.classList.add(cls);
            }
        });
        
        // Ensure it has pulse if it's the player's turn
        if (!finalDiceSection.classList.contains('dice-pulse')) {
            finalDiceSection.classList.add('dice-pulse');
            console.log('ðŸ“± Added dice-pulse class to ensure visibility');
        }
        
        minimizedContent.appendChild(finalDiceSection);
        console.log('ðŸ“± Dice section ensured in minimized property decision with classes:', Array.from(finalDiceSection.classList));
        
        // Apply enhanced touch handlers to the dice section in minimized content
        setTimeout(() => {
            console.log('ðŸ“± Adding touch handlers to minimized dice section');
            
            // Remove any existing listeners first
            finalDiceSection.removeEventListener('touchstart', handleDiceTouchStart);
            finalDiceSection.removeEventListener('touchend', handleDiceTouchEnd);
            finalDiceSection.removeEventListener('click', triggerDiceRoll);
            
            // Add enhanced touch handlers specifically for minimized mode
            finalDiceSection.addEventListener('touchstart', function(e) {
                e.preventDefault();
                e.stopPropagation();
                this.classList.add('touch-feedback');
                console.log('ðŸ“± Minimized dice touch start');
            }, { passive: false });
            
            finalDiceSection.addEventListener('touchend', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const self = this;
                setTimeout(() => {
                    self.classList.remove('touch-feedback');
                }, 150);
                
                console.log('ðŸ“± Minimized dice touch end - calling handleDiceClick');
                
                // Use the proper dice click handler
                if (typeof handleDiceClick === 'function') {
                    handleDiceClick('minimized-touch');
                } else {
                    console.error('ðŸ“± handleDiceClick function not found');
                }
            }, { passive: false });
            
            // Also add click handler as fallback
            finalDiceSection.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.log('ðŸ“± Minimized dice click - calling handleDiceClick');
                
                if (typeof handleDiceClick === 'function') {
                    handleDiceClick('minimized-click');
                } else {
                    console.error('ðŸ“± handleDiceClick function not found');
                }
            });
            
            // Also add handlers to individual dice elements
            const dice = finalDiceSection.querySelectorAll('.die, [id^="die"]');
            dice.forEach((die, index) => {
                console.log(`ðŸ“± Adding touch handlers to die ${index + 1}:`, die.id || die.className);
                
                // Remove existing listeners
                die.removeEventListener('touchstart', handleDiceTouchStart);
                die.removeEventListener('touchend', handleDiceTouchEnd);
                die.removeEventListener('click', triggerDiceRoll);
                
                // Add touch handlers to individual dice
                die.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.classList.add('touch-feedback');
                    console.log('ðŸ“± Individual die touch start:', this.id || this.className);
                }, { passive: false });
                
                die.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const self = this;
                    setTimeout(() => {
                        self.classList.remove('touch-feedback');
                    }, 150);
                    
                    console.log('ðŸ“± Individual die touch end - calling handleDiceClick:', this.id || this.className);
                    
                    if (typeof handleDiceClick === 'function') {
                        handleDiceClick('individual-die-touch');
                    } else {
                        console.error('ðŸ“± handleDiceClick function not found');
                    }
                }, { passive: false });
                
                // Click handler as fallback
                die.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('ðŸ“± Individual die click - calling handleDiceClick:', this.id || this.className);
                    
                    if (typeof handleDiceClick === 'function') {
                        handleDiceClick('individual-die-click');
                    } else {
                        console.error('ðŸ“± handleDiceClick function not found');
                    }
                });
            });
            
            console.log('ðŸ“± Enhanced touch handlers applied to minimized dice section and', dice.length, 'individual dice');
            
            // Add CSS for better mobile touch feedback
            if (!document.getElementById('mobile-dice-touch-styles')) {
                const style = document.createElement('style');
                style.id = 'mobile-dice-touch-styles';
                style.textContent = `
                    /* Enhanced mobile dice touch feedback */
                    .dice-section {
                        -webkit-tap-highlight-color: rgba(255, 255, 255, 0.3) !important;
                        touch-action: manipulation !important;
                        user-select: none !important;
                        -webkit-user-select: none !important;
                    }
                    
                    .dice-section.touch-feedback {
                        background: rgba(255, 255, 255, 0.2) !important;
                        transform: scale(0.95) !important;
                        transition: all 0.1s ease !important;
                    }
                    
                    .die {
                        -webkit-tap-highlight-color: rgba(255, 255, 255, 0.4) !important;
                        touch-action: manipulation !important;
                        user-select: none !important;
                        -webkit-user-select: none !important;
                        cursor: pointer !important;
                    }
                    
                    .die.touch-feedback {
                        transform: scale(0.9) !important;
                        transition: all 0.1s ease !important;
                        /* Don't override background - let player colors show through */
                    }
                    
                    /* Mobile-specific improvements - Better definition */
                    @media (max-width: 768px), (max-device-width: 768px) {
                        .dice-section {
                            min-height: 48px !important;
                            min-width: 48px !important;
                            padding: 8px !important;
                            border-radius: 8px !important;
                        }
                        
                        .die {
                            min-height: 32px !important;
                            min-width: 32px !important;
                            max-height: 32px !important;
                            max-width: 32px !important;
                            font-size: 18px !important;
                            margin: 3px !important;
                            border-radius: 6px !important;
                            /* Enhanced mobile dice definition */
                            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2) !important;
                            text-rendering: optimizeLegibility !important;
                            -webkit-font-smoothing: antialiased !important;
                        }
                    }
                `;
                document.head.appendChild(style);
                console.log('ðŸ“± Mobile dice touch styles added');
            }
        }, 100);
        
    } else if (!shouldShowDice) {
        console.log('ðŸ“± Dice intentionally hidden in minimized property decision (no doubles rolled)');
    } else {
        console.error('ðŸ“± Could not find dice section to add to minimized content');
    }
    
    // Restore turn-info if it existed
    if (turnInfo) {
        console.log('ðŸ“± Preserving turn-info in minimized property decision');
        minimizedContent.appendChild(turnInfo);
    }
    
    // Store original content for restoration
    minimizedContent.setAttribute('data-original-content', originalContent);
    
    // Add mobile touch event handlers for better mobile compatibility
    setTimeout(() => {
        const buttons = minimizedContent.querySelectorAll('button');
        buttons.forEach(button => {
            // Remove any existing event listeners
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            
            // Add optimized touch handlers
            let touchStartTime = 0;
            let hasTouchMoved = false;
            
            newButton.addEventListener('touchstart', function(e) {
                console.log('ðŸ“± Touch start on minimized button:', this.textContent);
                touchStartTime = Date.now();
                hasTouchMoved = false;
                this.style.transform = 'scale(0.95)';
                this.style.opacity = '0.8';
            }, { passive: true });
            
            newButton.addEventListener('touchmove', function(e) {
                hasTouchMoved = true;
            }, { passive: true });
            
            newButton.addEventListener('touchend', function(e) {
                console.log('ðŸ“± Touch end on minimized button:', this.textContent);
                e.preventDefault();
                e.stopPropagation();
                
                this.style.transform = 'scale(1)';
                this.style.opacity = '1';
                
                // Only trigger click if it was a tap (not a drag) and within reasonable time
                const touchDuration = Date.now() - touchStartTime;
                if (!hasTouchMoved && touchDuration < 1000) {
                    console.log('ðŸ“± Triggering click for minimized button:', this.textContent);
                    setTimeout(() => {
                        // Manually trigger the onclick handler
                        const onclickAttr = this.getAttribute('onclick');
                        if (onclickAttr) {
                            console.log('ðŸ“± Executing onclick:', onclickAttr);
                            try {
                                eval(onclickAttr);
                            } catch (error) {
                                console.error('Error executing onclick:', error);
                                // Fallback to regular click
                                this.click();
                            }
                        } else {
                            this.click();
                        }
                    }, 10);
                }
            }, { passive: false });
            
            // Add click handler as backup
            newButton.addEventListener('click', function(e) {
                console.log('ðŸ“± Click event on minimized button:', this.textContent);
            });
        });
        
        // Start auto-action timer for purchase decision
        if (buttons.length > 0 && !currentPlayer.isAI) {
            startAutoActionTimer('purchase');
        }
    }, 50);
}

// Function to restore minimized content after property decision
function restoreMinimizedContent() {
    const minimizedContent = document.getElementById('minimized-content');
    const propertyInfoContent = document.getElementById('property-info-content');
    const diceSection = document.getElementById('dice-section');
    
    // First, restore the dice section and turn-info before restoring other content
    if (diceSection && minimizedContent && diceSection.parentElement === minimizedContent) {
        const storedParentId = diceSection.getAttribute('data-original-parent-id');
        const originalDiceParent = storedParentId ? 
            document.getElementById(storedParentId) : 
            document.getElementById('info-panel-content');
        
        if (originalDiceParent) {
            console.log('ðŸ“± Moving dice back to original location before content restoration', {
                currentParent: diceSection.parentElement?.id,
                targetParent: originalDiceParent.id,
                storedParentId: storedParentId
            });
            
            // Remove the stored parent ID attribute
            diceSection.removeAttribute('data-original-parent-id');
            
            // Move dice back to original location first
            originalDiceParent.appendChild(diceSection);
        }
    }
    
    // Also restore turn-info element if it was moved to minimized content
    const turnInfo = document.getElementById('turn-info');
    if (turnInfo && minimizedContent && turnInfo.parentElement === minimizedContent) {
        const storedTurnInfoParentId = turnInfo.getAttribute('data-original-parent-id');
        const originalTurnInfoParent = storedTurnInfoParentId ? 
            document.getElementById(storedTurnInfoParentId) : 
            document.getElementById('info-panel-content');
        
        if (originalTurnInfoParent) {
            console.log('ðŸ“± Moving turn-info back to original location before content restoration');
            
            // Remove the stored parent ID attribute
            turnInfo.removeAttribute('data-original-parent-id');
            
            // Move turn-info back to original location
            originalTurnInfoParent.appendChild(turnInfo);
        }
    }
    
    // Then restore the minimized content (this won't affect the dice since it's already moved)
    if (minimizedContent) {
        const originalContent = minimizedContent.getAttribute('data-original-content');
        if (originalContent) {
            // Temporarily store the dice section if it's in minimized content
            const diceInMinimized = minimizedContent.querySelector('#dice-section');
            const turnInfoInMinimized = minimizedContent.querySelector('#turn-info');
            
            // Restore the original content
            minimizedContent.innerHTML = originalContent;
            minimizedContent.removeAttribute('data-original-content');
            
            // If dice section was in minimized content, move it back to its proper location
            if (diceInMinimized) {
                console.log('ðŸ“± Dice section was in minimized content - moving to proper location');
                const infoPanelContent = document.getElementById('info-panel-content');
                const diceContent = document.getElementById('dice-content');
                
                if (diceContent) {
                    diceContent.appendChild(diceInMinimized);
                    console.log('ðŸ“± Moved dice section to dice-content');
                } else if (infoPanelContent) {
                    infoPanelContent.appendChild(diceInMinimized);
                    console.log('ðŸ“± Moved dice section to info-panel-content');
                }
            }
            
            // Check for dice section in temporary storage and restore it
            const tempDiceStorage = document.getElementById('temp-dice-storage');
            if (tempDiceStorage) {
                const tempDiceSection = tempDiceStorage.querySelector('#dice-section');
                if (tempDiceSection) {
                    console.log('ðŸ“± Restoring dice section from temporary storage');
                    const infoPanelContent = document.getElementById('info-panel-content');
                    const diceContent = document.getElementById('dice-content');
                    
                    if (diceContent) {
                        diceContent.appendChild(tempDiceSection);
                        console.log('ðŸ“± Restored dice section to dice-content from temp storage');
                    } else if (infoPanelContent) {
                        infoPanelContent.appendChild(tempDiceSection);
                        console.log('ðŸ“± Restored dice section to info-panel-content from temp storage');
                    }
                }
                // Clean up temporary storage
                tempDiceStorage.remove();
                console.log('ðŸ“± Cleaned up temporary dice storage');
            }
            
            // If turn-info was in minimized content, move it back to its proper location
            if (turnInfoInMinimized) {
                console.log('ðŸ“± Turn-info was in minimized content - moving to proper location');
                const infoPanelContent = document.getElementById('info-panel-content');
                if (infoPanelContent) {
                    infoPanelContent.appendChild(turnInfoInMinimized);
                    console.log('ðŸ“± Moved turn-info to info-panel-content');
                }
            }
        }
    }
    
    // Restore the property-info-content to its original location and styling
    if (propertyInfoContent) {
        const wasVisible = propertyInfoContent.getAttribute('data-was-visible-before-minimized');
        const originalParentId = propertyInfoContent.getAttribute('data-original-parent-id');
        const originalStyle = propertyInfoContent.getAttribute('data-original-style');
        
        // Restore to original parent if it exists
        if (originalParentId) {
            const originalParent = document.getElementById(originalParentId);
            if (originalParent && propertyInfoContent.parentElement !== originalParent) {
                originalParent.appendChild(propertyInfoContent);
                console.log('ðŸ“± Restored property-info-content to original parent:', originalParentId);
            }
        }
        
        // Restore original styling
        if (originalStyle) {
            propertyInfoContent.style.cssText = originalStyle;
            propertyInfoContent.removeAttribute('data-original-style');
        }
        
        // Restore button styling
        const buttons = propertyInfoContent.querySelectorAll('button[data-original-style]');
        buttons.forEach(button => {
            const originalButtonStyle = button.getAttribute('data-original-style');
            if (originalButtonStyle) {
                button.style.cssText = originalButtonStyle;
                button.removeAttribute('data-original-style');
            }
        });
        
        if (wasVisible === 'true') {
            propertyInfoContent.style.display = 'block';
        }
        
        // Clean up attributes
        propertyInfoContent.removeAttribute('data-was-visible-before-minimized');
        propertyInfoContent.removeAttribute('data-original-parent-id');
    }
    

    
    // Player info content stays hidden since we use bottom-player-display now
    const playerInfoContent = document.getElementById('player-info-content');
    if (playerInfoContent) {
        playerInfoContent.style.display = 'none';
        // Remove any old attributes
        playerInfoContent.removeAttribute('data-was-visible-before-minimized');
    }
    
         // Re-enable dice functionality after restoration
     if (diceSection) {
         setTimeout(() => {
             const infoPanel = document.getElementById('info-panel');
             const isStillMinimized = infoPanel && infoPanel.classList.contains('minimized');
             
             if (isStillMinimized) {
                 console.log('ðŸ“± Still in minimized mode - preserving minimized dice handlers');
                 // Don't call enableDiceSection, just ensure basic clickability
                 diceSection.style.pointerEvents = '';
                 diceSection.classList.remove('dice-disabled');
                 
                 // Re-attach minimized handlers if needed
                 const minimizedContent = document.getElementById('minimized-content');
                 if (minimizedContent && diceSection.parentElement === minimizedContent) {
                     reattachMinimizedDiceHandlers(diceSection);
                 }
             } else {
                 // Reset pointer events and ensure dice is properly enabled
                 diceSection.style.pointerEvents = '';
                 enableDiceSection();
                 
                 // Force the dice to be clickable by removing any blocking classes/styles
                 diceSection.classList.remove('dice-disabled');
             }
             
             console.log('ðŸ“± Dice section re-enabled after minimized mode restoration', {
                 isMinimized: isStillMinimized,
                 pointerEvents: diceSection.style.pointerEvents,
                 classList: Array.from(diceSection.classList)
             });
         }, 100);
     } else {
         // Dice section is missing - try to recreate it
         console.log('ðŸ“± Dice section missing after content restoration - attempting to recreate');
         setTimeout(() => {
             const missingDiceSection = document.getElementById('dice-section');
             if (!missingDiceSection) {
                 console.log('ðŸ“± Recreating missing dice section');
                 const infoPanelContent = document.getElementById('info-panel-content');
                 const diceContent = document.getElementById('dice-content');
                 
                 if (diceContent) {
                     const newDiceSection = document.createElement('div');
                     newDiceSection.id = 'dice-section';
                     newDiceSection.className = 'dice-section';
                     newDiceSection.innerHTML = `
                         <div id="die1" class="die">1</div>
                         <div id="die2" class="die">1</div>
                     `;
                     
                     diceContent.appendChild(newDiceSection);
                     console.log('ðŸ“± Recreated dice section in dice-content');
                     
                     // Enable the newly created dice section
                     setTimeout(() => {
                         enableDiceSection();
                     }, 100);
                 } else if (infoPanelContent) {
                     const newDiceSection = document.createElement('div');
                     newDiceSection.id = 'dice-section';
                     newDiceSection.className = 'dice-section';
                     newDiceSection.innerHTML = `
                         <div id="die1" class="die">1</div>
                         <div id="die2" class="die">1</div>
                     `;
                     
                     infoPanelContent.appendChild(newDiceSection);
                     console.log('ðŸ“± Recreated dice section in info-panel-content');
                     
                     // Enable the newly created dice section
                     setTimeout(() => {
                         enableDiceSection();
                     }, 100);
                 }
             } else {
                 console.log('ðŸ“± Dice section found on retry - enabling');
                 enableDiceSection();
             }
         }, 100);
     }
}

// Function to revert window to standard minimized state
function revertToStandardMinimized() {
    const infoPanel = document.getElementById('info-panel');
    if (!infoPanel) {
        console.log('[revertToStandardMinimized] Info panel not found');
        return;
    }

    const isPropertyDecision = infoPanel.classList.contains('property-decision');

    console.log('[revertToStandardMinimized] Current state:', {
        isPropertyDecision: isPropertyDecision
    });

    // If we're in property-decision mode (purchase/decline prompt), revert to standard minimized
    if (isPropertyDecision) {
        console.log('[revertToStandardMinimized] Reverting from property-decision to standard minimized');
        // Use the new function to create proper standard minimized state
        minimizeToStandardState();
        console.log('[revertToStandardMinimized] Successfully reverted to standard minimized state');
    }
}

// Function to ensure dice section exists
function ensureDiceSectionExists() {
    let diceSection = document.getElementById('dice-section');
    
    if (!diceSection) {
        console.log('ðŸ“± Dice section missing - creating new one');
        const infoPanelContent = document.getElementById('info-panel-content');
        const diceContent = document.getElementById('dice-content');
        
        diceSection = document.createElement('div');
        diceSection.id = 'dice-section';
        diceSection.className = 'dice-section';
        diceSection.innerHTML = `
            <div id="die1" class="die">1</div>
            <div id="die2" class="die">1</div>
        `;
        
        if (diceContent) {
            diceContent.appendChild(diceSection);
            console.log('ðŸ“± Created dice section in dice-content');
        } else if (infoPanelContent) {
            infoPanelContent.appendChild(diceSection);
            console.log('ðŸ“± Created dice section in info-panel-content');
        } else {
            console.error('ðŸ“± No suitable container found for dice section');
            return null;
        }
    }
    
    return diceSection;
}

// Function to ensure dice stays in minimized content during turn transitions
function ensureDiceInMinimizedContent() {
    const infoPanel = document.getElementById('info-panel');
    const minimizedContent = document.getElementById('minimized-content');
    
    // Only act if panel is minimized
    if (!infoPanel || !infoPanel.classList.contains('minimized') || !minimizedContent) {
        return;
    }
    
    // Check for duplicate dice sections and remove them
    const allDiceSections = document.querySelectorAll('[id="dice-section"]');
    if (allDiceSections.length > 1) {
        console.log(`ðŸ“± Found ${allDiceSections.length} dice sections - removing duplicates`);
        // Keep only the first one, remove the rest
        for (let i = 1; i < allDiceSections.length; i++) {
            allDiceSections[i].remove();
            console.log(`ðŸ“± Removed duplicate dice section ${i + 1}`);
        }
    }
    
    const diceSection = document.getElementById('dice-section');
    if (!diceSection) {
        console.log('ðŸ“± No dice section found after duplicate cleanup');
        return;
    }
    
    // Check if dice is already in minimized content
    if (diceSection.parentElement === minimizedContent) {
        console.log('ðŸ“± Dice already in minimized content - cleaning up classes and ensuring pulse');
        
        // Clean up any purchase buttons that shouldn't be there
        const purchaseButtons = minimizedContent.querySelectorAll('button[onclick*="handleMinimizedPropertyPurchase"], button[onclick*="handleMinimizedDeclinePurchase"]');
        if (purchaseButtons.length > 0) {
            console.log('ðŸ“± Found purchase buttons in minimized content - removing them');
            purchaseButtons.forEach(button => button.remove());
            console.log('ðŸ“± Purchase buttons removed - continuing with dice cleanup');
        }
        
        // Check if dice should remain disabled (e.g., during property purchase decisions)
        const currentPlayer = players[currentPlayerIndex];
        const propertyInfo = getPropertyInfo(currentPlayer?.currentSquare);
        const hasUnpurchasedProperty = propertyInfo && !propertyInfo.state.owner && !propertyInfo.special && !currentPlayer?.isAI;
        const canDevelop = propertyInfo && propertyInfo.state.owner === currentPlayer?.name && !currentPlayer?.isAI && canDevelopProperty(currentPlayer, propertyInfo.square);
        const hasDevelopmentOption = canDevelop && getDevelopmentCost(propertyInfo.square) && currentPlayer?.money >= getDevelopmentCost(propertyInfo.square).cost;
        
        if (hasUnpurchasedProperty || hasDevelopmentOption) {
            // Keep dice disabled during property/development decisions
            console.log('ðŸ“± Keeping dice disabled - player has property/development decision pending');
            if (!diceSection.classList.contains('dice-pulse-red')) {
                diceSection.classList.add('dice-pulse-red');
            }
            diceSection.style.pointerEvents = 'none';
        } else {
            // Clean up any AI-specific classes and ensure proper pulse for human player
            removeAllDicePulseClasses(diceSection);
            const currentPlayer = players[currentPlayerIndex];
            const playerPulseClass = getPlayerDicePulseClassByPlayer(currentPlayer);
            diceSection.classList.add(playerPulseClass);
            console.log(`ðŸ“± Applied player color pulse: ${playerPulseClass}`);
            // Ensure proper pointer events for human player
            diceSection.style.pointerEvents = 'auto';
        }
        console.log('ðŸ“± Dice classes cleaned up:', Array.from(diceSection.classList));
        return;
    }
    
    // If dice is not in minimized content, move it there
    console.log('ðŸ“± Moving dice to minimized content during turn transition');
    
    // Preserve current classes and pointer events
    const currentClasses = Array.from(diceSection.classList);
    const currentPointerEvents = diceSection.style.pointerEvents;
    
    // Store original parent info if not already stored
    if (!diceSection.getAttribute('data-original-parent-id')) {
        diceSection.setAttribute('data-original-parent-id', diceSection.parentElement?.id || 'info-panel-content');
    }
    
    // Apply minimized styling
    const isMobileDevice = window.innerWidth <= 768;
    const diceScale = isMobileDevice ? '0.6' : '0.8';
    const marginTop = isMobileDevice ? '3px' : '5px';
    
    diceSection.style.cssText = `margin-top: ${marginTop}; transform: scale(${diceScale}); transform-origin: left center; position: relative; z-index: 10;`;
    
    // Check if dice should remain disabled (e.g., during property purchase decisions)
    const currentPlayer = players[currentPlayerIndex];
    const propertyInfo = getPropertyInfo(currentPlayer?.currentSquare);
    const hasUnpurchasedProperty = propertyInfo && !propertyInfo.state.owner && !propertyInfo.special && !currentPlayer?.isAI;
    const canDevelop = propertyInfo && propertyInfo.state.owner === currentPlayer?.name && !currentPlayer?.isAI && canDevelopProperty(currentPlayer, propertyInfo.square);
    const hasDevelopmentOption = canDevelop && getDevelopmentCost(propertyInfo.square) && currentPlayer?.money >= getDevelopmentCost(propertyInfo.square).cost;
    
    // Preserve any existing player color classes from enableDiceSection
    const existingClasses = Array.from(diceSection.classList);
    const existingPlayerColorClass = existingClasses.find(cls => cls.startsWith('dice-pulse-player-'));
    
    // Reset to base class first
    diceSection.className = 'dice-section';
    
    if (hasUnpurchasedProperty || hasDevelopmentOption) {
        // Keep dice disabled during property/development decisions
        console.log('ðŸ“± Moving dice but keeping disabled - player has property/development decision pending');
        diceSection.classList.add('dice-pulse-red');
        diceSection.style.pointerEvents = 'none';
    } else {
        // Normal enabled state for human player
        const currentPlayer = players[currentPlayerIndex];
        
        // Use existing player color class if available, otherwise get new one
        let playerPulseClass = existingPlayerColorClass;
        if (!playerPulseClass) {
            playerPulseClass = getPlayerDicePulseClassByPlayer(currentPlayer);
        }
        
        diceSection.classList.add(playerPulseClass);
        diceSection.style.pointerEvents = currentPointerEvents || 'auto';
        console.log(`ðŸ“± Preserved/applied player color pulse: ${playerPulseClass}`);
    }
    
    // Move to minimized content
    minimizedContent.appendChild(diceSection);
    
    console.log('ðŸ“± Dice moved to minimized content with classes:', Array.from(diceSection.classList));
}

// Function to create standard minimized state
function minimizeToStandardState() {
    const infoPanel = document.getElementById('info-panel');
    const infoPanelContent = document.getElementById('info-panel-content');
    const minimizeButton = document.getElementById('minimize-info-panel');
    
    if (!infoPanel || !infoPanelContent || !minimizeButton) {
        console.error('Info panel elements not found for minimizeToStandardState');
        return;
    }
    
    console.log('[minimizeToStandardState] Creating standard minimized state');
    
    // Check for duplicate dice sections and clean them up
    const allDiceSections = document.querySelectorAll('[id="dice-section"]');
    if (allDiceSections.length > 1) {
        console.log(`[minimizeToStandardState] Found ${allDiceSections.length} dice sections - removing duplicates`);
        // Keep only the first one, remove the rest
        for (let i = 1; i < allDiceSections.length; i++) {
            allDiceSections[i].remove();
            console.log(`[minimizeToStandardState] Removed duplicate dice section ${i + 1}`);
        }
    }
    
    // Ensure dice section exists before minimizing
    const ensuredDiceSection = ensureDiceSectionExists();
    if (ensuredDiceSection) {
        console.log('[minimizeToStandardState] Dice section ensured');
    }
    
    // Remove property-decision class but keep minimized
    infoPanel.classList.remove('property-decision');
    infoPanel.classList.add('minimized');
    
    // Hide the main content
    infoPanelContent.style.display = 'none';
    
    // Update button state
    minimizeButton.textContent = '+';
    minimizeButton.title = 'Restore';
    
    // Preserve dice section and turn-info before removing existing minimized content
    let preservedDiceSection = null;
    let preservedTurnInfo = null;
    
    const existingMinimizedContent = document.getElementById('minimized-content');
    if (existingMinimizedContent) {
        // Extract dice section and turn-info before removing content
        preservedDiceSection = existingMinimizedContent.querySelector('#dice-section');
        preservedTurnInfo = existingMinimizedContent.querySelector('#turn-info');
        
        // Temporarily move them to a safe location
        if (preservedDiceSection) {
            document.body.appendChild(preservedDiceSection);
            console.log('ðŸ“± Preserved dice section during minimized content recreation');
        }
        if (preservedTurnInfo) {
            document.body.appendChild(preservedTurnInfo);
            console.log('ðŸ“± Preserved turn-info during minimized content recreation');
        }
        
        existingMinimizedContent.remove();
    }
    
    // Create new minimized content with standard layout
    const minimizedContent = document.createElement('div');
    minimizedContent.id = 'minimized-content';
    
    // Adjust styles for mobile vs desktop
    const isMobileDevice = isMobile || window.innerWidth <= 768;
    const fontSize = isMobileDevice ? '10px' : '14px';
    const padding = isMobileDevice ? '3px 6px' : '5px 10px';
    const gap = isMobileDevice ? '3px' : '5px';
    
    minimizedContent.style.cssText = `
        padding: ${padding};
        color: #fff;
        font-size: ${fontSize};
        display: flex;
        flex-direction: column;
        gap: ${gap};
        height: auto;
        overflow: visible;
        pointer-events: auto;
        position: relative;
        z-index: 1;
    `;
    
    // Get current player info
    const currentPlayer = players[currentPlayerIndex];
    if (currentPlayer) {
        // Player name, funds, and steal cards
        const playerBasics = document.createElement('div');
        const mobileGap = isMobileDevice ? '4px' : '8px';
        playerBasics.style.cssText = `display: flex; align-items: center; justify-content: center; gap: ${mobileGap};`;
        
        // Create player name with star
        const playerNameSpan = document.createElement('span');
        const mobileStarMargin = isMobileDevice ? '2px' : '4px';
        playerNameSpan.style.cssText = `font-weight: bold; color: #90EE90;`;
        playerNameSpan.innerHTML = `
            <span style="color: ${currentPlayer.color || '#fff'}; margin-right: ${mobileStarMargin};">â˜…</span>${currentPlayer.name}
        `;
        
        // Create funds display
        const fundsSpan = document.createElement('span');
        fundsSpan.style.cssText = `color: #90EE90;`;
        fundsSpan.textContent = `Â£${currentPlayer.money}`;
        
        // Add steal cards if player has them
        if (currentPlayer.stealCards && currentPlayer.stealCards > 0) {
            const stealCardsSpan = document.createElement('span');
            stealCardsSpan.style.cssText = `color: #00ff00; font-weight: bold;`;
            stealCardsSpan.innerHTML = `<img src="assets/images/spades.png" style="width: 14px; height: 14px; vertical-align: middle; margin-right: 3px;">${currentPlayer.stealCards}`;
            stealCardsSpan.title = `${currentPlayer.stealCards} steal card${currentPlayer.stealCards > 1 ? 's' : ''}`;
            playerBasics.appendChild(playerNameSpan);
            playerBasics.appendChild(fundsSpan);
            playerBasics.appendChild(stealCardsSpan);
        } else {
            playerBasics.appendChild(playerNameSpan);
            playerBasics.appendChild(fundsSpan);
        }
        minimizedContent.appendChild(playerBasics);
        
        // Token section (if visible)
        const tokenSection = currentPlayer.token ? `
            <div style="display: flex; align-items: center; justify-content: center; gap: 5px;">
                <span style="font-size: 10px;">Token:</span>
                <img src="${currentPlayer.token}" style="width: 16px; height: 16px; border-radius: 50%;">
            </div>
        ` : '';
        
        if (tokenSection) {
            const tokenDiv = document.createElement('div');
            tokenDiv.innerHTML = tokenSection;
            minimizedContent.appendChild(tokenDiv);
        }
        
        // Properties owned (compact format)
        if (currentPlayer.properties && currentPlayer.properties.length > 0) {
            const propertiesDiv = document.createElement('div');
            propertiesDiv.style.cssText = 'font-size: 10px; line-height: 1.2;';
            
            // Group properties by color/type
            const groupedProps = {};
            currentPlayer.properties.forEach(propSquare => {
                const propInfo = getPropertyInfo(propSquare);
                if (propInfo && propInfo.group) {
                    if (!groupedProps[propInfo.group]) {
                        groupedProps[propInfo.group] = [];
                    }
                    groupedProps[propInfo.group].push(propInfo);
                }
            });
            
            const propDisplay = Object.entries(groupedProps).map(([group, props]) => {
                const colorIcon = propertyGroups[group]?.colorIcon || 'â—';
                return props.length > 1 ? `<span style="font-size: 16px;">${colorIcon}${props.length}</span>` : `<span style="font-size: 16px;">${colorIcon}</span>`;
            }).join(' ');
            
            propertiesDiv.innerHTML = `<span style="color: #ccc;">Properties: ${propDisplay}</span>`;
            minimizedContent.appendChild(propertiesDiv);
        }
    }
    
    // Add dice section (use preserved one if available, otherwise find it)
    const standardDiceSection = preservedDiceSection || document.getElementById('dice-section');
    if (standardDiceSection) {
        // Check if dice is already in minimized content to prevent duplicates
        if (standardDiceSection.parentElement === minimizedContent) {
            console.log('[minimizeToStandardState] Dice already in minimized content, skipping duplicate creation');
        } else {
        // Store original parent to restore later
        standardDiceSection.setAttribute('data-original-parent-id', 'dice-content');
        const diceScale = isMobileDevice ? '0.6' : '0.8';
        const marginTop = isMobileDevice ? '3px' : '5px';
        
        // Preserve current pulse classes before applying new styles
        const currentClasses = Array.from(standardDiceSection.classList);
        const hasPulse = currentClasses.some(cls => cls.includes('pulse'));
        const currentPointerEvents = standardDiceSection.style.pointerEvents || 'auto';
        
        // Apply new styles while preserving pulse classes
        standardDiceSection.style.cssText = `margin-top: ${marginTop}; transform: scale(${diceScale}); transform-origin: left center; position: relative; z-index: 10;`;
        
        // Restore the pointer-events value to preserve enableDiceSection() settings
        standardDiceSection.style.pointerEvents = currentPointerEvents;
        
        // Restore pulse classes if they were present, or add default pulse
        if (hasPulse) {
            currentClasses.forEach(cls => {
                if (cls.includes('pulse')) {
                    standardDiceSection.classList.add(cls);
                    console.log(`ðŸ“± Preserved dice pulse class: ${cls}`);
                }
            });
        } else {
            // ALWAYS ensure dice has player color pulse in minimized mode
            const currentPlayer = players[currentPlayerIndex];
            const playerPulseClass = getPlayerDicePulseClassByPlayer(currentPlayer);
            standardDiceSection.classList.add(playerPulseClass);
            console.log(`ðŸ“± Added player color pulse class to ensure visibility in minimized mode: ${playerPulseClass}`);
        }
        
        minimizedContent.appendChild(standardDiceSection);
        
        // Add turn-info right after dice in minimized content
        const turnInfo = document.getElementById('turn-info');
        if (turnInfo) {
            const originalTurnInfoParent = turnInfo.parentElement;
            turnInfo.setAttribute('data-original-parent-id', originalTurnInfoParent?.id || 'info-panel-content');
            minimizedContent.appendChild(turnInfo);
            console.log('ðŸ“± Added turn-info to minimized content in minimizeToStandardState');
        }
        
        // Add property-info-content if it exists and has content
        const propertyInfoContent = document.getElementById('property-info-content');
        if (propertyInfoContent && propertyInfoContent.innerHTML.trim()) {
            const originalPropertyInfoParent = propertyInfoContent.parentElement;
            propertyInfoContent.setAttribute('data-original-parent-id', originalPropertyInfoParent?.id || 'info-panel-content');
            
            // Apply minimized styling to property info
            const originalPropertyStyle = propertyInfoContent.style.cssText;
            propertyInfoContent.setAttribute('data-original-style', originalPropertyStyle);
            propertyInfoContent.style.cssText = 'margin-top: 5px; font-size: 10px; max-height: 150px; overflow-y: auto;';
            
            // Scale down buttons in property info
            const buttons = propertyInfoContent.querySelectorAll('button');
            buttons.forEach(button => {
                if (!button.getAttribute('data-original-style')) {
                    button.setAttribute('data-original-style', button.style.cssText);
                }
                button.style.cssText = 'font-size: 8px !important; padding: 2px 6px !important; min-height: 18px !important; margin: 1px !important;';
            });
            
            minimizedContent.appendChild(propertyInfoContent);
            console.log('ðŸ“± Added property-info-content to minimized content in minimizeToStandardState');
        }
        
        // Re-attach minimized dice handlers
        reattachMinimizedDiceHandlers(standardDiceSection);
        }
    } else {
        // If no dice section found, create one as fallback
        console.log('ðŸ“± No dice section found - creating new one for minimized mode');
        const newDiceSection = document.createElement('div');
        newDiceSection.id = 'dice-section';
        newDiceSection.className = 'dice-section dice-pulse';
        newDiceSection.innerHTML = `
            <div id="die1" class="die">1</div>
            <div id="die2" class="die">1</div>
        `;
        
        const diceScale = isMobileDevice ? '0.6' : '0.8';
        const marginTop = isMobileDevice ? '3px' : '5px';
        newDiceSection.style.cssText = `margin-top: ${marginTop}; transform: scale(${diceScale}); transform-origin: left center; position: relative; z-index: 10;`;
        newDiceSection.style.pointerEvents = 'auto';
        
        minimizedContent.appendChild(newDiceSection);
        console.log('ðŸ“± Created new dice section for minimized mode');
    }
    
    // Add turn info (use preserved one if available, otherwise find it)
    const turnInfo = preservedTurnInfo || document.getElementById('turn-info');
    if (turnInfo) {
        // Check if turn-info is already in minimized content to prevent duplicates
        if (turnInfo.parentElement !== minimizedContent) {
            // Store original parent to restore later
            turnInfo.setAttribute('data-original-parent-id', 'info-panel-content');
            
            // Ensure turn-info is visible and properly styled in minimized mode
            turnInfo.style.display = 'block';
            turnInfo.style.visibility = 'visible';
            turnInfo.style.opacity = '1';
            turnInfo.style.fontSize = isMobileDevice ? '10px' : '12px';
            turnInfo.style.margin = '3px 0';
            turnInfo.style.textAlign = 'center';
            
            minimizedContent.appendChild(turnInfo);
            console.log('ðŸ“± Added turn-info to minimized content with enhanced styling');
        } else {
            console.log('ðŸ“± Turn-info already in minimized content, skipping duplicate add');
        }
    }
    
    // Append the minimized content to the info panel
    infoPanel.appendChild(minimizedContent);
    
    console.log('[minimizeToStandardState] Standard minimized state created successfully');
}

// Function to re-attach minimized dice handlers
function reattachMinimizedDiceHandlers(diceSection) {
    if (!diceSection) return;
    
    console.log('ðŸ“± Re-attaching minimized dice handlers');
    
    // Create the minimized dice click handler using the unified system
    let lastClickTime = 0;
    const minimizedDiceClickHandler = async (e) => {
        const now = Date.now();
        
        // Debounce clicks to prevent multiple rapid clicks
        if (now - lastClickTime < 500) {
            console.log('ðŸ“± Minimized dice click ignored (debounced)');
            return;
        }
        lastClickTime = now;
        
        console.log('ðŸ“± MINIMIZED DICE CLICKED!', e.target.tagName, e.target.id, e.target.className);
        console.log('ðŸ“± Click coordinates:', e.clientX, e.clientY);
        console.log('ðŸ“± Target element bounds:', e.target.getBoundingClientRect());
        e.preventDefault();
        e.stopPropagation(); // Prevent triggering main handler
        
        // Use unified dice click handler
        await handleDiceClick('minimized');
    };
    
    // Add the minimized click handler (don't clone, just add to existing)
    diceSection.addEventListener('click', minimizedDiceClickHandler, { capture: true });
    console.log('ðŸ“± Added minimized dice click handler to dice section:', diceSection.id);
    
    // Set cursor style for individual die elements but don't add separate handlers
    const die1 = diceSection.querySelector('#die1');
    const die2 = diceSection.querySelector('#die2');
    
    if (die1) {
        die1.style.cursor = 'pointer';
    }
    if (die2) {
        die2.style.cursor = 'pointer';
    }
    
    console.log('ðŸ“± Re-attached single click handler to dice section');
    
    console.log('ðŸ“± Minimized dice handlers successfully re-attached');
}

// Wrapper functions for minimized mode property decisions
// Global functions for minimized property decision handling
window.handleMinimizedPropertyPurchase = function(square, playerIndex) {
    console.log('ðŸ“± Handling minimized property purchase');
    // Call the original purchase function
    handlePropertyPurchase(square, playerIndex);
    
    // Check if player rolled doubles and should continue rolling
    const shouldContinueRolling = lastRollWasDoubles;
    console.log(`ðŸ“± After property purchase - should continue rolling: ${shouldContinueRolling} (rolled doubles: ${lastRollWasDoubles})`);
    
    if (shouldContinueRolling) {
        // If player rolled doubles, show dice for continued play
        setTimeout(() => {
            showDiceAfterPropertyDecision();
        }, 100);
    } else {
        // If no doubles, restore normal minimized content and end turn
        setTimeout(() => {
            console.log('ðŸ“± No doubles after property purchase - reverting to standard minimized state');
            minimizeToStandardState();
            // End the turn since no doubles were rolled
            setTimeout(() => {
                console.log('ðŸ“± No doubles after property purchase - ending turn');
                nextTurn();
            }, 500);
        }, 100);
        return;
    }
    
    // Restore minimized content after purchase with a slightly longer delay to ensure dice is properly restored
    setTimeout(() => {
        console.log('ðŸ“± Property purchase completed - reverting to standard minimized state');
        minimizeToStandardState();
        // Check if still in minimized mode and preserve minimized handlers
        setTimeout(() => {
            const diceSection = document.getElementById('dice-section');
            const infoPanel = document.getElementById('info-panel');
            const isStillMinimized = infoPanel && infoPanel.classList.contains('minimized');
            
            if (diceSection) {
                if (isStillMinimized) {
                    console.log('ðŸ“± Still in minimized mode after purchase - preserving minimized dice handlers');
                    // Don't call enableDiceSection, just ensure basic clickability
                    diceSection.style.pointerEvents = '';
                    diceSection.removeAttribute('disabled');
                    diceSection.classList.remove('dice-disabled');
                    
                    // Ensure the minimized click handler is still attached
                    const minimizedContent = document.getElementById('minimized-content');
                    if (minimizedContent && diceSection.parentElement === minimizedContent) {
                        console.log('ðŸ“± Dice is in minimized content - re-attaching minimized handlers');
                        // Re-attach minimized handlers if they were lost during restoration
                        reattachMinimizedDiceHandlers(diceSection);
                    }
                } else {
                    // Force clear any pointer event blocking
                    diceSection.style.pointerEvents = '';
                    diceSection.removeAttribute('disabled');
                    
                    // Remove any blocking classes
                    diceSection.classList.remove('dice-disabled', 'dice-pulse-red');
                    
                    // Aggressively re-enable the dice
                    enableDiceSection();
                    
                    // Additional safety check
                    setTimeout(() => {
                        if (diceSection.style.pointerEvents === 'none') {
                            console.log('ðŸ“± Dice still disabled, forcing re-enable');
                            diceSection.style.pointerEvents = '';
                            enableDiceSection();
                        }
                    }, 100);
                }
                
                console.log('ðŸ“± Dice section restored after minimized purchase', {
                    isMinimized: isStillMinimized,
                    pointerEvents: diceSection.style.pointerEvents,
                    classList: Array.from(diceSection.classList)
                });
            }
        }, 50);
    }, 150);
};

window.handleMinimizedDeclinePurchase = function(square, playerIndex) {
    console.log('ðŸ“± Handling minimized property decline');
    // Call the original decline function - it will handle turn advancement
    handleDeclinePurchase(square, playerIndex);
    
    // Check if player rolled doubles and should continue rolling
    const shouldContinueRolling = lastRollWasDoubles;
    console.log(`ðŸ“± After property decline - should continue rolling: ${shouldContinueRolling} (rolled doubles: ${lastRollWasDoubles})`);
    
    if (shouldContinueRolling) {
        // If player rolled doubles, show dice for continued play
        setTimeout(() => {
            showDiceAfterPropertyDecision();
        }, 100);
    } else {
        // If no doubles, just restore normal minimized content
        // The main handleDeclinePurchase function will handle turn advancement
        setTimeout(() => {
            const infoPanel = document.getElementById('info-panel');
            const isStillMinimized = infoPanel && infoPanel.classList.contains('minimized');
            
            if (isStillMinimized) {
                minimizeToStandardState();
            }
        }, 100);
        return;
    }
    
    // After decline, revert to standard minimized state instead of trying to restore content
    setTimeout(() => {
        const infoPanel = document.getElementById('info-panel');
        const isStillMinimized = infoPanel && infoPanel.classList.contains('minimized');
        
        if (isStillMinimized) {
            console.log('ðŸ“± Reverting to standard minimized state after property decline');
            // Ensure dice section exists before reverting
            ensureDiceSectionExists();
            // Revert to standard minimized state without purchase panel
            minimizeToStandardState();
            
            // Ensure dice is properly enabled after reverting to standard state
            setTimeout(() => {
                const diceSection = document.getElementById('dice-section');
                if (diceSection) {
                    console.log('ðŸ“± Ensuring dice section is enabled after reverting to standard minimized state');
                    diceSection.style.pointerEvents = '';
                    diceSection.classList.remove('dice-disabled');
                    enableDiceSection();
                } else {
                    console.log('ðŸ“± Dice section missing after revert - will be recreated');
                }
            }, 100);
        } else {
            // If not minimized anymore, just ensure dice is enabled
            const diceSection = document.getElementById('dice-section');
            if (diceSection) {
                // Force clear any pointer event blocking
                diceSection.style.pointerEvents = '';
                diceSection.removeAttribute('disabled');
                
                // Remove any blocking classes
                diceSection.classList.remove('dice-disabled', 'dice-pulse-red');
                
                // Aggressively re-enable the dice
                enableDiceSection();
                
                // Additional safety check
                setTimeout(() => {
                    if (diceSection.style.pointerEvents === 'none') {
                        console.log('ðŸ“± Dice still disabled, forcing re-enable');
                        diceSection.style.pointerEvents = '';
                        enableDiceSection();
                    }
                }, 200);
            }
        }
    }, 150);
};

// Global function for minimized development decline
window.handleMinimizedDeclineDevelopment = function(square, playerIndex) {
    console.log('ðŸ“± Handling minimized development decline');
    // Call the original decline function
    handleDeclineDevelopment(square, playerIndex);
    // Restore minimized content after decline with a slightly longer delay to ensure dice is properly restored
    setTimeout(() => {
        console.log('ðŸ“± Development decline completed - reverting to standard minimized state');
        minimizeToStandardState();
        // Check if still in minimized mode and preserve minimized handlers
        setTimeout(() => {
            const diceSection = document.getElementById('dice-section');
            const infoPanel = document.getElementById('info-panel');
            const isStillMinimized = infoPanel && infoPanel.classList.contains('minimized');
            
            if (diceSection) {
                if (isStillMinimized) {
                    console.log('ðŸ“± Still in minimized mode after development decline - preserving minimized dice handlers');
                    // Don't call enableDiceSection, just ensure basic clickability
                    diceSection.style.pointerEvents = '';
                    diceSection.removeAttribute('disabled');
                    diceSection.classList.remove('dice-disabled');
                    
                    // Ensure the minimized click handler is still attached
                    const minimizedContent = document.getElementById('minimized-content');
                    if (minimizedContent && diceSection.parentElement === minimizedContent) {
                        console.log('ðŸ“± Dice is in minimized content - re-attaching minimized handlers');
                        // Re-attach minimized handlers if they were lost during restoration
                        reattachMinimizedDiceHandlers(diceSection);
                    }
                    
                    // Re-instate dice pulsing after auto-decline in minimized mode
                    console.log('ðŸ“± Re-instating dice pulsing after auto-decline in minimized mode');
                    updateDicePulsing();
                    
                    // Ensure dice section is properly enabled after auto-decline
                    setTimeout(() => {
                        const diceSection = document.getElementById('dice-section');
                        if (diceSection) {
                            console.log('ðŸ“± Ensuring dice section is enabled after auto-decline');
                            diceSection.style.pointerEvents = '';
                            diceSection.classList.remove('dice-disabled');
                            enableDiceSection();
                        } else {
                            console.log('ðŸ“± Dice section missing after auto-decline - will be recreated by restoreMinimizedContent');
                        }
                    }, 200);
                } else {
                    // Force clear any pointer event blocking
                    diceSection.style.pointerEvents = '';
                    diceSection.removeAttribute('disabled');
                    
                    // Remove any blocking classes
                    diceSection.classList.remove('dice-disabled', 'dice-pulse-red');
                    
                    // Aggressively re-enable the dice
                    enableDiceSection();
                    
                    // Additional safety check
                    setTimeout(() => {
                        if (diceSection.style.pointerEvents === 'none') {
                            console.log('ðŸ“± Dice still disabled, forcing re-enable');
                            diceSection.style.pointerEvents = '';
                            enableDiceSection();
                        }
                    }, 100);
                }
                
                console.log('ðŸ“± Dice section restored after minimized development decline', {
                    isMinimized: isStillMinimized,
                    pointerEvents: diceSection.style.pointerEvents,
                    classList: Array.from(diceSection.classList)
                });
            }
        }, 50);
    }, 150);
};

// Advisory panel functions
// Global variable to track advisory timer
let advisoryTimer = null;
let isYingyangDisplaying = false; // Flag to protect yingyang quotes

function showAdvisory(message, type = 'info') {
    const advisoryContent = document.getElementById('advisory-content');
    const advisoryTitle = document.getElementById('advisory-title');
    if (!advisoryContent || !advisoryTitle) return;

    // Protect yingyang quotes from being overridden
    if (isYingyangDisplaying && type !== 'yingyang') {
        console.log(`[showAdvisory] Blocking ${type} message while yingyang quote is displaying:`, message);
        return;
    }

    // Clear any existing timer
    if (advisoryTimer) {
        clearTimeout(advisoryTimer);
        advisoryTimer = null;
    }

    // Set title based on type
    let title = 'Game Advisory';
    let titleColor = '#ffd700'; // Default gold
    let bgColor = 'rgba(255, 255, 255, 0.1)'; // Default
    let displayDuration = 0; // 0 means no auto-clear

    switch(type) {
        case 'payment':
            title = 'Payment Made';
            titleColor = '#ff4444'; // Red for payments
            bgColor = 'rgba(255, 68, 68, 0.1)';
            displayDuration = 1500; // 1.5 seconds for Pass Go messages
            break;
        case 'gain':
            title = 'Money Gained';
            titleColor = '#44ff44'; // Green for gains
            bgColor = 'rgba(68, 255, 68, 0.1)';
            break;
        case 'turn':
            title = 'Turn Update';
            titleColor = '#4444ff'; // Blue for turns
            bgColor = 'rgba(68, 68, 255, 0.1)';
            break;
        case 'yingyang':
            title = 'Yingyang Wisdom';
            titleColor = '#ff00ff'; // Magenta for yingyang
            bgColor = 'rgba(255, 0, 255, 0.1)';
            displayDuration = 1500; // 1.5 seconds
            isYingyangDisplaying = true; // Set protection flag
            console.log('[showAdvisory] Displaying yingyang quote for 1.5 seconds with protection');
            break;
        case 'teleport':
            title = 'Teleport';
            titleColor = '#ff0000'; // Red for teleportation
            bgColor = 'rgba(255, 0, 0, 0.15)';
            displayDuration = 3000; // 3 seconds display
            break;
        case 'tax':
            title = 'Tax Penalty';
            titleColor = '#ff6600'; // Orange for tax
            bgColor = 'rgba(255, 102, 0, 0.3)';
            displayDuration = 2500; // 2.5 seconds display
            break;
        case 'lightning':
            title = 'Lightning Strike';
            titleColor = '#ffff00'; // Yellow for lightning
            bgColor = 'rgba(255, 255, 0, 0.15)';
            displayDuration = 10000; // 10 seconds for strike outcomes on owned properties
            break;
        case 'payment':
            title = 'Payment';
            titleColor = '#00ff00'; // Green for payments
            bgColor = 'rgba(0, 255, 0, 0.1)';
            displayDuration = 1500; // 1.5 seconds display
            break;
    }

    // Update the advisory panel (desktop)
    if (advisoryTitle) {
        advisoryTitle.textContent = title;
        advisoryTitle.style.color = titleColor;
        advisoryTitle.style.textAlign = 'center';
        advisoryTitle.style.fontSize = '12px';
        advisoryTitle.style.fontFamily = "'Courier New', 'Lucida Console', 'Monaco', 'Consolas', monospace";
        advisoryTitle.style.fontWeight = 'bold';
        advisoryTitle.style.textShadow = `0 0 6px ${titleColor}`;
        advisoryTitle.style.letterSpacing = '1px';
    }
    if (advisoryContent) {
        advisoryContent.innerHTML = message;
        advisoryContent.style.textAlign = 'center';
        advisoryContent.style.fontSize = '11px';
        advisoryContent.style.color = '#fff';
        advisoryContent.style.fontFamily = "'Courier New', 'Lucida Console', 'Monaco', 'Consolas', monospace";
        advisoryContent.style.lineHeight = '1.4';
    }
    
    // Also update mobile advisory panel if it exists
    const mobileAdvisoryTitle = document.getElementById('mobile-advisory-title');
    const mobileAdvisoryContent = document.getElementById('mobile-advisory-content');
    
    if (mobileAdvisoryTitle) {
        mobileAdvisoryTitle.textContent = title;
        mobileAdvisoryTitle.style.color = titleColor;
        mobileAdvisoryTitle.style.textShadow = `0 0 4px ${titleColor}`;
    }
    if (mobileAdvisoryContent) {
        mobileAdvisoryContent.innerHTML = message;
        mobileAdvisoryContent.style.color = '#fff';
    }
    
    const advisoryPanel = document.getElementById('advisory-panel');
    if (advisoryPanel) {
        advisoryPanel.style.background = bgColor;
        
        // Add click handler for manual dismissal of yingyang quotes
        if (type === 'yingyang') {
            advisoryPanel.style.cursor = 'pointer';
            advisoryPanel.title = 'Click to dismiss quote';
            
            // Remove any existing click listeners to avoid duplicates
            advisoryPanel.onclick = null;
            
            // Add new click listener for manual dismissal
            advisoryPanel.onclick = () => {
                if (isYingyangDisplaying) {
                    // Clear the timer
                    if (advisoryTimer) {
                        clearTimeout(advisoryTimer);
                        advisoryTimer = null;
                    }
                    
                    // Clear the display
                    if (advisoryContent) {
                        advisoryContent.innerHTML = '';
                    }
                    if (advisoryTitle) {
                        advisoryTitle.textContent = 'Game Advisory';
                        advisoryTitle.style.color = '#ffd700';
                        advisoryTitle.style.textShadow = '0 0 6px #ffd700';
                    }
                    advisoryPanel.style.background = 'rgba(255, 255, 255, 0.1)';
                    advisoryPanel.style.cursor = '';
                    advisoryPanel.title = '';
                    advisoryPanel.onclick = null;
                    
                    // Clear yingyang protection flag
                    isYingyangDisplaying = false;
                    console.log('[showAdvisory] Yingyang quote manually dismissed by click');
                }
            };
        } else {
            // Reset cursor and click handler for non-yingyang messages
            advisoryPanel.style.cursor = '';
            advisoryPanel.title = '';
            advisoryPanel.onclick = null;
        }
    }

    // Set auto-clear timer for yingyang quotes
    if (displayDuration > 0) {
        advisoryTimer = setTimeout(() => {
            if (advisoryContent) {
                advisoryContent.innerHTML = '';
            }
            if (advisoryTitle) {
                advisoryTitle.textContent = 'Game Advisory';
                advisoryTitle.style.color = '#ffd700';
                advisoryTitle.style.textShadow = '0 0 6px #ffd700';
            }
            if (advisoryPanel) {
                advisoryPanel.style.background = 'rgba(255, 255, 255, 0.1)';
            }
            advisoryTimer = null;
            
            // Clear yingyang protection flag when timer expires
            if (isYingyangDisplaying) {
                isYingyangDisplaying = false;
                console.log('[showAdvisory] Yingyang quote display completed, protection cleared');
            }
        }, displayDuration);
    }
}

// Function to calculate rent
function calculateRent(propertyInfo) {
    const state = propertyInfo.state;
    let baseRent;
    let rentMultiplier = 1;
    let rentBreakdown = [];

    if (propertyInfo.group === 'cave') {
        // Special fixed rent for cave property
        baseRent = 500;
        rentBreakdown.push(`Cave rent: Fixed Â£500`);
    } else if (propertyInfo.group === 'demon') {
        // Special rent: number of demon properties owned by the owner Ã— Â£200
        const owner = players.find(p => p.name.toLowerCase() === (state.owner || '').toLowerCase());
        const numOwned = owner ? owner.properties.filter(sq => propertyGroups.demon.positions.includes(sq)).length : 0;
        baseRent = numOwned * 200;
        rentBreakdown.push(`Demon properties owned: ${numOwned} Ã— Â£200 = Â£${baseRent}`);
    } else if (state.hasCrypt) {
        // Crypt rent is 5x the property cost (no other modifiers apply)
        baseRent = propertyInfo.cost * 5;
        rentBreakdown.push(`Crypt rent: 5 Ã— property cost (Â£${propertyInfo.cost}) = Â£${baseRent}`);
        rentMultiplier = 1; // No additional multipliers for crypts
    } else if (state.graveyards > 0) {
        // New graveyard rent system: 1.5x property cost per graveyard
        // 1 graveyard = 1.5x, 2 graveyards = 3x, 3 graveyards = 4.5x, 4 graveyards = 6x
        const graveyardMultiplier = 1.5 * state.graveyards;
        baseRent = propertyInfo.cost * graveyardMultiplier;
        rentBreakdown.push(`Graveyard rent: ${state.graveyards} graveyard${state.graveyards > 1 ? 's' : ''} Ã— 1.5 Ã— property cost (Â£${propertyInfo.cost}) = ${graveyardMultiplier}x = Â£${baseRent}`);
        rentMultiplier = 1; // No additional multipliers for graveyards
    } else {
        // Base property rent is 1.5x the property cost
        baseRent = propertyInfo.cost * 1.5;
        rentBreakdown.push(`Base rent: 1.5 Ã— property cost (Â£${propertyInfo.cost}) = Â£${baseRent}`);
        rentMultiplier = 1; // No additional multipliers needed
    }
    const finalRent = Math.round(baseRent * rentMultiplier);
    return {
        amount: finalRent,
        breakdown: rentBreakdown,
        multiplier: rentMultiplier
    };
}

// Modified moveToken function
async function moveToken(player, spaces, isReverse = false) {
    const moveInterval = 200;
    let passedGo = false;
    
    // Add safety timeout for movement to prevent hanging
    const moveStartTime = Date.now();
    let moveCompleted = false;
    
    const moveTimeout = setTimeout(() => {
        if (!moveCompleted) {
            console.error(`ðŸš¨ moveToken timeout after ${Date.now() - moveStartTime}ms for ${player.name} - forcing completion`);
            isPlayerMoving = false;
            // Don't call nextTurn here as that should be handled by the calling function
        }
    }, 20000); // 20 second timeout for movement
    
    // Clear manually declined properties for this player when they start moving
    // But keep auto-declined properties to prevent re-asking on future turns
    if (playerDeclinedProperties.has(player.name)) {
        const declinedSet = playerDeclinedProperties.get(player.name);
        const manuallyDeclined = Array.from(declinedSet).filter(prop => !prop.startsWith('auto_'));
        const autoDeclined = Array.from(declinedSet).filter(prop => prop.startsWith('auto_'));
        
        // Clear manually declined properties
        declinedSet.clear();
        autoDeclined.forEach(prop => declinedSet.add(prop));
        
        console.log(`[moveToken] Cleared ${manuallyDeclined.length} manually declined properties for ${player.name}, kept ${autoDeclined.length} auto-declined properties`);
    }
    
    // Set movement flag to prevent property buttons during movement
    isPlayerMoving = true;

    try {
        // Get current path configuration
        const pathConfig = paths[player.currentPathKey];
        if (!pathConfig) {
            console.error('Invalid path key:', player.currentPathKey);
            moveCompleted = true;
            clearTimeout(moveTimeout);
            isPlayerMoving = false;
            return;
        }

        let currentPath = pathConfig.array;

    for (let step = 0; step < spaces; step++) {
        // Play movement sound
        await playPigSound();

        // Calculate next position
        let nextIndex;
        if (isReverse) {
            nextIndex = (player.currentIndexOnPath - 1 + currentPath.length) % currentPath.length;
        } else {
            nextIndex = (player.currentIndexOnPath + 1) % currentPath.length;
        }
        
        // Handle special case where player is entering a new path (currentIndexOnPath = -1)
        if (player.currentIndexOnPath === -1 && !isReverse) {
            nextIndex = 0; // Start at beginning of new path
        }

        // Get the next square name
        const nextSquare = currentPath[nextIndex];
        const nextPos = positionsMap.get(nextSquare);

        if (!nextPos) {
            console.error('Position not found for square:', nextSquare);
            moveCompleted = true;
            clearTimeout(moveTimeout);
            isPlayerMoving = false;
            return;
        }

        // Update player position
        player.currentIndexOnPath = nextIndex;
        player.currentSquare = nextSquare;
        player.x = nextPos.x;
        player.y = nextPos.y;
        
        console.log(`[moveToken] Step ${step + 1}/${spaces}: ${player.name} moved to ${nextSquare} at (${nextPos.x}, ${nextPos.y})`);

        // Check for snake path money/steal card/lightning bolt collection
        if (snakePathMoney[nextSquare] && !snakePathMoney[nextSquare].collected) {
            snakePathMoney[nextSquare].collected = true;
            
            if (snakePathMoney[nextSquare].isStealCard) {
                // Collect steal card
                console.log(`[moveToken] ${player.name} collected a STEAL CARD from ${nextSquare}!`);
                player.stealCards = (player.stealCards || 0) + 1;
                
                // Show steal card collection message
                showAdvisory(`
                    <div style="background: linear-gradient(135deg, #ffd700, #ffcc00); padding: 15px; border-radius: 10px; border: 3px solid #ff8800; margin: 10px 0; box-shadow: 0 4px 8px rgba(0,0,0,0.3);">
                        <div style="font-family: 'Arial Black', sans-serif; font-size: 24px; font-weight: bold; color: #ffffff; text-align: center; margin: 10px 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">
                            <img src="assets/images/spades.png" style="width: 24px; height: 24px; vertical-align: middle;"> STEAL CARD FOUND! <img src="assets/images/spades.png" style="width: 24px; height: 24px; vertical-align: middle;">
                        </div>
                        <div style="font-family: 'Courier New', monospace; font-size: 18px; font-weight: bold; color: #cc6600; text-align: center; margin: 8px 0;">
                            ${player.name} found a STEAL CARD on ${nextSquare.toUpperCase()}!
                        </div>
                        <div style="font-size: 14px; color: #ffffff; text-align: center; margin-top: 8px;">
                            Total steal cards: ${player.stealCards}
                        </div>
                    </div>
                `, 'turn');
                
                // Play steal award sound
                await playStealAwardSound();
            } else if (snakePathMoney[nextSquare].isLightningBolt) {
                // Collect lightning bolt
                console.log(`[moveToken] ${player.name} collected a LIGHTNING BOLT from ${nextSquare}!`);
                player.lightningBolts = (player.lightningBolts || 0) + 1;
                
                showAdvisory(`
                    <div style="background: linear-gradient(135deg, #ffff00, #ffee58); padding: 15px; border-radius: 10px; border: 3px solid #ffeb3b; margin: 10px 0; box-shadow: 0 4px 8px rgba(0,0,0,0.3);">
                        <div style="font-family: 'Arial Black', sans-serif; font-size: 24px; font-weight: bold; color: #000; text-align: center; margin: 10px 0; text-shadow: 1px 1px 2px rgba(255,255,255,0.6);">
                            âš¡ LIGHTNING BOLT ACQUIRED! âš¡
                        </div>
                        <div style="font-family: 'Courier New', monospace; font-size: 18px; font-weight: bold; color: #8d6e63; text-align: center; margin: 8px 0;">
                            ${player.name} found a bolt on ${nextSquare.toUpperCase()}!
                        </div>
                        <div style="font-size: 14px; color: #000; text-align: center; margin-top: 8px;">
                            Total bolts: ${player.lightningBolts}
                        </div>
                    </div>
                `, 'turn');
                
                // Play lightning sound
                playStrikeSound();
                
                // Update bottom player display to show new lightning bolt count
                if (typeof updateBottomPlayerDisplay === 'function') {
                    updateBottomPlayerDisplay();
                }
            } else {
                // Collect money as usual
                console.log(`[moveToken] ${player.name} collected Â£${snakePathMoney[nextSquare].amount} from ${nextSquare}!`);
                player.money += snakePathMoney[nextSquare].amount;
                // In multiplayer, immediately sync player's money and collected flag to Firebase
                if (isMultiplayerGame) {
                    try {
                        const pIdx = players.findIndex(p => p.name === player.name);
                        if (pIdx !== -1) {
                            updatePlayerData(pIdx, { money: player.money }).catch(() => {});
                        }
                        const updates = {};
                        updates[`snakePathMoney.${nextSquare}.collected`] = true;
                        updateGameState(updates).catch(() => {});
                    } catch (e) {
                        console.warn('Snake money immediate sync failed (will be covered by full sync):', e?.message || e);
                    }
                }
                
                // Show money collection message
                showAdvisory(`
                    <div style="background: linear-gradient(135deg, #00ff00, #00cc00); padding: 15px; border-radius: 10px; border: 3px solid #008000; margin: 10px 0; box-shadow: 0 4px 8px rgba(0,0,0,0.3);">
                        <div style="font-family: 'Arial Black', sans-serif; font-size: 24px; font-weight: bold; color: #ffffff; text-align: center; margin: 10px 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">
                            ðŸ’° MONEY COLLECTED! ðŸ’°
                        </div>
                        <div style="font-family: 'Courier New', monospace; font-size: 18px; font-weight: bold; color: #006600; text-align: center; margin: 8px 0;">
                            ${player.name} found Â£${snakePathMoney[nextSquare].amount} on ${nextSquare.toUpperCase()}!
                        </div>
                        <div style="font-size: 14px; color: #ffffff; text-align: center; margin-top: 8px;">
                            New balance: Â£${player.money}
                        </div>
                    </div>
                `, 'payment');
                
                // Play money collection sound
                await playGongSound();
            }
            
            // Sync snake path money collection to Firebase in multiplayer games (redundant full sync)
            if (isMultiplayerGame) {
                console.log(`[moveToken] Syncing snake path money collection (${nextSquare}) to Firebase...`);
                syncGameStateToFirebase();
            }
        }

        // Check if passed GO
        if (!isReverse && player.currentPathKey === "gamePath" && nextSquare === 'go') {
            passedGo = true;
        }

        // Check for path exit if on special path and reached the end
        if (player.currentPathKey !== 'gamePath' && player.currentIndexOnPath >= currentPath.length - 1) {
            console.log(`[moveToken] Player ${player.name} reached end of ${player.currentPathKey} during movement`);
            
            // Calculate remaining steps after exit
            const remainingSteps = spaces - (step + 1);
            console.log(`[moveToken] ${remainingSteps} steps remaining after path exit`);
            
            // Exit to main path
            await checkForPathExit(player);
            
            // If there are remaining steps, continue movement on main path
            if (remainingSteps > 0) {
                console.log(`[moveToken] Continuing movement on main path for ${remainingSteps} more steps`);
                
                // Update currentPath to main game path for remaining movement
                currentPath = paths.gamePath.array;
                
                // Continue the loop with remaining steps
                // The loop will continue with the current step count and process remaining steps
                spaces = step + 1 + remainingSteps; // Adjust total spaces to account for remaining movement
                
                // Brief pause to show the path exit before continuing
                await new Promise(resolve => setTimeout(resolve, 500));
            } else {
                // No remaining steps, exit the movement loop
                break;
            }
        }

        // Update game frame for each step
        await updateGameFrame();
        
        // Sync position to Firebase after each movement step in multiplayer mode
        if (isMultiplayerGame) {
            const playerIndex = players.findIndex(p => p.name === player.name);
            if (playerIndex !== -1) {
                updatePlayerData(playerIndex, {
                    currentSquare: player.currentSquare,
                    currentPathKey: player.currentPathKey,
                    currentIndexOnPath: player.currentIndexOnPath,
                    x: player.x,
                    y: player.y,
                    isMoving: true, // Flag to indicate player is currently moving
                    movementStep: step + 1, // Current step in movement sequence
                    totalMovementSteps: spaces, // Total steps for this movement
                    movementTimestamp: Date.now() // Timestamp for this movement step
                }).catch(error => console.error('Error updating player position during movement:', error));
            }
        }
        
        await new Promise(resolve => setTimeout(resolve, moveInterval));
    }

    // Handle passing GO
    if (passedGo) {
        player.money += 500;
        player.goPassCount = (player.goPassCount || 0) + 1;
        
        await playGongSound();
        showHandEffect(); // Show hand image at Go position
        showBonusFlash(); // Show "BONUS!" flash message
        
        // Check if player gets a steal card (every 4th pass)
        if (player.goPassCount % 4 === 0) {
            player.stealCards = (player.stealCards || 0) + 1;
            
            // Play steal award sound
            playStealAwardSound();
            
            showAdvisory(`
                <div style="background: linear-gradient(135deg, #ffd700, #ffed4a); padding: 7.5px; border-radius: 5px; border: 1.5px solid #ffa500; margin: 5px 0; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                    <div style="font-family: 'Courier New', monospace; font-size: 9px; font-weight: bold; color: #cc8400; text-align: center; margin-bottom: 4px;">
                        ðŸ† PASSED GO! ðŸ†
                    </div>
                    <div style="font-family: 'Arial Black', sans-serif; font-size: 12px; font-weight: bold; color: #006600; text-align: center; margin: 5px 0; text-shadow: 1px 1px 2px rgba(0,0,0,0.3);">
                        +Â£500 COLLECTED!
                    </div>
                    <div style="font-family: 'Courier New', monospace; font-size: 8px; font-weight: bold; color: #cc0000; text-align: center; margin-top: 4px;">
                        ${player.goPassCount}${getOrdinalSuffix(player.goPassCount)} time passing GO
                    </div>
                    <div style="background: rgba(255, 0, 0, 0.2); padding: 5px; border-radius: 3px; border: 1px solid #ff0000; margin-top: 5px;">
                        <div style="font-family: 'Courier New', monospace; font-size: 8px; font-weight: bold; color: #ff0000; text-align: center;">
                            âœ¨ BONUS: STEAL CARD EARNED! âœ¨
                        </div>
                        <div style="font-size: 6px; color: #ffffff; text-align: center; margin-top: 2.5px;">
                            Total steal cards: ${player.stealCards} | Double-click any property to steal it!
                        </div>
                    </div>
                </div>
            `, 'payment');
            console.log(`[moveToken] ${player.name} passed Go ${player.goPassCount} times - collected Â£500, earned steal card (total: ${player.stealCards})`);
        } else {
            const remaining = 4 - (player.goPassCount % 4);
            showAdvisory(`
                <div style="background: linear-gradient(135deg, #ffd700, #ffed4a); padding: 7.5px; border-radius: 5px; border: 1.5px solid #ffa500; margin: 5px 0; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                    <div style="font-family: 'Courier New', monospace; font-size: 9px; font-weight: bold; color: #cc8400; text-align: center; margin-bottom: 4px;">
                        ðŸ† PASSED GO! ðŸ†
                    </div>
                    <div style="font-family: 'Arial Black', sans-serif; font-size: 12px; font-weight: bold; color: #006600; text-align: center; margin: 5px 0; text-shadow: 1px 1px 2px rgba(0,0,0,0.3);">
                        +Â£500 COLLECTED!
                    </div>
                    <div style="font-family: 'Courier New', monospace; font-size: 8px; font-weight: bold; color: #cc0000; text-align: center; margin-top: 4px;">
                        ${player.goPassCount}${getOrdinalSuffix(player.goPassCount)} time passing GO
                    </div>
                    <div style="font-size: 7px; color: #666666; text-align: center; margin-top: 4px;">
                        ${remaining} more passes for a steal card
                    </div>
                </div>
            `, 'payment');
            console.log(`[moveToken] ${player.name} passed Go ${player.goPassCount} times - collected Â£500, ${remaining} more passes needed for steal card`);
        }
        
        updateInfoPanel(); // Now safe to call - isPlayerMoving flag prevents wrong buttons
    }

    // Check for teleportation triggers after movement is complete
    await checkForTeleportation(player);
    
    // Check for gojail landing and steal card award
    const gojailProcessed = await checkGojailLanding(player);
    
    // Check for steal card bonus on other positions when gojail is glowing
    if (!gojailProcessed) {
        await checkStealCardBonusPositions(player);
    }
    

    
    // If gojail was processed, the turn has ended - return early
    if (gojailProcessed) {
        // Clear movement flag - movement is complete
        isPlayerMoving = false;
        
        // Mark movement as completed and clear timeout
        moveCompleted = true;
        clearTimeout(moveTimeout);
        
        return true; // Indicates turn was ended early
    }

    // Trigger yingyang quote if landed on the yingyang square
    if (player.currentSquare === 'yingyang') {
        console.log(`[moveToken] ${player.name} landed on yingyang - triggering quote`);
        await handleYingyangLanding(player);
    }

    // Trigger scream sound if landed on L7
    if (player.currentSquare === 'l7') {
        console.log(`[moveToken] ${player.name} landed on L7 - playing scream sound`);
        await playScreamSound();
        showAdvisory(`${player.name} landed on the cursed L7 position!`, 'turn');
    }

    // Trigger boy sound if landed on R8
    if (player.currentSquare === 'r8') {
        console.log(`[moveToken] ${player.name} landed on R8 - playing boy sound`);
        await playBoySound();
        showAdvisory(`${player.name} landed on R8!`, 'turn');
    }

    // Final update
    await updateGameFrame();
    
    // Sync position to Firebase if in multiplayer mode
    if (isMultiplayerGame) {
        const playerIndex = players.findIndex(p => p.name === player.name);
        if (playerIndex !== -1) {
            updatePlayerData(playerIndex, {
                currentSquare: player.currentSquare,
                currentPathKey: player.currentPathKey,
                currentIndexOnPath: player.currentIndexOnPath,
                x: player.x,
                y: player.y,
                money: player.money, // Include money in case they passed GO
                isMoving: true,
                movementTimestamp: Date.now(),
                movementStep: null, // Clear movement step
                totalMovementSteps: null // Clear total steps
            }).catch(error => console.error('Error updating player position:', error));
        }
    }
    
    // Clear movement flag - movement is complete
    isPlayerMoving = false;
    
    // Mark movement as completed and clear timeout
    moveCompleted = true;
    clearTimeout(moveTimeout);
    
    return false; // Indicates normal movement completion
    
    } catch (error) {
        console.error(`[moveToken] Error during movement for ${player.name}:`, error);
        
        // Clean up on error
        moveCompleted = true;
        clearTimeout(moveTimeout);
        isPlayerMoving = false;
        
        return false; // Return false to continue with turn logic
    }
}

// Function to check and handle path transitions and teleportations
async function checkForTeleportation(player) {
    const currentSquare = player.currentSquare;
    
    // Check for direct teleportation (t8 â†’ t2)
    if (currentSquare === 't8') {
        console.log(`[checkForTeleportation] Player ${player.name} landed on Hell's Portal (t8), teleporting to Sanctuary (t2)`);
        
        // Add red glow effect to t8
        const t8Element = document.querySelector(`[data-square="t8"]`);
        if (t8Element) {
            t8Element.classList.add('t8-glow');
            // Remove the glow effect after animation completes
            setTimeout(() => {
                t8Element.classList.remove('t8-glow');
            }, 500);
        }
        
        // Play zap sound for teleportation
        await playZapSound();
        
        // Create white screen flash for teleportation
        createTeleportScreenFlash();
        
        // Show "TELEPORT!" flash message
        showTeleportFlash();
        
        // Find t2 position on the main game path
        const t2Index = gamePath.indexOf('t2');
        const t2Pos = positionsMap.get('t2');
        
        if (t2Index !== -1 && t2Pos) {
            player.currentSquare = 't2';
            player.currentPathKey = 'gamePath';
            player.currentIndexOnPath = t2Index;
            player.x = t2Pos.x;
            player.y = t2Pos.y;
            
            showAdvisory(`${player.name} teleported from Hell's Portal to Sanctuary!`, 'teleport');
            console.log(`[checkForTeleportation] ${player.name} teleported from Hell's Portal (t8) to Sanctuary (t2)`);
            
            // Update game frame to show new position
            await updateGameFrame();
            await new Promise(resolve => setTimeout(resolve, 1000)); // Brief pause to show teleportation
        } else {
            console.error(`[checkForTeleportation] Could not find t2 position for teleportation`);
        }
        return; // Don't check for other transitions after teleportation
    }
    

    // Check for R5 to T5 teleportation (1 in 10 chance)
    if (currentSquare === 'r5') {
        // 1 in 10 chance
        const shouldTeleport = Math.floor(Math.random() * 10) === 0;
        if (shouldTeleport) {
            console.log(`[checkForTeleportation] Player ${player.name} landed on r5, teleporting to t5 (1 in 10 chance)`);
            
            // Play zap sound for teleportation
            await playZapSound();
            
            // Create white screen flash for teleportation
            createTeleportScreenFlash();
            
            // Show "TELEPORT!" flash message
            showTeleportFlash();
            
            // Find t5 position on the main game path
            const t5Index = gamePath.indexOf('t5');
            const t5Pos = positionsMap.get('t5');
            
            if (t5Index !== -1 && t5Pos) {
                player.currentSquare = 't5';
                player.currentPathKey = 'gamePath';
                player.currentIndexOnPath = t5Index;
                player.x = t5Pos.x;
                player.y = t5Pos.y;
                
                showAdvisory(`${player.name} teleported from Ritual Chamber to Temple!`, 'teleport');
                console.log(`[checkForTeleportation] ${player.name} teleported from r5 to t5`);
                
                // Update game frame to show new position
                await updateGameFrame();
                await new Promise(resolve => setTimeout(resolve, 1000)); // Brief pause to show teleportation
            } else {
                console.error(`[checkForTeleportation] Could not find t5 position for teleportation`);
            }
            return; // Don't check for other transitions after teleportation
        }
    }
    
    // Check for R7 to bottom row teleportation
    if (currentSquare === 'r7') {
        console.log(`[checkForTeleportation] Player ${player.name} landed on r7, teleporting to bottom row (b1)`);
        
        // Play zap sound for teleportation
        await playZapSound();
        
        // Create white screen flash for teleportation
        createTeleportScreenFlash();
        
        // Show "TELEPORT!" flash message
        showTeleportFlash();
        
        // Find b1 position on the main game path (bottom row)
        const b1Index = gamePath.indexOf('b1');
        const b1Pos = positionsMap.get('b1');
        
        if (b1Index !== -1 && b1Pos) {
            player.currentSquare = 'b1';
            player.currentPathKey = 'gamePath';
            player.currentIndexOnPath = b1Index;
            player.x = b1Pos.x;
            player.y = b1Pos.y;
            
            showAdvisory(`${player.name} teleported from Ritual Altar to the Bottom Row!`, 'teleport');
            console.log(`[checkForTeleportation] ${player.name} teleported from r7 to b1`);
            
            // Update game frame to show new position
            await updateGameFrame();
            await new Promise(resolve => setTimeout(resolve, 1000)); // Brief pause to show teleportation
        } else {
            console.error(`[checkForTeleportation] Could not find b1 position for teleportation`);
        }
        return; // Don't check for other transitions after teleportation
    }
    
    // 1-in-20 chance: R2 to T2 teleportation
    if (currentSquare === 'r2') {
        // 1 in 20 chance
        const shouldTeleport = Math.floor(Math.random() * 20) === 0;
        if (shouldTeleport) {
            // Play zap sound for teleportation
            await playZapSound();
            
            // Create white screen flash for teleportation
            createTeleportScreenFlash();
            
            // Show "TELEPORT!" flash message
            showTeleportFlash();
            
            // Find t2 position on the main game path
            const t2Index = gamePath.indexOf('t2');
            const t2Pos = positionsMap.get('t2');
            
            if (t2Index !== -1 && t2Pos) {
                player.currentSquare = 't2';
                player.currentPathKey = 'gamePath';
                player.currentIndexOnPath = t2Index;
                player.x = t2Pos.x;
                player.y = t2Pos.y;
                
                // Requested advisory message
                showAdvisory(`Player teleprted from Midgets dungeon to Start`, 'teleport');
                
                // Update game frame to show new position
                await updateGameFrame();
                await new Promise(resolve => setTimeout(resolve, 1000)); // Brief pause to show teleportation
            } else {
                console.error(`[checkForTeleportation] Could not find t2 position for R2 random teleportation`);
            }
            return; // Don't check for other transitions after teleportation
        }
    }
    
    // Check for path transition triggers
    for (const [pathKey, pathConfig] of Object.entries(paths)) {
        if (pathConfig.entryTriggerForwardLandOn === currentSquare) {
            console.log(`[checkForTeleportation] Player ${player.name} landed on ${currentSquare}, switching to ${pathKey}`);
            
            // U path entry no longer has teleportation effects
            
            // Switch player to the new path but keep them on the trigger square for this turn
            // Next movement will start from the beginning of the new path
            player.currentPathKey = pathKey;
            player.currentIndexOnPath = -1; // Will be 0 on next move
            
            // Check for snake path money/steal card/lightning bolt on the entry trigger square (just in case)
            if (snakePathMoney[currentSquare] && !snakePathMoney[currentSquare].collected) {
                snakePathMoney[currentSquare].collected = true;
                
                if (snakePathMoney[currentSquare].isStealCard) {
                    // Collect steal card
                    console.log(`[checkForTeleportation] ${player.name} collected a STEAL CARD from path entry square ${currentSquare}!`);
                    player.stealCards = (player.stealCards || 0) + 1;
                    
                    // Show steal card collection message
                    showAdvisory(`<img src="assets/images/spades.png" style="width: 16px; height: 16px; vertical-align: middle;"> ${player.name} found a STEAL CARD when entering ${pathKey}! Total: ${player.stealCards}`, 'turn');
                    
                    // Play steal award sound
                    await playStealAwardSound();
                } else if (snakePathMoney[currentSquare].isLightningBolt) {
                    // Collect lightning bolt on entry
                    console.log(`[checkForTeleportation] ${player.name} collected a LIGHTNING BOLT from path entry square ${currentSquare}!`);
                    player.lightningBolts = (player.lightningBolts || 0) + 1;
                    
                    showAdvisory(`âš¡ ${player.name} found a LIGHTNING BOLT when entering ${pathKey}! Total: ${player.lightningBolts}`, 'turn');
                    playStrikeSound();
                    
                    // Update bottom player display to show new lightning bolt count
                    if (typeof updateBottomPlayerDisplay === 'function') {
                        updateBottomPlayerDisplay();
                    }
                } else {
                    // Collect money as usual
                    console.log(`[checkForTeleportation] ${player.name} collected Â£${snakePathMoney[currentSquare].amount} from path entry square ${currentSquare}!`);
                    player.money += snakePathMoney[currentSquare].amount;
                    
                    // Show money collection message
                    showAdvisory(`ðŸ’° ${player.name} collected Â£${snakePathMoney[currentSquare].amount} when entering ${pathKey}!`, 'payment');
                    
                    // Play money collection sound
                    await playGongSound();
                }
                
                // Sync snake path money collection to Firebase in multiplayer games
                if (isMultiplayerGame) {
                    console.log(`[checkForTeleportation] Syncing snake path money collection (${currentSquare}) to Firebase...`);
                    syncGameStateToFirebase();
                }
            }
            
            // Show path transition message
            const pathName = pathKey === 'snakePath1' ? 'Snake Path 1 (s1â†’s19â†’b1)' : 
                            pathKey === 'snakePath2' ? 'Snake Path 2 (TT1â†’TT19â†’b9)' : pathKey;
            
            // Use turn message type for all path entries
            showAdvisory(`${player.name} entered ${pathName}!`, 'turn');
            
            console.log(`[checkForTeleportation] ${player.name} will enter ${pathKey} on next move`);
            
            break; // Only one path transition per turn
        }
    }
}

// Function to handle doubles on special paths - step-by-step exit to main path
async function handleDoublesOnSpecialPath(player) {
    // Only applies to special paths (not main game path)
    if (player.currentPathKey === 'gamePath') {
        return false; // Not on special path
    }
    
    const currentPathConfig = paths[player.currentPathKey];
    if (!currentPathConfig || !currentPathConfig.exitTargetForward) {
        return false; // No exit target defined
    }
    
    // All snake paths now go forward only - when doubles are rolled, immediately teleport to the end
    const exitTarget = currentPathConfig.exitTargetForward;
    const exitIndex = gamePath.indexOf(exitTarget);
    
    console.log(`[handleDoublesOnSpecialPath] ${player.name} rolled doubles on ${player.currentPathKey} - immediately going to ${exitTarget}!`);
    
    // Immediately teleport to the exit target
    if (exitIndex !== -1) {
        player.currentPathKey = 'gamePath';
        player.currentIndexOnPath = exitIndex;
        player.currentSquare = exitTarget;
        
        const exitPos = positionsMap.get(exitTarget);
        if (exitPos) {
            player.x = exitPos.x;
            player.y = exitPos.y;
            
            console.log(`[handleDoublesOnSpecialPath] ${player.name} immediately teleported from snake path to ${exitTarget}`);
            
            await updateGameFrame();
            
            // Sync to Firebase in multiplayer mode
            if (isMultiplayerGame) {
                await syncGameStateToFirebase();
            }
            
            showAdvisory(`${player.name} rolled doubles and immediately went to the end of the snake path (${exitTarget})!`, 'turn');
            // Award a lightning bolt for completing a snake path via doubles
            try {
                player.lightningBolts = (player.lightningBolts || 0) + 1;
                showAdvisory(`âš¡ ${player.name} received a LIGHTNING BOLT for completing the snake path! Total: ${player.lightningBolts}`, 'turn');
                playStrikeSound();
                updateInfoPanel();
                
                // Update bottom player display to show new lightning bolt count
                if (typeof updateBottomPlayerDisplay === 'function') {
                    updateBottomPlayerDisplay();
                }
            } catch (_) {}
            return true;
        }
    }
    
    return false;
}

// Function to check if player should exit current path and return to main path
async function checkForPathExit(player) {
    const currentPathConfig = paths[player.currentPathKey];
    
    // Only check for exit if not on main game path
    if (player.currentPathKey === 'gamePath') return;
    
    // Check if player reached the end of current path
    if (player.currentIndexOnPath >= currentPathConfig.array.length - 1) {
        console.log(`[checkForPathExit] Player ${player.name} reached end of ${player.currentPathKey}, exiting to main path`);
        
        // Get exit target
        const exitTarget = currentPathConfig.exitTargetForward;
        if (exitTarget) {
            // Find position on main game path
            const exitIndex = gamePath.indexOf(exitTarget);
            if (exitIndex !== -1) {
                player.currentPathKey = 'gamePath';
                player.currentIndexOnPath = exitIndex;
                player.currentSquare = exitTarget;
                
                const exitPos = positionsMap.get(exitTarget);
                if (exitPos) {
                    player.x = exitPos.x;
                    player.y = exitPos.y;
                    
                    showAdvisory(`${player.name} exited to ${exitTarget}!`, 'turn');
                    console.log(`[checkForPathExit] ${player.name} exited to ${exitTarget} on main path`);
                    
                    await updateGameFrame();
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
        }
    }
}

async function sendPlayerToJail(player, chargeAmount = 0) {
    console.log(`Sending ${player.name} to Jail.`);
    
    // Charge the player if specified
    if (chargeAmount > 0) {
        player.money -= chargeAmount;
        checkBankruptcy(player);
        
        // Show "Grave Tax!" message for gojail landing
        showAdvisory(`Grave Tax!`, 'tax');
        setTimeout(() => {
            showAdvisory(`${player.name} is sent to Jail and charged Â£${chargeAmount}!`, 'payment');
        }, 2000);
        
        console.log(`${player.name} charged Â£${chargeAmount} for going to jail. Money: ${player.money}`);
    } else {
        showAdvisory(`${player.name} is sent to Jail!`, 'turn');
    }

    player.currentSquare = 'jail';
    player.currentPathKey = "gamePath"; // Jail is on the main game path
    const jailIndex = gamePath.indexOf('jail');

    if (jailIndex === -1) {
        console.error("CRITICAL: 'jail' position not found in gamePath array!");
        // Potentially add a fallback or more robust error handling here
        return; // Early exit if jail cannot be found
    }
    player.currentIndexOnPath = jailIndex;

    const jailPos = positionsMap.get('jail');
    if (!jailPos) {
        console.error("CRITICAL: 'jail' coordinates not found in positionsMap!");
        // Potentially add a fallback
        return; // Early exit
    }
    player.x = jailPos.x;
    player.y = jailPos.y;

    // Standard Monopoly rules: Do not collect $200 for passing Go if sent to jail.
    // Any "in jail" status flags (e.g., turns in jail, can/cannot roll out) would be managed here or by caller.
    // For now, this function handles the direct placement.



    await updateGameFrame(); // Visually move the player token to jail
    updateInfoPanel(); // Now safe to call - isPlayerMoving flag prevents wrong buttons
}

async function animateDice(die1, die2) {
    // Find dice elements dynamically (works in both normal and minimized mode)
    let die1Element = document.getElementById('die1');
    let die2Element = document.getElementById('die2');
    
    if (!die1Element || !die2Element) {
        console.error('Dice elements not found for animation - attempting to restore');
        
        // Try to restore dice elements if they're missing
        const diceSection = document.getElementById('dice-section');
        if (diceSection) {
            // Check if dice elements exist within the dice section
            die1Element = diceSection.querySelector('#die1');
            die2Element = diceSection.querySelector('#die2');
            
                if (!die1Element || !die2Element) {
        console.error('Dice elements still not found after restoration attempt - recreating them');
        
        // Try to recreate the dice elements
        const diceContent = document.getElementById('dice-content');
        if (diceContent && !die1Element) {
            die1Element = document.createElement('div');
            die1Element.id = 'die1';
            die1Element.className = 'die';
            die1Element.textContent = '1';
            diceContent.appendChild(die1Element);
            console.log('Recreated die1 element');
        }
        
        if (diceContent && !die2Element) {
            die2Element = document.createElement('div');
            die2Element.id = 'die2';
            die2Element.className = 'die';
            die2Element.textContent = '1';
            diceContent.appendChild(die2Element);
            console.log('Recreated die2 element');
        }
        
        // If still not found, try one more time with a delay
        if (!die1Element || !die2Element) {
            console.error('Failed to recreate dice elements - trying again after delay');
            await new Promise(resolve => setTimeout(resolve, 100));
            
            die1Element = document.getElementById('die1');
            die2Element = document.getElementById('die2');
            
            if (!die1Element || !die2Element) {
                console.error('Dice elements could not be restored or recreated');
                return;
            }
        }
            }
        } else {
            console.error('Dice section not found - cannot restore dice elements');
            return;
        }
    }
    
    // Add animation class to both dice
    die1Element.classList.add('animate');
    die2Element.classList.add('animate');
    
    // Show random numbers during animation
    let animationInterval = setInterval(() => {
        die1Element.textContent = Math.floor(Math.random() * 6) + 1;
        die2Element.textContent = Math.floor(Math.random() * 6) + 1;
    }, 100);
    
    // Wait for animation to complete
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // Clear interval and remove animation class
    clearInterval(animationInterval);
    die1Element.classList.remove('animate');
    die2Element.classList.remove('animate');
    
    // Set final values
    die1Element.textContent = die1;
    die2Element.textContent = die2;
}

// Eye position recording mode
function startEyeRecording() {
    console.log('Starting eye recording');
    isRecordingEyes = true;
            // Eye positions are now fixed coordinates, no need to reset
    
    // Add instruction text
    const instructionEl = document.createElement('div');
    instructionEl.id = 'instruction-text';
    instructionEl.style.position = 'fixed';
    instructionEl.style.top = '50%';
    instructionEl.style.left = '50%';
    instructionEl.style.transform = 'translate(-50%, -50%)';
    instructionEl.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    instructionEl.style.color = 'white';
    instructionEl.style.padding = '20px';
    instructionEl.style.borderRadius = '10px';
    instructionEl.style.zIndex = '1000';
    instructionEl.textContent = 'Click to set left eye position';
    document.body.appendChild(instructionEl);
}

function recordEyePosition(e) {
    if (!isRecordingEyes || !canvas) return;

    const rect = canvas.getBoundingClientRect();
    const x = Math.round(e.clientX - rect.left);
    const y = Math.round(e.clientY - rect.top);
    
    console.log('Recording eye position:', { x, y });

    if (!eyePositions.left) {
        eyePositions.left = { x, y };
        const instructionEl = document.getElementById('instruction-text');
        if (instructionEl) {
            instructionEl.textContent = 'Click to set right eye position';
        }
        
        // Draw marker for left eye
        const ctx = canvas.getContext('2d');
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fillStyle = 'red';
        ctx.fill();
    } else if (!eyePositions.right) {
        eyePositions.right = { x, y };
        
        // Draw marker for right eye
        const ctx = canvas.getContext('2d');
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fillStyle = 'red';
        ctx.fill();
        
        // Show the record export dialog
        const recordExport = document.getElementById('record-export');
        const eyePositionsJson = document.getElementById('eye-positions-json');
        
        if (recordExport && eyePositionsJson) {
            console.log('Eye positions recorded:', eyePositions);
            eyePositionsJson.value = JSON.stringify(eyePositions, null, 2);
            recordExport.style.display = 'block';
            
            // Update eye positions in game_utils
            setEyePositions(eyePositions);
            
            // Save to localStorage immediately
            localStorage.setItem('eyePositions', JSON.stringify(eyePositions));
        }
        
        // Remove instruction text
        const instructionEl = document.getElementById('instruction-text');
        if (instructionEl) {
            instructionEl.remove();
        }
        
        isRecordingEyes = false;
    }
}

function clearAutoRollTimer() {
    if (autoRollTimeout) {
        clearTimeout(autoRollTimeout);
        autoRollTimeout = null;
    }
}

function clearAutoActionTimer() {
    if (autoActionTimeout) {
        clearTimeout(autoActionTimeout);
        autoActionTimeout = null;
        console.log('[clearAutoActionTimer] Auto-action timer cleared');
    }
    // Reset tracking variables
    currentTimerType = null;
    timerStartTime = null;
}

// Track the current timer type to prevent unnecessary restarts
let currentTimerType = null;
let timerStartTime = null;

function startAutoActionTimer(actionType = 'roll') {
    // Longer delays for multiplayer to give players more time to respond
    // Extended development timer to give more time for property development decisions
    const delay = isMultiplayerGame ? 
        (actionType === 'roll' ? 20000 : (actionType === 'develop' ? 60000 : 15000)) : // 20s for roll, 60s for develop, 15s for other actions in multiplayer
        (actionType === 'roll' ? 10000 : (actionType === 'develop' ? 30000 : 8000));   // 10s for roll, 30s for develop, 8s for other actions in single player
    
    // CRITICAL FIX: Don't restart timer if same type is already running
    // This prevents multiplayer Firebase syncs from constantly resetting the develop timer
    if (autoActionTimeout && currentTimerType === actionType && timerStartTime) {
        const elapsed = Date.now() - timerStartTime;
        const remaining = delay - elapsed;
        
        if (remaining > 1000) { // If more than 1 second remaining, don't restart
            console.log(`[startAutoActionTimer] Timer for ${actionType} already running with ${Math.round(remaining/1000)}s remaining - not restarting`);
            return;
        }
    }
    
    console.log(`[startAutoActionTimer] Starting ${delay/1000}-second timer for ${actionType} action (${isMultiplayerGame ? 'multiplayer' : 'single player'})`);
    clearAutoActionTimer(); // Clear any existing timer
    
    // Track the new timer
    currentTimerType = actionType;
    timerStartTime = Date.now();
    
    const currentPlayer = players[currentPlayerIndex];
    if (!currentPlayer || currentPlayer.isAI || currentPlayer.bankrupt) {
        console.log('[startAutoActionTimer] No timer needed - player is AI, bankrupt, or not found');
        return;
    }

    // Add early warning for development actions (15 seconds before timeout)
    if (actionType === 'develop' && delay > 15000) {
        const earlyWarningTime = delay - 15000;
        setTimeout(() => {
            if (isMultiplayerGame) {
                showAdvisory(`â° Development decision needed! Auto-declining in 15 seconds...`, 'warning');
            }
        }, earlyWarningTime);
    }

    autoActionTimeout = setTimeout(async () => {
        console.log(`[startAutoActionTimer] ${delay/1000}-second timer expired for ${actionType} action. Auto-executing...`);
        
        if (isMultiplayerGame) {
            // In multiplayer, show warning and auto-execute after another brief delay
            const finalWarningMessage = actionType === 'develop' ? 
                `â° ${currentPlayer.name} didn't make a development decision in time! Auto-declining in 3 seconds...` :
                `â° ${currentPlayer.name} didn't respond in time! Auto-executing in 3 seconds...`;
            showAdvisory(finalWarningMessage, 'warning');
            
            setTimeout(async () => {
                switch(actionType) {
                    case 'roll':
                        console.log('[startAutoActionTimer] Multiplayer auto-rolling dice for unresponsive player...');
                        if (isMultiplayerGame) {
                            // Force the turn for multiplayer
                            await executeMultiplayerAutoTurn();
                        } else {
                            await takeTurn();
                        }
                        break;
                    case 'purchase':
                        console.log('[startAutoActionTimer] Multiplayer auto-declining purchase...');
                        await handleAutoDeclinePurchase();
                        break;
                    case 'develop':
                        console.log('[startAutoActionTimer] Multiplayer auto-declining development...');
                        await handleAutoDeclineDevelopment();
                        break;
                    case 'decline':
                        console.log('[startAutoActionTimer] Multiplayer auto-declining...');
                        await handleAutoDecline();
                        break;
                }
            }, 3000);
        } else {
            // Single player - immediate auto-action
            switch(actionType) {
                case 'roll':
                    console.log('[startAutoActionTimer] Auto-rolling dice...');
                    await takeTurn();
                    break;
                case 'purchase':
                    console.log('[startAutoActionTimer] Auto-declining purchase...');
                    await handleAutoDeclinePurchase();
                    break;
                case 'develop':
                    console.log('[startAutoActionTimer] Auto-declining development...');
                    await handleAutoDeclineDevelopment();
                    break;
                case 'decline':
                    console.log('[startAutoActionTimer] Auto-declining...');
                    await handleAutoDecline();
                    break;
            }
        }
    }, delay);
}

// Execute automatic turn for unresponsive multiplayer player
async function executeMultiplayerAutoTurn() {
    const currentPlayer = players[currentPlayerIndex];
    
    if (!currentPlayer) {
        console.error('[executeMultiplayerAutoTurn] No current player found');
        nextTurn();
        return;
    }
    
    console.log(`[executeMultiplayerAutoTurn] Auto-executing turn for ${currentPlayer.name}`);
    
    try {
        // Roll dice automatically
        const die1 = rollDie();
        const die2 = rollDie();
        const total = die1 + die2;
        
        showAdvisory(`ðŸŽ² Auto-rolled for ${currentPlayer.name}: ${die1} + ${die2} = ${total}`, 'info');
        
        // Animate dice
        await animateDice(die1, die2);
        
        // Update dice display
        updateInfoPanel(die1, die2);
        
        // Move the player
        const moveResult = await moveToken(currentPlayer, total);
        
        // Check for doubles
        const isDouble = die1 === die2;
        if (isDouble) {
            currentPlayer.consecutiveDoubles = (currentPlayer.consecutiveDoubles || 0) + 1;
            
            if (currentPlayer.consecutiveDoubles >= 3) {
                // Send to jail for 3 doubles
                currentPlayer.consecutiveDoubles = 0;
                currentPlayer.inJail = true;
                currentPlayer.jailTurns = 0;
                await sendPlayerToJail(currentPlayer);
                await playThreeDoublesSound();
                showAdvisory(`${currentPlayer.name} rolled 3 doubles and was sent to jail!`, 'jail');
                
                // Update Firebase if multiplayer
                if (isMultiplayerGame && window.updatePlayerInFirebase) {
                    await window.updatePlayerInFirebase(currentPlayer);
                }
                
                nextTurn();
                return;
            } else {
                showAdvisory(`${currentPlayer.name} rolled doubles! Gets another turn.`, 'turn');
                // Stay on same player for another turn
                enableDiceSection();
                startAutoActionTimer('roll'); // Start timer again for the bonus turn
                return;
            }
        } else {
            currentPlayer.consecutiveDoubles = 0;
        }
        
        // Update Firebase if multiplayer
        if (isMultiplayerGame && window.updatePlayerInFirebase) {
            await window.updatePlayerInFirebase(currentPlayer);
        }
        
        // Move to next turn
        nextTurn();
        
    } catch (error) {
        console.error('[executeMultiplayerAutoTurn] Error during auto-turn:', error);
        showAdvisory(`Error during auto-turn for ${currentPlayer.name}. Skipping turn.`, 'error');
        nextTurn();
    }
}

// Auto-decline handler functions
async function handleAutoDeclinePurchase() {
    const currentPlayer = players[currentPlayerIndex];
    if (!currentPlayer) return;
    
    const propertyInfo = getPropertyInfo(currentPlayer.currentSquare);
    if (propertyInfo && !propertyInfo.state.owner) {
        console.log(`[handleAutoDeclinePurchase] Auto-declining purchase of ${getPropertyDisplayName(propertyInfo)} for ${currentPlayer.name}`);
        
        // If this was NOT a double roll, mark as permanently declined for this player
        // This prevents the game from asking again on future turns
        if (!lastRollWasDoubles) {
            console.log(`[handleAutoDeclinePurchase] Non-double roll - marking ${propertyInfo.square} as permanently declined for ${currentPlayer.name}`);
            
            // Mark property as permanently declined by this player
            if (!playerDeclinedProperties.has(currentPlayer.name)) {
                playerDeclinedProperties.set(currentPlayer.name, new Set());
            }
            playerDeclinedProperties.get(currentPlayer.name).add(`auto_${propertyInfo.square}`);
            console.log(`[handleAutoDeclinePurchase] Added auto_${propertyInfo.square} to ${currentPlayer.name}'s permanently declined properties list.`);
        } else {
            console.log(`[handleAutoDeclinePurchase] Double roll - not permanently declining ${propertyInfo.square} for ${currentPlayer.name}`);
        }
        
        // Check if we're in minimized mode with purchase panel
        const infoPanel = document.getElementById('info-panel');
        const isMinimizedWithPurchase = infoPanel && infoPanel.classList.contains('minimized') && 
                                      document.getElementById('minimized-content') && 
                                      document.getElementById('minimized-content').querySelector('button[onclick*="handleMinimizedPropertyPurchase"]');
        
        if (isMinimizedWithPurchase) {
            console.log('[handleAutoDeclinePurchase] Auto-declining from minimized purchase panel');
            // Call the minimized decline function directly
            handleMinimizedDeclinePurchase(propertyInfo.square, currentPlayerIndex);
        } else {
            // Check if we're in minimized mode (but not with purchase panel)
            const isMinimized = infoPanel && infoPanel.classList.contains('minimized');
            
            if (isMinimized) {
                console.log('[handleAutoDeclinePurchase] Auto-declining from minimized mode - reverting to standard minimized state');
                // Ensure dice section exists before reverting
                ensureDiceSectionExists();
                // Revert to standard minimized state without purchase panel
                minimizeToStandardState();
                await handleDeclinePurchase(propertyInfo.square, currentPlayerIndex);
            } else {
                // Regular panel - revert to standard minimized state before auto-declining
        revertToStandardMinimized();
        await handleDeclinePurchase(propertyInfo.square, currentPlayerIndex);
            }
        }
    }
}

async function handleAutoDeclineDevelopment() {
    const currentPlayer = players[currentPlayerIndex];
    if (!currentPlayer) return;
    
    const propertyInfo = getPropertyInfo(currentPlayer.currentSquare);
    if (propertyInfo && propertyInfo.state.owner && propertyInfo.state.owner.toLowerCase() === currentPlayer.name.toLowerCase()) {
        console.log(`[handleAutoDeclineDevelopment] Auto-declining development of ${getPropertyDisplayName(propertyInfo)} for ${currentPlayer.name}`);
        
        // Check if we're in minimized mode with development panel
        const infoPanel = document.getElementById('info-panel');
        const isMinimizedWithDevelopment = infoPanel && infoPanel.classList.contains('minimized') && 
                                         document.getElementById('minimized-content') && 
                                         document.getElementById('minimized-content').querySelector('button[onclick*="handlePropertyDevelopment"]');
        
        if (isMinimizedWithDevelopment) {
            console.log('[handleAutoDeclineDevelopment] Auto-declining from minimized development panel');
            // Call the minimized decline function directly
            handleMinimizedDeclineDevelopment(propertyInfo.square, currentPlayerIndex);
        } else {
            // Check if we're in minimized mode (but not with development panel)
            const isMinimized = infoPanel && infoPanel.classList.contains('minimized');
            
            if (isMinimized) {
                console.log('[handleAutoDeclineDevelopment] Auto-declining from minimized mode - reverting to standard minimized state');
                // Ensure dice section exists before reverting
                ensureDiceSectionExists();
                // Revert to standard minimized state without development panel
                minimizeToStandardState();
                await handleDeclineDevelopment(propertyInfo.square, currentPlayerIndex);
            } else {
                // Regular panel - revert to standard minimized state before auto-declining
        revertToStandardMinimized();
        await handleDeclineDevelopment(propertyInfo.square, currentPlayerIndex);
            }
        }
    }
}

async function handleAutoDecline() {
    // Generic auto-decline - try to find what needs to be declined
    const currentPlayer = players[currentPlayerIndex];
    if (!currentPlayer) return;
    
    const propertyInfo = getPropertyInfo(currentPlayer.currentSquare);
    if (propertyInfo) {
        if (!propertyInfo.state.owner) {
            await handleAutoDeclinePurchase();
        } else if (propertyInfo.state.owner && propertyInfo.state.owner.toLowerCase() === currentPlayer.name.toLowerCase()) {
            await handleAutoDeclineDevelopment();
        }
    }
}

// Helper function to check if development buttons are visible
function hasDevelopmentButtonsVisible() {
    let propertyInfoContent = document.getElementById('property-info-content');
    if (!propertyInfoContent) {
        console.log(`[hasDevelopmentButtonsVisible] propertyInfoContent not found, attempting to create it...`);
        
        // Try to create the element if it doesn't exist
        propertyInfoContent = document.createElement('div');
        propertyInfoContent.id = 'property-info-content';
        
        const infoPanelContent = document.getElementById('info-panel-content');
        if (infoPanelContent) {
            infoPanelContent.appendChild(propertyInfoContent);
            console.log('[hasDevelopmentButtonsVisible] Created property-info-content element');
        } else {
            document.body.appendChild(propertyInfoContent);
            console.log('[hasDevelopmentButtonsVisible] Created property-info-content element (fallback to body)');
        }
        
        // Still return false since we just created an empty element
        return false;
    }
    
    // Check for development buttons (graveyard or crypt build buttons)
    const developButton = propertyInfoContent.querySelector('button[onclick*="handlePropertyDevelopment"]');
    
    const hasButtons = !!developButton;
    console.log(`[hasDevelopmentButtonsVisible] Development buttons visible: ${hasButtons}`, {
        developButton: !!developButton,
        innerHTML: propertyInfoContent.innerHTML.substring(0, 200) + '...'
    });
    return hasButtons;
}

function startAutoRollTimer() {
    console.log('[startAutoRollTimer] Called.');
    clearAutoRollTimer(); // Clear any existing timer

    const currentPlayer = players[currentPlayerIndex];

    if (!currentPlayer) {
        console.error('[startAutoRollTimer] No currentPlayer found. Aborting timer start.');
        return;
    }
    if (currentPlayer.isAI) {
        console.log('[startAutoRollTimer] Player is AI. No timer needed. AI turn handled by handleAITurn().');
        return;
    }
    if (currentPlayer.bankrupt) {
        console.log(`[startAutoRollTimer] Player ${currentPlayer.name} is bankrupt. No timer needed.`);
        return;
    }
    if (isMultiplayerGame) {
        console.log('[startAutoRollTimer] Multiplayer game detected. No auto-roll timer needed.');
        return;
    }
    if (hasDevelopmentButtonsVisible()) {
        console.log('[startAutoRollTimer] Development buttons are visible. No auto-roll timer needed.');
        return;
    }

    console.log(`[startAutoRollTimer] Starting auto-roll timer for human player: ${currentPlayer.name}. Timeout: 8s.`);
    startAutoActionTimer('roll');
    console.log('[startAutoRollTimer] Completed. Using auto-action timer instead of setTimeout.');
}

// Combined Canvas Click Handler with double-click steal functionality
let lastClickTime = 0;
let lastClickPosition = { x: 0, y: 0 };
let lastTapTime = 0;
let lastTapPosition = { x: 0, y: 0 };
// Wider timing window on touch devices to improve reliability of double-tap on tablets/phones
const DOUBLE_CLICK_THRESHOLD = (window.isTablet || (window.deviceInfo && window.deviceInfo.isTablet)) ? 1000 : (isMobile ? 800 : 600);
// Looser spatial tolerance on touch devices (board is often scaled and fingers imprecise)
const CLICK_POSITION_THRESHOLD = (window.isTablet || (window.deviceInfo && window.deviceInfo.isTablet)) ? 140 : (isMobile ? 110 : 40);

function handleCanvasClick(e) {
    if (isRecordingEyes) {
        recordEyePosition(e); // Existing eye recording logic
    } else if (isRecordingBoardPositions) {
        recordBoardPosition(e); // New board position recording logic
    } else {
        // Handle potential double-click for property stealing or bolt targeting
        const currentTime = Date.now();
        const rect = canvas.getBoundingClientRect();
        
        // Get click coordinates with proper scaling for mobile
        let clickX, clickY;
        if (e.touches) { // Touch event
            const touch = e.touches[0] || e.changedTouches[0];
            // Account for canvas scaling and scroll position
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            clickX = (touch.clientX - rect.left) * scaleX;
            clickY = (touch.clientY - rect.top) * scaleY;
        } else { // Mouse event
            clickX = e.clientX - rect.left;
            clickY = e.clientY - rect.top;
        }
        
        // Check if this is a double-click/tap
        const timeSinceLastClick = currentTime - lastClickTime;
        const distanceFromLastClick = Math.sqrt(
            Math.pow(clickX - lastClickPosition.x, 2) + 
            Math.pow(clickY - lastClickPosition.y, 2)
        );
        
        if (timeSinceLastClick < DOUBLE_CLICK_THRESHOLD && distanceFromLastClick < CLICK_POSITION_THRESHOLD) {
            // This is a double-click - record coordinates and process action
            console.log(`Double-click detected at coordinates: x=${Math.round(clickX)}, y=${Math.round(clickY)}`);
            if (isBoltTargetingMode) {
                handleLightningBoltFire(clickX, clickY);
            } else {
            showAdvisory(`Double-click coordinates: x=${Math.round(clickX)}, y=${Math.round(clickY)}`, 'info');
                // Check for property stealing
            handlePropertySteal(clickX, clickY);
            }
        }
        
        // Update last click info
        lastClickTime = currentTime;
        lastClickPosition = { x: clickX, y: clickY };
        
        // Log single clicks for debugging
        console.log(`Single click detected at: x=${Math.round(clickX)}, y=${Math.round(clickY)}`);
    }
}

// Find the existing touch handler functions and update them
function updateTouchHandlers() {
    // Remove old event listeners if they exist
    if (canvas) {
        canvas.removeEventListener('touchstart', handleTouchStart);
        canvas.removeEventListener('touchend', handleTouchEnd);
    }
    
    // Update the existing handleTouchStart function
    window.handleTouchStart = function(e) {
        if (!canvas) return;
        
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches[0];
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        // Calculate touch position with proper scaling
        const touchX = (touch.clientX - rect.left) * scaleX;
        const touchY = (touch.clientY - rect.top) * scaleY;
        
        lastTapTime = Date.now();
        lastTapPosition = { x: touchX, y: touchY };
        
        // Prevent default scrolling when touching the canvas
        // Use passive: false at listener registration to ensure preventDefault works on touch devices
        e.preventDefault();
    };
    
    // Update the existing handleTouchEnd function
    window.handleTouchEnd = function(e) {
        if (!canvas) return;
        
        const currentTime = Date.now();
        const rect = canvas.getBoundingClientRect();
        const touch = e.changedTouches[0];
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        // Calculate touch position with proper scaling
        const touchX = (touch.clientX - rect.left) * scaleX;
        const touchY = (touch.clientY - rect.top) * scaleY;
        
        // Check for double tap
        const timeSinceLastTap = currentTime - lastTapTime;
        const distanceFromLastTap = Math.sqrt(
            Math.pow(touchX - lastTapPosition.x, 2) + 
            Math.pow(touchY - lastTapPosition.y, 2)
        );
        
        if (timeSinceLastTap < DOUBLE_CLICK_THRESHOLD && distanceFromLastTap < CLICK_POSITION_THRESHOLD) {
            console.log(`Double-tap detected at: x=${Math.round(touchX)}, y=${Math.round(touchY)}`);
            if (isBoltTargetingMode) {
                handleLightningBoltFire(touchX, touchY);
            } else {
            handlePropertySteal(touchX, touchY);
            }
        }
        
        // Prevent default behavior
        e.preventDefault();
    };
    
    // Re-add event listeners with updated handlers
    if (canvas) {
        // Passive false is important so we can reliably call preventDefault on touchstart/touchend
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
    }
}

// Update the existing initializeMobileControls function to include touch handlers
if (typeof initializeMobileControls === 'function') {
    const originalInitMobileControls = initializeMobileControls;
    initializeMobileControls = function() {
        originalInitMobileControls();
        if (isMobile) {
            console.log('Updating touch handlers');
            updateTouchHandlers();
        }
    };
}

// Board Position Recording Functions
function startBoardPositionRecording(pathArrayToRecord, pathNameForDisplay) {
    if (!pathArrayToRecord || pathArrayToRecord.length === 0) {
        alert(`${pathNameForDisplay} is not defined or is empty. Cannot record positions.`);
        return;
    }
    currentRecordingPathArray = pathArrayToRecord; // Store the path to record
    isRecordingBoardPositions = true;
    isRecordingEyes = false; // Ensure eye recording is off
    document.getElementById('record-export').style.display = 'none'; // Hide eye panel if open

    recordedPositionsData = [];
    currentRecordingPathIndex = 0;
    
    updateBoardPositionRecorderInstruction();
    boardPositionsJsonOutputEl.value = ""; // Clear previous output
    boardPositionsRecorderPanelEl.style.display = 'block';
    
    // Disable game interactions while recording positions
    const diceSection = document.getElementById('dice-section');
    if (diceSection) diceSection.style.pointerEvents = 'none';
    if (recordPositionsBtnEl) recordPositionsBtnEl.disabled = true;
    if (recordSnakePathBtnEl) recordSnakePathBtnEl.disabled = true; // Disable snake path button too

    console.log(`Board position recording started for: ${pathNameForDisplay}`);
}

function cancelBoardPositionRecording() {
    isRecordingBoardPositions = false;
    recordedPositionsData = [];
    currentRecordingPathIndex = 0;
    currentRecordingPathArray = null; // Clear the current path array
    
    boardPositionsRecorderPanelEl.style.display = 'none';
    boardPositionsJsonOutputEl.value = "";
    
    const diceSection = document.getElementById('dice-section');
    if (diceSection) diceSection.style.pointerEvents = 'auto';
    if (recordPositionsBtnEl) recordPositionsBtnEl.disabled = false;
    if (recordSnakePathBtnEl) recordSnakePathBtnEl.disabled = false; // Re-enable snake path button
    
    console.log("Board position recording cancelled.");
}

function updateBoardPositionRecorderInstruction() {
    if (!currentRecordingPathArray) return; // Guard against no path selected

    if (currentRecordingPathIndex < currentRecordingPathArray.length) {
        const nextSquareName = currentRecordingPathArray[currentRecordingPathIndex];
        positionRecorderInstructionEl.textContent = `Click on the center of: ${nextSquareName} (${currentRecordingPathIndex + 1}/${currentRecordingPathArray.length})`;
    } else {
        positionRecorderInstructionEl.textContent = `All ${currentRecordingPathArray.length} positions recorded! Copy JSON below.`;
    }
}

function recordBoardPosition(event) {
    if (!isRecordingBoardPositions || !canvas || !currentRecordingPathArray) return;
    if (currentRecordingPathIndex >= currentRecordingPathArray.length) {
        console.log("All positions already recorded.");
        return; // All positions recorded
    }

    const rect = canvas.getBoundingClientRect();
    const x = Math.round(event.clientX - rect.left);
    const y = Math.round(event.clientY - rect.top);

    const squareName = currentRecordingPathArray[currentRecordingPathIndex];
    recordedPositionsData.push({ name: squareName, x: x, y: y });

    console.log(`Recorded: ${squareName} at x:${x}, y:${y}`);
    boardPositionsJsonOutputEl.value = JSON.stringify(recordedPositionsData, null, 2);

    currentRecordingPathIndex++;
    updateBoardPositionRecorderInstruction();

    if (currentRecordingPathIndex >= currentRecordingPathArray.length) {
        console.log("All board positions for the current path recorded.");
        // Optionally, disable further clicks or provide a 'done' state
    }
}

// Function to update token pulsing
function updateTokenPulsing() {
    const currentPlayer = players[currentPlayerIndex];
    
    // Remove pulse from all tokens
    players.forEach(player => {
        if (player.image) {
            player.image.classList.remove('token-pulse');
        }
    });
    
    // Add pulse to current player's token
    if (currentPlayer.image) {
        currentPlayer.image.classList.add('token-pulse');
    }
}

// Function to check for money changes and trigger flash animations
function checkMoneyChangesAndPulse() {
    if (!players || !Array.isArray(players)) return;
    
    players.forEach((player, index) => {
        const playerName = player.name;
        const currentMoney = player.money;
        const previousMoney = previousPlayerMoney.get(playerName);
        
        if (previousMoney !== undefined && previousMoney !== currentMoney) {
            // Money changed - trigger flash animation
            const moneyElement = document.getElementById(`player-money-${index}`);
            if (moneyElement) {
                // Remove any existing flash classes
                moneyElement.classList.remove('money-flash-green', 'money-flash-red');
                
                // Force a reflow to ensure the class removal takes effect
                void moneyElement.offsetWidth;
                
                // Add appropriate flash class based on money change
                if (currentMoney > previousMoney) {
                    // Money increased - green flash
                    moneyElement.classList.add('money-flash-green');
                    console.log(`${playerName} gained Â£${currentMoney - previousMoney} (Â£${previousMoney} â†’ Â£${currentMoney})`);
                } else {
                    // Money decreased - red flash
                    moneyElement.classList.add('money-flash-red');
                    console.log(`${playerName} lost Â£${previousMoney - currentMoney} (Â£${previousMoney} â†’ Â£${currentMoney})`);
                }
                
                // Remove the flash class after animation completes
                setTimeout(() => {
                    moneyElement.classList.remove('money-flash-green', 'money-flash-red');
                }, 1200); // Match the animation duration (0.6s Ã— 2 repetitions)
            }
        }
        
        // Update the stored previous money value
        previousPlayerMoney.set(playerName, currentMoney);
    });
}

// Function to update dice pulsing
function updateDicePulsing() {
    const diceSection = document.getElementById('dice-section');
    if (!diceSection) return;
    
    // Safety check: if players array is empty, skip dice pulsing
    if (!players || players.length === 0) {
        console.log('[updateDicePulsing] Skipping dice pulsing - players array is empty or undefined');
        return;
    }
    
    // Remove all pulse classes first
    removeAllDicePulseClasses(diceSection);
    
    if (isAITurn) {
        // Use AI player's color for pulsing instead of generic blue
        const currentPlayer = players[currentPlayerIndex];
        if (!currentPlayer) {
            console.error('[updateDicePulsing] CRITICAL: currentPlayer is undefined for AI turn. currentPlayerIndex:', currentPlayerIndex);
            return;
        }
        const aiPlayerPulseClass = getPlayerDicePulseClassByPlayer(currentPlayer);
        diceSection.classList.add(aiPlayerPulseClass);
        diceSection.style.pointerEvents = 'none';
        console.log(`[updateDicePulsing] Applied AI player color pulse: ${aiPlayerPulseClass}`);
    } else {
        // For human players, delegate to enableDiceSection which has proper multiplayer logic
        // Don't duplicate the logic here - let enableDiceSection handle it
        // But first check if players array is initialized
        if (players && players.length > 0) {
            enableDiceSection();
        } else {
            console.log('[updateDicePulsing] Skipping enableDiceSection - players array is empty or undefined');
        }
    }
}

// Add this function to handle eye animation
function startEyeAnimation() {
    // Glowing eyes feature disabled
    return;
}

// Add the eye animation function
function animateEyes() {
    const canvas = document.querySelector('canvas');
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const duration = 2000; // Animation duration in milliseconds
    const now = Date.now();
    const elapsed = now - eyeAnimationStartTime;

    if (elapsed < duration) {
        // Calculate animation progress (0 to 1)
        const progress = elapsed / duration;
        
        // Pulsing glow effect
        const glowIntensity = Math.abs(Math.sin(progress * Math.PI * 2)) * 50;
        
        // Draw glowing eyes
        [eyePositions.left, eyePositions.right].forEach(eye => {
            if (!eye) return;
            
            // Outer glow
            const gradient = ctx.createRadialGradient(
                eye.x, eye.y, 0,
                eye.x, eye.y, 20
            );
            gradient.addColorStop(0, `rgba(255, 0, 0, ${0.8 * (glowIntensity/50)})`);
            gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(eye.x, eye.y, 20, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner bright center
            ctx.fillStyle = `rgba(255, ${100 - glowIntensity}, ${100 - glowIntensity}, 1)`;
            ctx.beginPath();
            ctx.arc(eye.x, eye.y, 5, 0, Math.PI * 2);
            ctx.fill();
        });

        // Continue animation
        eyeAnimationFrame = requestAnimationFrame(animateEyes);
    } else {
        // Stop animation
        if (eyeAnimationFrame) {
            cancelAnimationFrame(eyeAnimationFrame);
            eyeAnimationFrame = null;
        }
        // Ensure we update the frame one last time to clear any remaining effects
        updateGameFrame();
    }
}

// Modify drawPropertyMarkers function
// Function to draw a star shape
function drawStar(ctx, x, y, size, color) {
    const spikes = 5;
    const outerRadius = size;
    const innerRadius = size * 0.4;
    
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = color;
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2; // Thicker border for visibility
    
    ctx.beginPath();
    for (let i = 0; i < spikes * 2; i++) {
        const radius = i % 2 === 0 ? outerRadius : innerRadius;
        const angle = (i * Math.PI) / spikes - Math.PI / 2; // Start from top
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        
        if (i === 0) {
            ctx.moveTo(x, y);
        } else {
            ctx.lineTo(x, y);
        }
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();
}

// Function to draw star outline only (for enhanced visibility)
function drawStarOutline(ctx, x, y, size) {
    const spikes = 5;
    const outerRadius = size;
    const innerRadius = size * 0.4;
    
    ctx.save();
    ctx.translate(x, y);
    
    ctx.beginPath();
    for (let i = 0; i < spikes * 2; i++) {
        const radius = i % 2 === 0 ? outerRadius : innerRadius;
        const angle = (i * Math.PI) / spikes - Math.PI / 2; // Start from top
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        
        if (i === 0) {
            ctx.moveTo(x, y);
        } else {
            ctx.lineTo(x, y);
        }
    }
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
}

// Function to find player by name and get their color
function getPlayerColor(playerName) {
    const player = players.find(p => p.name.toLowerCase() === (playerName || '').toLowerCase());
    
    if (!player) {
        console.warn(`getPlayerColor: Player "${playerName}" not found in players array`);
        return '#ff0000'; // Default to red if player not found
    }
    
    if (!player.color) {
        console.warn(`getPlayerColor: Player "${playerName}" has no color assigned, assigning colors now`);
        // Try to assign colors if they're missing
        assignPlayerColors(players);
        // Return the color after assignment
        return player.color || '#ff0000';
    }
    
    console.log(`getPlayerColor: Player "${playerName}" has color ${player.color}`);
    return player.color;
}

// Function to get the appropriate colored crypt image based on player color
function getCryptImageByColor(playerColor) {
    switch (playerColor) {
        case '#ff0000': // Red
            return cryptRedImageLoaded ? cryptRedImage : null;
        case '#0000ff': // Blue
            return cryptBlueImageLoaded ? cryptBlueImage : null;
        case '#00ff00': // Green
            return cryptGreenImageLoaded ? cryptGreenImage : null;
        case '#ffff00': // Yellow
            return cryptYellowImageLoaded ? cryptYellowImage : null;
        case '#800080': // Purple
            return cryptWhiteImageLoaded ? cryptWhiteImage : null;
        default:
            // For any other color, use the default crypt image
            return cryptImageLoaded ? cryptImage : null;
    }
}

function ensurePropertyColors() {
    console.log('ensurePropertyColors: Checking all properties for missing colors');
    
    // First ensure all players have colors
    if (players.some(p => !p.color)) {
        console.log('ensurePropertyColors: Some players missing colors, assigning now');
        assignPlayerColors(players);
    }
    
    // Go through all properties and ensure they have owner colors
    Object.keys(propertyState).forEach(propertyId => {
        const property = propertyState[propertyId];
        if (property.owner && !property.ownerColor) {
            property.ownerColor = getPlayerColor(property.owner);
            console.log(`Fixed missing color for property ${propertyId} owned by ${property.owner}, color: ${property.ownerColor}`);
        }
    });
}

function drawPropertyMarkers(ctx) {
    if (!positionsMap) return;

    for (const [square, state] of Object.entries(propertyState)) {
        if (!state.owner) continue;

        const pos = positionsMap.get(square);
        if (!pos) continue;

        if (stolenPropertyPulse === square) {
            const pulse = Math.abs(Math.sin(Date.now() * 0.01));
            ctx.save();
            ctx.strokeStyle = `rgba(255,0,0,${0.5 + pulse * 0.5})`;
            ctx.lineWidth = 4 + pulse * 2;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 26 + pulse * 6, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }

        const groupInfo = propertyGroups[state.group];
        if (!groupInfo) continue;

        // Get owner's color
        const ownerColor = state.ownerColor || getPlayerColor(state.owner);
        
        // Enhanced debug logging for property ownership display
        console.log(`ðŸ  Drawing ownership marker for ${square}: owner=${state.owner}, ownerColor=${ownerColor}, position=(${pos.x}, ${pos.y})`);
        
        // Validate that we have all required data
        if (!ownerColor || ownerColor === 'undefined') {
            console.warn(`âš ï¸ Missing owner color for ${square} owned by ${state.owner}`);
            // Try to fix it immediately
            if (state.owner) {
                const fixedColor = getPlayerColor(state.owner);
                state.ownerColor = fixedColor;
                console.log(`ðŸ”§ Fixed color for ${square}: ${fixedColor}`);
            }
        }

        // Check if this property should be highlighted with player-colored glow
        const isHighlighted = propertyGroupHighlightActive && highlightedProperties.includes(square);
        
        // Draw player-colored pulsing glow for highlighted properties
        if (isHighlighted) {
            ctx.save();
            // Create pulsing effect based on current time
            const time = Date.now() / 1000;
            const pulseIntensity = (Math.sin(time * 4) + 1) / 2; // Oscillates between 0 and 1
            const glowRadius = 35 + (pulseIntensity * 10); // Pulsing radius
            const glowAlpha = 0.4 + (pulseIntensity * 0.3); // Pulsing opacity
            
            // Convert hex color to RGB for gradient
            const hexColor = highlightPlayerColor;
            const r = parseInt(hexColor.slice(1, 3), 16);
            const g = parseInt(hexColor.slice(3, 5), 16);
            const b = parseInt(hexColor.slice(5, 7), 16);
            
            // Create radial gradient with player's color
            const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, glowRadius);
            gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${glowAlpha})`);
            gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${glowAlpha * 0.5})`);
            gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, glowRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        
        // Draw colored background circle for ownership visibility
        ctx.save();
        ctx.globalAlpha = 0.4; // Slightly more visible background
        ctx.fillStyle = ownerColor;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 30, 0, Math.PI * 2); // Larger circle around the star
        ctx.fill();
        ctx.restore();
        
        // Draw colored star for ownership (on top of background) - Enhanced visibility
        ctx.save();
        ctx.shadowColor = ownerColor;
        ctx.shadowBlur = 8;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        drawStar(ctx, pos.x, pos.y, 20, ownerColor); // Larger star
        ctx.restore();
        
        // Add a white border around the star for better contrast
        ctx.save();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.8;
        drawStarOutline(ctx, pos.x, pos.y, 20);
        ctx.restore();

        // Calculate rent for later display (will be drawn on top of everything)
        const propertyInfo = {
            square: square,
            group: state.group,
            cost: groupInfo.cost,
            color: groupInfo.color,
            state: state
        };
        const rentInfo = calculateRent(propertyInfo);
        const currentRent = rentInfo.amount;

        // Draw development markers
        // Draw graveyards first (if any and no crypt) - NEW NUMBERED GRAVEYARD SYSTEM
        if (!state.hasCrypt && state.graveyards > 0) {
            const graveSize = 60; // Much larger size for better visibility (increased by 50%)
            const borderWidth = 4; // Thicker border for better visibility
            
            // Get the appropriate graveyard image based on count
            let graveyardImage = null;
            let graveyardImageLoaded = false;
            
            switch (state.graveyards) {
                case 1:
                    graveyardImage = grave1Image;
                    graveyardImageLoaded = grave1ImageLoaded;
                    break;
                case 2:
                    graveyardImage = grave2Image;
                    graveyardImageLoaded = grave2ImageLoaded;
                    break;
                case 3:
                    graveyardImage = grave3Image;
                    graveyardImageLoaded = grave3ImageLoaded;
                    break;
                case 4:
                    graveyardImage = grave4Image;
                    graveyardImageLoaded = grave4ImageLoaded;
                    break;
                default:
                    // Fallback to legacy system for invalid counts
                    graveyardImage = graveImage;
                    graveyardImageLoaded = graveImageLoaded;
                    break;
            }
            
            if (graveyardImageLoaded && graveyardImage) {
                // Save current context state
                ctx.save();
                
                // Center the graveyard image on the property
                const x = pos.x - (graveSize / 2);
                const y = pos.y - (graveSize / 2);
                
                // Add shadow for better visibility
                ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                
                // Draw player color border with enhanced visibility
                if (state.ownerColor) {
                    ctx.strokeStyle = state.ownerColor;
                    ctx.lineWidth = borderWidth;
                    ctx.strokeRect(x - borderWidth/2, y - borderWidth/2, graveSize + borderWidth, graveSize + borderWidth);
                }
                
                // Draw the graveyard image
                ctx.drawImage(
                    graveyardImage,
                    x,
                    y,
                    graveSize,
                    graveSize
                );
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Restore context state
                ctx.restore();
                
                console.log(`ðŸª¦ Drew ${state.graveyards} graveyard(s) for ${state.owner} with color ${state.ownerColor}`);
            } else {
                // Fallback: draw individual graves using legacy system
                const individualGraveSize = 30; // Much larger for better visibility (increased by 50%)
                const spacing = 6;
                const startX = pos.x - (individualGraveSize / 2);
                const startY = pos.y - (individualGraveSize / 2);
                const rotationAngle = -15 * Math.PI / 180;
                
                for (let i = 0; i < state.graveyards; i++) {
                    const row = Math.floor(i / 2);
                    const col = i % 2;
                    const x = startX + col * (individualGraveSize + spacing) - (individualGraveSize / 2);
                    const y = startY + row * (individualGraveSize + spacing) - (individualGraveSize / 2);
                    
                    if (graveImageLoaded && graveImage) {
                        ctx.save();
                        
                        // Add shadow for individual graves
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
                        ctx.shadowBlur = 4;
                        ctx.shadowOffsetX = 1;
                        ctx.shadowOffsetY = 1;
                        
                        ctx.translate(x + individualGraveSize/2, y + individualGraveSize/2);
                        ctx.rotate(rotationAngle);
                        ctx.drawImage(graveImage, -individualGraveSize/2, -individualGraveSize/2, individualGraveSize, individualGraveSize);
                        
                        // Reset shadow
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                        
                        ctx.restore();
                    } else {
                        // Ultimate fallback: enhanced colored circles with player color
                        ctx.save();
                        
                        // Add shadow for fallback graves
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                        ctx.shadowBlur = 6;
                        ctx.shadowOffsetX = 2;
                        ctx.shadowOffsetY = 2;
                        
                        // Draw thicker border for better visibility
                        ctx.strokeStyle = state.ownerColor || '#ffffff';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(x + individualGraveSize/2, y + individualGraveSize/2, individualGraveSize/2, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Fill with darker color
                        ctx.fillStyle = state.ownerColor || '#444444';
                        ctx.beginPath();
                        ctx.arc(x + individualGraveSize/2, y + individualGraveSize/2, individualGraveSize/2 - 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add red pulsing effect (enhanced)
                        const pulseIntensity = Math.abs(Math.sin(Date.now() * 0.003)) * 0.6;
                        ctx.fillStyle = `rgba(255, 0, 0, ${pulseIntensity})`;
                        ctx.beginPath();
                        ctx.arc(x + individualGraveSize/2, y + individualGraveSize/2, individualGraveSize/2 - 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw larger, bolder text
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('âš°', x + individualGraveSize/2, y + individualGraveSize/2);
                        
                        ctx.restore();
                    }
                }
                
                console.log(`ðŸª¦ Drew ${state.graveyards} individual graves (fallback) for ${state.owner}`);
            }
        }
        
        // Rent prices are now drawn separately as the final top layer for full visibility
    }
    
        // Draw gojail glow effect if active
    if (gojailGlowActive) {
        const gojailPos = positionsMap.get('gojail');
        if (gojailPos) {
            // Create dramatic pulsing green glow effect from nothing to full visibility
            const time = Date.now() * 0.004; // Slightly faster pulse for more noticeable effect
            const pulseIntensity = (Math.sin(time) + 1) * 0.5; // Pulse from 0 to 1 (nothing to full glow)
            
            // Only draw if there's some intensity (creates the "from nothing" effect)
            if (pulseIntensity > 0.05) {
                // Draw witch face image with matching opacity
                if (witchFaceImage.complete) {
                    ctx.save();
                    ctx.globalAlpha = pulseIntensity * 0.8;
                    // Draw the witch face centered on the gojail position
                    const imageSize = 80; // Size of the witch face
                    ctx.drawImage(witchFaceImage, 
                        gojailPos.x - imageSize/2, 
                        gojailPos.y - imageSize/2, 
                        imageSize, 
                        imageSize
                    );
                    ctx.restore();
                }
                // Draw outer glow with larger radius for more dramatic effect
                const outerGradient = ctx.createRadialGradient(
                    gojailPos.x, gojailPos.y, 0,
                    gojailPos.x, gojailPos.y, 80
                );
                outerGradient.addColorStop(0, `rgba(0, 255, 0, ${pulseIntensity * 0.8})`);
                outerGradient.addColorStop(0.3, `rgba(0, 255, 0, ${pulseIntensity * 0.5})`);
                outerGradient.addColorStop(0.7, `rgba(0, 255, 0, ${pulseIntensity * 0.2})`);
                outerGradient.addColorStop(1, 'rgba(0, 255, 0, 0)');
                
                ctx.fillStyle = outerGradient;
                ctx.beginPath();
                ctx.arc(gojailPos.x, gojailPos.y, 80, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw middle glow
                const middleGradient = ctx.createRadialGradient(
                    gojailPos.x, gojailPos.y, 0,
                    gojailPos.x, gojailPos.y, 50
                );
                middleGradient.addColorStop(0, `rgba(0, 255, 0, ${pulseIntensity * 0.9})`);
                middleGradient.addColorStop(0.5, `rgba(0, 255, 0, ${pulseIntensity * 0.6})`);
                middleGradient.addColorStop(1, 'rgba(0, 255, 0, 0)');
                
                ctx.fillStyle = middleGradient;
                ctx.beginPath();
                ctx.arc(gojailPos.x, gojailPos.y, 50, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw inner core glow (brightest)
                const innerGradient = ctx.createRadialGradient(
                    gojailPos.x, gojailPos.y, 0,
                    gojailPos.x, gojailPos.y, 25
                );
                innerGradient.addColorStop(0, `rgba(0, 255, 0, ${pulseIntensity})`);
                innerGradient.addColorStop(0.6, `rgba(0, 255, 0, ${pulseIntensity * 0.7})`);
                innerGradient.addColorStop(1, 'rgba(0, 255, 0, 0)');
                
                ctx.fillStyle = innerGradient;
                ctx.beginPath();
                ctx.arc(gojailPos.x, gojailPos.y, 25, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }
    
    // Draw shaking graves at gojail if active
    if (gojailGravesShaking) {
        const gojailPos = positionsMap.get('gojail');
        if (gojailPos) {
            // Create shaking effect with random offset
            const shakeIntensity = 3; // pixels
            const shakeTime = Date.now() * 0.02; // Fast shake
            const shakeX = Math.sin(shakeTime) * shakeIntensity + Math.random() * 2 - 1;
            const shakeY = Math.cos(shakeTime * 1.3) * shakeIntensity + Math.random() * 2 - 1;
            
            // Draw 3-4 graves around the gojail position
            const numGraves = 3 + Math.floor(Math.random() * 2); // 3 or 4 graves
            const graveSize = 24; // Much larger for better visibility (increased by 50%)
            const radius = 25; // Distance from center
            
            for (let i = 0; i < numGraves; i++) {
                const angle = (i / numGraves) * Math.PI * 2;
                const graveX = gojailPos.x + Math.cos(angle) * radius + shakeX;
                const graveY = gojailPos.y + Math.sin(angle) * radius + shakeY;
                
                if (graveImageLoaded && graveImage) {
                    // Save context for rotation
                    ctx.save();
                    
                    // Add shadow for better visibility
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    ctx.shadowBlur = 6;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                    
                    ctx.translate(graveX, graveY);
                    
                    // Add slight random rotation for more chaotic effect
                    const shakeRotation = (Math.random() - 0.5) * 0.3; // Â±0.15 radians
                    ctx.rotate(shakeRotation);
                    
                    // Draw grave image centered at the rotation point
                    ctx.drawImage(
                        graveImage,
                        -graveSize/2,
                        -graveSize/2,
                        graveSize,
                        graveSize
                    );
                    
                    // Reset shadow
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    
                    ctx.restore();
                } else {
                    // Fallback: draw simple grave shape
                    ctx.fillStyle = '#666666';
                    ctx.beginPath();
                    ctx.arc(graveX, graveY, graveSize/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add cross
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(graveX, graveY - graveSize/3);
                    ctx.lineTo(graveX, graveY + graveSize/3);
                    ctx.moveTo(graveX - graveSize/4, graveY);
                    ctx.lineTo(graveX + graveSize/4, graveY);
                    ctx.stroke();
                }
            }
        }
    }
}

// Modify the updateGameFrame function
async function updateGameFrame() {
    console.log('updateGameFrame called');
    
    // Try to get canvas from global variable first, then fallback to DOM query
    let canvasToUse = canvas;
    if (!canvasToUse) {
        console.warn('Global canvas variable is null, trying to find canvas in DOM...');
        canvasToUse = document.querySelector('canvas');
        if (canvasToUse) {
            console.log('Found canvas in DOM, updating global canvas variable');
            canvas = canvasToUse;
        }
    }
    
    if (!canvasToUse) {
        console.warn('No canvas found in updateGameFrame - neither global variable nor DOM query found canvas');
        console.log('Available canvases in DOM:', document.querySelectorAll('canvas').length);
        console.log('Game container:', document.getElementById('game-container'));
        
        // Don't try to reinitialize if already in progress
        if (isInitializing) {
            console.log('Game initialization in progress, waiting for canvas...');
            return; // Exit gracefully, canvas should be ready soon
        }
        
        // Try to reinitialize the game if canvas is missing
        if (!isGameInitialized) {
            console.log('ðŸ”„ Attempting to reinitialize game due to missing canvas...');
            try {
                await initGame();
                canvasToUse = canvas; // Try again after initialization
                if (canvasToUse) {
                    console.log('âœ… Canvas found after reinitialization');
                } else {
                    console.log('âŒ Canvas still not found after reinitialization');
                    console.log('ðŸ’¡ To fix this issue, try:');
                    console.log('   - debugCanvasIssues() - to diagnose the problem');
                    console.log('   - forceCanvasReinit() - to force canvas reinitialization');
                    console.log('   - Refresh the page and try again');
                    return;
                }
            } catch (error) {
                console.error('âŒ Failed to reinitialize game:', error);
                console.log('ðŸ’¡ To fix this issue, try:');
                console.log('   - debugCanvasIssues() - to diagnose the problem');
                console.log('   - forceCanvasReinit() - to force canvas reinitialization');
                console.log('   - Refresh the page and try again');
                return;
            }
        } else {
            console.log('ðŸ’¡ To fix this issue, try:');
            console.log('   - debugCanvasIssues() - to diagnose the problem');
            console.log('   - forceCanvasReinit() - to force canvas reinitialization');
            console.log('   - Refresh the page and try again');
            return;
        }
    }
    
    console.log('Canvas found, dimensions:', canvasToUse.width, 'x', canvasToUse.height);
    const ctx = canvasToUse.getContext('2d');
    
    // Clear the entire canvas
    ctx.clearRect(0, 0, canvasToUse.width, canvasToUse.height);
    console.log('Canvas cleared');
    
    // Outer background now handled by CSS body background for full-screen coverage
    // No need to draw outerBackgroundImage on canvas anymore

    // Draw the internal background image (middle layer - shows through board transparency)
    if (backgroundImage && backgroundImage.complete && backgroundImage.naturalWidth > 0) {
        console.log('ðŸŽ¨ Drawing internal background image, dimensions:', backgroundImage.naturalWidth, 'x', backgroundImage.naturalHeight);
        console.log('ðŸŽ¨ Canvas dimensions for internal background:', canvasToUse.width, 'x', canvasToUse.height);
        ctx.drawImage(backgroundImage, 0, 0, canvasToUse.width, canvasToUse.height);
        console.log('âœ… Internal background image drawn successfully');
    } else {
        console.warn('âš ï¸ Internal background image not ready for drawing:', {
            exists: !!backgroundImage,
            complete: backgroundImage?.complete,
            naturalWidth: backgroundImage?.naturalWidth,
            naturalHeight: backgroundImage?.naturalHeight
        });
    }
    
    // Draw the board image on top of the background with transparency
    if (boardImage) {
        console.log('Drawing board image with transparency, dimensions:', boardImage.naturalWidth, 'x', boardImage.naturalHeight);
        // Set transparency for the board so background shows through
        ctx.globalAlpha = boardTransparency; // Use dynamic transparency level
        ctx.drawImage(boardImage, 0, 0, canvasToUse.width, canvasToUse.height);
        ctx.globalAlpha = 1.0; // Reset to full opacity for other elements
        console.log(`Board image drawn with ${Math.round(boardTransparency * 100)}% opacity`);
    } else {
        console.error('No boardImage available for drawing');
    }
    
    // Blue mist disabled
    
    // Draw snake path money with pulsing effect
    drawSnakePathMoney(ctx);
    
    // If bolt targeting mode: draw subtle overlay hint
    if (isBoltTargetingMode) {
        ctx.save();
        ctx.fillStyle = 'rgba(255, 255, 0, 0.05)';
        ctx.fillRect(0, 0, canvasToUse.width, canvasToUse.height);
        ctx.restore();
    }
    
    // Mark current player before rendering
    const playersWithCurrent = Array.isArray(players) ? players.map(p => ({
        ...p,
        isCurrentPlayer: players[currentPlayerIndex] && p.name === players[currentPlayerIndex].name
    })) : [];
    
    console.log('About to render tokens for', playersWithCurrent.length, 'players');
    // Then render tokens with current player indication
    await renderTokens(playersWithCurrent);
    console.log('Tokens rendered');

    // Draw ownership markers and cost labels on purchased properties
    drawPropertyMarkers(ctx);
    
    // If we're in an eye animation, let the animation function handle the eyes
    // Otherwise, if doubles were just rolled, draw the eyes normally
    console.log('Eye glow check:', { eyeAnimationFrame: !!eyeAnimationFrame, lastRollWasDoubles, hasLeftEye: !!eyePositions.left, hasRightEye: !!eyePositions.right });
    if (!eyeAnimationFrame && lastRollWasDoubles && eyePositions.left && eyePositions.right) {
        [eyePositions.left, eyePositions.right].forEach(eye => {
            // Draw a static red glow
            const gradient = ctx.createRadialGradient(
                eye.x, eye.y, 0,
                eye.x, eye.y, 20
            );
            gradient.addColorStop(0, 'rgba(255, 0, 0, 0.8)');
            gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(eye.x, eye.y, 20, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw the eye center
            ctx.fillStyle = 'rgba(255, 50, 50, 1)';
            ctx.beginPath();
            ctx.arc(eye.x, eye.y, 5, 0, Math.PI * 2);
            ctx.fill();
        });
    }
    
    // Update dice pulsing
    updateDicePulsing();
    
    // Draw crypts as the top layer for full visibility
    drawCrypts(ctx);
    
    // Draw rent prices as the final top layer (always on top of everything)
    drawRentPrices(ctx);
}

// Function to draw crypts as the top layer for full visibility
function drawCrypts(ctx) {
    if (!positionsMap) return;
    
    // Iterate through all properties and draw crypts on top
    for (const [square, state] of Object.entries(propertyState)) {
        if (state.hasCrypt) {
            const pos = positionsMap.get(square);
            if (pos) {
                ctx.save(); // Save context state
                
                // Ensure owner color is present for consistent crypt rendering in multiplayer
                if (state.owner && (!state.ownerColor || state.ownerColor === 'undefined' || state.ownerColor === 'null')) {
                    state.ownerColor = getPlayerColor(state.owner);
                }

                // Get the owner's color and corresponding crypt image
                const ownerColor = state.ownerColor || getPlayerColor(state.owner);
                const coloredCryptImage = getCryptImageByColor(ownerColor);
                
                if (coloredCryptImage) {
                    // Draw colored crypt image centered on property
                    const cryptSize = 75; // Slightly larger for better visibility
                    const cryptX = pos.x - (cryptSize / 2); // Center on property position
                    const cryptY = pos.y - (cryptSize / 2); // Center on property position (not above rent)
                    
                    // Add a subtle shadow for depth
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 4;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;

                    // Set transparency (20% transparent = 80% opacity)
                    ctx.globalAlpha = 0.8;

                    ctx.drawImage(
                        coloredCryptImage,
                        cryptX,
                        cryptY,
                        cryptSize,
                        cryptSize
                    );
                } else if (cryptImageLoaded && cryptImage) {
                    // Fallback to default crypt image if colored one not available
                    const cryptSize = 75;
                    const cryptX = pos.x - (cryptSize / 2);
                    const cryptY = pos.y - (cryptSize / 2); // Center on property position
                    
                    // Add a subtle shadow for depth
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 4;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;

                    // Set transparency (20% transparent = 80% opacity)
                    ctx.globalAlpha = 0.8;

                    ctx.drawImage(
                        cryptImage,
                        cryptX,
                        cryptY,
                        cryptSize,
                        cryptSize
                    );
                } else {
                    // Fallback: draw a colored circle with 'C' centered on property
                    const cryptRadius = 25; // Slightly larger
                    const cryptY = pos.y; // Center on property position
                    
                    // Set transparency (20% transparent = 80% opacity)
                    ctx.globalAlpha = 0.8;
                    
                    // Draw shadow first
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.arc(pos.x + 2, cryptY + 2, cryptRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw main circle with owner's color
                    ctx.fillStyle = ownerColor || '#000000';
                    ctx.beginPath();
                    ctx.arc(pos.x, cryptY, cryptRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw white border for better visibility
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw 'C' text
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 20px Arial'; // Slightly larger font
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('C', pos.x, cryptY + 2);
                }
                
                ctx.restore(); // Restore context state
            }
        }
    }
}

// Function to draw rent prices as the final top layer (always on top of everything)
function drawRentPrices(ctx) {
    if (!positionsMap) return;

    for (const [square, state] of Object.entries(propertyState)) {
        if (!state.owner) continue;

        const pos = positionsMap.get(square);
        if (!pos) continue;

        // Calculate current rent for this property
        const propertyInfo = getPropertyInfo(square);
        if (!propertyInfo) continue;

        const rentInfo = calculateRent(propertyInfo);
        const currentRent = rentInfo.amount;

        // Draw rent price - always position it in the center of the property position
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const rentText = `Â£${currentRent}`;
        const rentWidth = ctx.measureText(rentText).width;
        
        // Position rent in the center of the property position (not above it)
        const rentY = pos.y; // Center on the property position
        
        // Draw background rectangle
        ctx.fillRect(pos.x - rentWidth/2 - 4, rentY - 8, rentWidth + 8, 16);

        // Draw rent text
        ctx.fillStyle = '#ffff00'; // Bright yellow
        ctx.fillText(rentText, pos.x, rentY);
    }
}

// Global variable to store the spades image for steal cards
let spadesImage = null;
let spadesImageLoaded = false;

// Global variable to store the moneybag image for snake path money
let moneybagImage = null;
let moneybagImageLoaded = false;

// Function to draw snake path money with pulsing red background and yellow font
function drawSnakePathMoney(ctx) {
    const currentTime = Date.now();
    
    // Draw money on each snake path position
    Object.keys(snakePathMoney).forEach(square => {
        if (!snakePathMoney[square].collected) {
            const pos = positionsMap.get(square);
            if (pos) {
                // Update pulse phase for animation
                if (!snakePathMoney[square].pulsePhase) {
                    snakePathMoney[square].pulsePhase = 0;
                }
                snakePathMoney[square].pulsePhase = (currentTime * 0.003) % (Math.PI * 2);
                
                const isStealCard = snakePathMoney[square].isStealCard;
                const isLightningBoltPrize = snakePathMoney[square].isLightningBolt;
                
                // Calculate pulsing effects
                const pulseValue = Math.abs(Math.sin(snakePathMoney[square].pulsePhase));
                const opacity = 0.8 + (pulseValue * 0.2); // Opacity pulses from 0.8 to 1.0
                
                if (isStealCard) {
                    // For steal cards, draw spades image with background
                    const imageSize = 24 + (pulseValue * 8); // Larger size for better visibility (24-32px)
                    const padding = 8; // Larger padding for steal cards
                    
                    // Draw black background with pulsing intensity
                    const bgX = pos.x - (imageSize / 2) - padding;
                    const bgY = pos.y - (imageSize / 2) - padding;
                    const bgWidth = imageSize + (padding * 2);
                    const bgHeight = imageSize + (padding * 2);
                    
                    ctx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
                    ctx.fillRect(bgX, bgY, bgWidth, bgHeight);
                    
                    // Add white border for steal cards for better visibility on black background
                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(bgX, bgY, bgWidth, bgHeight);
                    
                    // Draw spades image if loaded, otherwise fallback to emoji
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    
                    if (spadesImageLoaded && spadesImage) {
                        // Draw the spades image
                        ctx.drawImage(
                            spadesImage,
                            pos.x - (imageSize / 2),
                            pos.y - (imageSize / 2),
                            imageSize,
                            imageSize
                        );
                    } else {
                        // Fallback to emoji if image not loaded
                        const fontSize = imageSize * 0.8; // Make emoji slightly smaller than the background
                        ctx.fillStyle = '#ffffff';
                        ctx.font = `bold ${fontSize}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('ðŸƒ', pos.x, pos.y);
                    }
                    ctx.restore();
                } else if (isLightningBoltPrize) {
                    // For lightning bolts, draw bolt icon with glowing background
                    const imageSize = 28 + (pulseValue * 10); // 28-38px
                    const padding = 8;

                    // Glowing yellow background
                    const bgX = pos.x - (imageSize / 2) - padding;
                    const bgY = pos.y - (imageSize / 2) - padding;
                    const bgWidth = imageSize + (padding * 2);
                    const bgHeight = imageSize + (padding * 2);

                    ctx.fillStyle = `rgba(255, 255, 0, ${opacity * 0.6})`;
                    ctx.fillRect(bgX, bgY, bgWidth, bgHeight);
                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(bgX, bgY, bgWidth, bgHeight);

                    ctx.save();
                    ctx.globalAlpha = opacity;
                    if (lightningBoltImageLoaded && lightningBoltImage) {
                        ctx.drawImage(
                            lightningBoltImage,
                            pos.x - (imageSize / 2),
                            pos.y - (imageSize / 2),
                            imageSize,
                            imageSize
                        );
                    } else {
                        const fontSize = imageSize * 0.9;
                        ctx.fillStyle = '#ffff00';
                        ctx.font = `bold ${fontSize}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('âš¡', pos.x, pos.y);
                    }
                    ctx.restore();
                } else {
                    // For money, use moneybag image with overlaid text
                    const text = `Â£${snakePathMoney[square].amount}`;
                    const imageSize = 45 + (pulseValue * 11); // Size for moneybag (45-56px) - 40% larger
                    
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    
                    if (moneybagImageLoaded && moneybagImage) {
                        // Draw the moneybag image
                        ctx.drawImage(
                            moneybagImage,
                            pos.x - (imageSize / 2),
                            pos.y - (imageSize / 2),
                            imageSize,
                            imageSize
                        );
                        
                        // Draw amount text overlaid on the moneybag (smaller red font, positioned lower)
                        const fontSize = 12 + (pulseValue * 2); // Smaller font size (12-14px)
                        const textYOffset = 8; // Move text 8 pixels lower than center
                        ctx.fillStyle = '#ff0000'; // Red text as requested
                        ctx.strokeStyle = '#ffffff'; // White outline for better visibility on any background
                        ctx.lineWidth = 2; // Thicker outline for better contrast
                        ctx.font = `bold ${fontSize}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        // Draw text with outline for better visibility (positioned lower)
                        ctx.strokeText(text, pos.x, pos.y + textYOffset);
                        ctx.fillText(text, pos.x, pos.y + textYOffset);
                    } else {
                        // Fallback to original text-based approach if moneybag image not loaded
                        const fontSize = 14 + (pulseValue * 3); // Smaller font size (14-17px)
                        
                        // Measure text for background sizing
                        ctx.font = `bold ${fontSize}px Arial`;
                        const textMetrics = ctx.measureText(text);
                        const textWidth = textMetrics.width;
                        const textHeight = fontSize * 1.2;
                        
                        // Draw background rectangle (adjusted for lower text position)
                        const padding = 8; // Larger padding for bigger text
                        const textYOffset = 8; // Match the text offset
                        const bgX = pos.x - (textWidth / 2) - padding;
                        const bgY = (pos.y + textYOffset) - (textHeight / 2) - padding;
                        const bgWidth = textWidth + (padding * 2);
                        const bgHeight = textHeight + (padding * 2);
                        
                        // Black background with pulsing intensity for better contrast
                        ctx.fillStyle = `rgba(0, 0, 0, ${opacity * 0.8})`;
                        ctx.fillRect(bgX, bgY, bgWidth, bgHeight);
                        
                        // Draw red text with white outline for better visibility (positioned lower)
                        // textYOffset already declared above
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.fillStyle = '#ff0000'; // Red text as requested
                        ctx.font = `bold ${fontSize}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.strokeText(text, pos.x, pos.y + textYOffset);
                        ctx.fillText(text, pos.x, pos.y + textYOffset);
                    }
                    
                    ctx.restore();
                }
            }
        }
    });
}

// Ensure every other snake path prize is a lightning bolt by alternating order
function enforceAlternatingBoltPrizes() {
    try {
        const entries = Object.keys(snakePathMoney);
        if (!entries || entries.length === 0) return;
        // Sort by snake path order if possible: prefer TT1..TT19 then s1..s19, else by name
        const orderVal = (sq) => {
            const m1 = /^TT(\d+)$/.exec(sq);
            const m2 = /^s(\d+)$/.exec(sq);
            if (m1) return 1000 + parseInt(m1[1], 10);
            if (m2) return 2000 + parseInt(m2[1], 10);
            return 3000 + sq.charCodeAt(0);
        };
        entries.sort((a, b) => orderVal(a) - orderVal(b));
        let toggle = false;
        for (const sq of entries) {
            const item = snakePathMoney[sq];
            if (!item || item.collected) continue;
            // Alternate: false -> money (or leave as is), true -> bolt
            if (toggle) {
                item.isLightningBolt = true;
                // When bolt, it should not be treated as steal card or money
                item.isStealCard = false;
                // Optional: ensure amount not shown for bolt
            } else {
                // Ensure not bolt for the alternating pattern
                item.isLightningBolt = false;
            }
            toggle = !toggle;
        }
    } catch (e) {
        console.warn('enforceAlternatingBoltPrizes failed:', e?.message || e);
    }
}

// Add function to load development images
async function loadDevelopmentImages() {
    try {
        // Load legacy grave image (for compatibility)
        graveImage = new Image();
        graveImage.src = 'assets/images/crosspng.png'; // Using crosspng.png for grave marker
        await new Promise((resolve) => {
            graveImage.onload = () => {
                graveImageLoaded = true;
                resolve();
            };
            graveImage.onerror = () => {
                console.warn('Failed to load grave image, will use fallback');
                graveImageLoaded = false;
                resolve();
            };
        });

        // Load numbered graveyard images
        const graveyardImages = [
            { image: 'grave1Image', src: 'assets/images/1grave.png', loaded: 'grave1ImageLoaded' },
            { image: 'grave2Image', src: 'assets/images/2grave.png', loaded: 'grave2ImageLoaded' },
            { image: 'grave3Image', src: 'assets/images/3grave.png', loaded: 'grave3ImageLoaded' },
            { image: 'grave4Image', src: 'assets/images/4grave.png', loaded: 'grave4ImageLoaded' }
        ];

        for (const graveyard of graveyardImages) {
            window[graveyard.image] = new Image();
            window[graveyard.image].src = graveyard.src;
            await new Promise((resolve) => {
                window[graveyard.image].onload = () => {
                    window[graveyard.loaded] = true;
                    console.log(`âœ… Loaded ${graveyard.src}`);
                    resolve();
                };
                window[graveyard.image].onerror = () => {
                    console.warn(`Failed to load ${graveyard.src}, will use fallback`);
                    window[graveyard.loaded] = false;
                    resolve();
                };
            });
        }

        // Load crypt image (fallback)
        cryptImage = new Image();
        cryptImage.src = 'assets/images/crypt.png'; // Using crypt.png for crypt marker
        await new Promise((resolve) => {
            cryptImage.onload = () => {
                cryptImageLoaded = true;
                resolve();
            };
            cryptImage.onerror = () => {
                console.warn('Failed to load crypt image, will use fallback');
                cryptImageLoaded = false;
                resolve();
            };
        });

        // Load colored crypt images
        cryptRedImage = new Image();
        cryptRedImage.src = 'assets/images/cryptred.png';
        await new Promise((resolve) => {
            cryptRedImage.onload = () => {
                cryptRedImageLoaded = true;
                resolve();
            };
            cryptRedImage.onerror = () => {
                console.warn('Failed to load red crypt image, will use fallback');
                cryptRedImageLoaded = false;
                resolve();
            };
        });

        cryptBlueImage = new Image();
        cryptBlueImage.src = 'assets/images/cryptblue.png';
        await new Promise((resolve) => {
            cryptBlueImage.onload = () => {
                cryptBlueImageLoaded = true;
                resolve();
            };
            cryptBlueImage.onerror = () => {
                console.warn('Failed to load blue crypt image, will use fallback');
                cryptBlueImageLoaded = false;
                resolve();
            };
        });

        cryptGreenImage = new Image();
        cryptGreenImage.src = 'assets/images/cryptgreen.png';
        await new Promise((resolve) => {
            cryptGreenImage.onload = () => {
                cryptGreenImageLoaded = true;
                resolve();
            };
            cryptGreenImage.onerror = () => {
                console.warn('Failed to load green crypt image, will use fallback');
                cryptGreenImageLoaded = false;
                resolve();
            };
        });

        cryptYellowImage = new Image();
        cryptYellowImage.src = 'assets/images/cryptyellow.png';
        await new Promise((resolve) => {
            cryptYellowImage.onload = () => {
                cryptYellowImageLoaded = true;
                resolve();
            };
            cryptYellowImage.onerror = () => {
                console.warn('Failed to load yellow crypt image, will use fallback');
                cryptYellowImageLoaded = false;
                resolve();
            };
        });

        cryptWhiteImage = new Image();
        cryptWhiteImage.src = 'assets/images/cryptwhite.png';
        await new Promise((resolve) => {
            cryptWhiteImage.onload = () => {
                cryptWhiteImageLoaded = true;
                resolve();
            };
            cryptWhiteImage.onerror = () => {
                console.warn('Failed to load white crypt image, will use fallback');
                cryptWhiteImageLoaded = false;
                resolve();
            };
        });

        // Load spades image for steal cards
        spadesImage = new Image();
        spadesImage.src = 'assets/images/spades.png'; // Using spades.png for steal card marker
        await new Promise((resolve) => {
            spadesImage.onload = () => {
                spadesImageLoaded = true;
                resolve();
            };
            spadesImage.onerror = () => {
                console.warn('Failed to load spades image, will use fallback');
                spadesImageLoaded = false;
                resolve();
            };
        });

        // Load moneybag image for snake path money
        moneybagImage = new Image();
        moneybagImage.src = 'assets/images/moneybag.png'; // Using moneybag.png for money display
        await new Promise((resolve) => {
            moneybagImage.onload = () => {
                moneybagImageLoaded = true;
                resolve();
            };
            moneybagImage.onerror = () => {
                console.warn('Failed to load moneybag image, will use fallback');
                moneybagImageLoaded = false;
                resolve();
            };
        });

        // Load lightning bolt image for snake path bolt prize (optional)
        lightningBoltImage = new Image();
        lightningBoltImage.src = 'assets/images/lightning-bolt.png';
        await new Promise((resolve) => {
            lightningBoltImage.onload = () => {
                lightningBoltImageLoaded = true;
                resolve();
            };
            lightningBoltImage.onerror = () => {
                console.warn('Failed to load lightning-bolt image, will use emoji fallback');
                lightningBoltImageLoaded = false;
                resolve();
            };
        });
    } catch (error) {
        console.error('Error loading development images:', error);
    }
}

// Global variable to track property group highlighting
let propertyGroupHighlightActive = false;
let highlightedProperties = [];
let highlightAnimationTimer = null;
let highlightPlayerColor = '#ff0000'; // Store the current player's color for highlighting

// Function to highlight properties in the same group when player lands on one
function highlightPropertyGroup(player, propertyInfo) {
    // Clear any existing highlights first
    clearPropertyGroupHighlight();
    
    if (!propertyInfo || !propertyInfo.group) {
        console.log('[highlightPropertyGroup] No property group found for this square.');
        return;
    }
    
    const currentGroup = propertyInfo.group;
    const groupInfo = propertyGroups[currentGroup];
    
    if (!groupInfo) {
        console.log(`[highlightPropertyGroup] Group info not found for ${currentGroup}.`);
        return;
    }
    
    // Find all properties in this group that the player owns (excluding the current one)
    const ownedPropertiesInGroup = groupInfo.positions.filter(position => {
        const state = propertyState[position];
        return state && state.owner === player.name && position !== propertyInfo.square;
    });
    
    if (ownedPropertiesInGroup.length === 0) {
        console.log(`[highlightPropertyGroup] Player ${player.name} doesn't own any other properties in ${currentGroup} group.`);
        return;
    }
    
    console.log(`[highlightPropertyGroup] Player ${player.name} owns ${ownedPropertiesInGroup.length} other properties in ${currentGroup} group:`, ownedPropertiesInGroup);
    
    // Activate highlighting
    propertyGroupHighlightActive = true;
    highlightedProperties = ownedPropertiesInGroup;
    highlightPlayerColor = player.color || getPlayerColor(player.name);
    
    // Show advisory message
    const groupDisplayName = currentGroup.charAt(0).toUpperCase() + currentGroup.slice(1);
    const playerColorName = player.colorName || 'their color';
    showAdvisory(`${player.name} owns ${ownedPropertiesInGroup.length} other ${groupDisplayName} properties! They are now highlighted in ${playerColorName}.`, 'info');
    
    // Start animation timer for pulsing effect
    startHighlightAnimation();
    
    console.log(`[highlightPropertyGroup] Activated ${playerColorName} glow (${highlightPlayerColor}) for ${ownedPropertiesInGroup.length} ${currentGroup} properties owned by ${player.name}.`);
}

// Function to start highlight animation timer
function startHighlightAnimation() {
    // Clear any existing timer
    if (highlightAnimationTimer) {
        clearInterval(highlightAnimationTimer);
    }
    
    // Update every 100ms for smooth pulsing animation
    highlightAnimationTimer = setInterval(() => {
        if (propertyGroupHighlightActive) {
            updateGameFrame();
        } else {
            // Stop timer if highlighting is no longer active
            clearInterval(highlightAnimationTimer);
            highlightAnimationTimer = null;
        }
    }, 100);
}

// Function to clear property group highlighting
function clearPropertyGroupHighlight() {
    if (propertyGroupHighlightActive) {
        console.log('[clearPropertyGroupHighlight] Clearing property group highlights.');
        propertyGroupHighlightActive = false;
        highlightedProperties = [];
        
        // Clear animation timer
        if (highlightAnimationTimer) {
            clearInterval(highlightAnimationTimer);
            highlightAnimationTimer = null;
        }
        
        updateGameFrame(); // Refresh to remove highlights
    }
}

// After movement is complete, handle property landing
async function handlePropertyLanding(player, propertyInfo) {
    console.log(`[handlePropertyLanding] *** CALLED *** for player: ${player.name} on square: ${propertyInfo.square}. Player is AI: ${player.isAI}.`);
    
    if (!propertyInfo) {
        console.error('[handlePropertyLanding] CRITICAL: propertyInfo is undefined. Aborting.');
        return;
    }
    if (!player) {
        console.error('[handlePropertyLanding] CRITICAL: player object is undefined. Aborting.');
        return;
    }

    // Check if player owns other properties in the same group and highlight them
    highlightPropertyGroup(player, propertyInfo);

    const state = propertyInfo.state;
    const displayName = getPropertyDisplayName(propertyInfo);
    console.log(`[handlePropertyLanding] Property: ${displayName}, Owner: ${state.owner || 'None'}.`);

    if (state.owner && state.owner !== player.name) {
        console.log(`[handlePropertyLanding] Property owned by ${state.owner}. ${player.name} needs to pay rent.`);
        const rentInfo = calculateRent(propertyInfo);
        console.log(`[handlePropertyLanding] Calculated rent: Â£${rentInfo.amount}`);
        const owner = players.find(p => p.name.toLowerCase() === (state.owner || '').toLowerCase());
        
        if (owner) {
            console.log(`[handlePropertyLanding] BEFORE rent payment - ${player.name}: Â£${player.money}, ${owner.name}: Â£${owner.money}`);
            // Always deduct rent, even if it makes player go negative (bankruptcy)
            player.money -= rentInfo.amount;
            owner.money += rentInfo.amount;
            console.log(`[handlePropertyLanding] AFTER rent payment - ${player.name}: Â£${player.money}, ${owner.name}: Â£${owner.money}`);
            console.log(`[handlePropertyLanding] âœ… RENT SUCCESSFULLY DEDUCTED: Â£${rentInfo.amount}`);
            
            // Check for bankruptcy after payment
            if (player.money < 0) {
                player.money = 0;
                player.bankrupt = true;
                console.log(`[handlePropertyLanding] ${player.name} went bankrupt paying Â£${rentInfo.amount} rent to ${owner.name}.`);
                showAdvisory(`${player.name} went bankrupt paying Â£${rentInfo.amount} rent for ${displayName}! Game Over for ${player.name}!`, 'payment');
                await playScreamSound();
            } else {
                checkBankruptcy(player);
            }
            console.log(`[handlePropertyLanding] ${player.name} paid Â£${rentInfo.amount} to ${owner.name}. ${player.name} money: ${player.money}, ${owner.name} money: ${owner.money}.`);
            
            // Sync to Firebase immediately after rent payment in multiplayer mode
            if (isMultiplayerGame) {
                console.log('[handlePropertyLanding] Syncing rent payment to Firebase...');
                await syncGameStateToFirebase();
            }
            
            // Create enhanced rent payment message with highlighting
            let rentMessage = `<div style="text-align: center; padding: 5px;">`;
            rentMessage += `<div style="font-size: 13px; color: #fff; margin-bottom: 8px;">${player.name} landed on</div>`;
            rentMessage += `<div style="font-size: 15px; color: #ffaa00; font-weight: bold; margin-bottom: 8px;">${displayName}</div>`;
            rentMessage += `<div style="font-size: 12px; color: #ffaa00; margin-bottom: 10px;">Owned by ${owner.name}</div>`;
            
            // Highlighted rent payment message without amount
            rentMessage += `<div style="background: rgba(255, 0, 0, 0.3); border: 2px solid #ff0000; border-radius: 8px; padding: 8px; margin: 10px 0; animation: pulse 1s infinite;">`;
            rentMessage += `<div style="color: #ff4444; font-size: 16px; font-weight: bold; text-shadow: 0 0 8px #ff4444;">ðŸ’° RENT PAID ðŸ’°</div>`;
            rentMessage += `</div>`;
            rentMessage += `</div>`;
            
            showAdvisory(rentMessage, 'payment');
            await playBellSound();
            
            // Pause for 1.5 seconds to let the rent message be seen
            await new Promise(resolve => setTimeout(resolve, 1500));
            
            // Update UI to reflect the money changes after rent payment
            updateInfoPanel();
            await updateGameFrame();
        } else {
            console.error(`[handlePropertyLanding] CRITICAL: Property owner ${state.owner} not found in players array.`);
        }
    } else if (!state.owner && !player.isAI) {
        console.log(`[handlePropertyLanding] Property ${displayName} is unowned. ${player.name} (Human) can purchase for Â£${propertyInfo.cost}.`);
        
        // Use AI strategy to analyze if this is a good purchase for human player
        const shouldBuy = calculateAIPurchaseStrategy(propertyInfo);
        if (shouldBuy) {
            // Add pulsing effect to the player's name in the info panel
            showAdvisory(`AI Analysis: This is a good property to buy!`, 'recommendation');
            // Add CSS for pulsing animation if it doesn't exist
            const style = document.createElement('style');
            style.textContent = `
                @keyframes pulse-green {
                    0% { text-shadow: 0 0 5px #4CAF50; }
                    50% { text-shadow: 0 0 20px #4CAF50; }
                    100% { text-shadow: 0 0 5px #4CAF50; }
                }
                .player-name-pulse {
                    animation: pulse-green 2s infinite;
                }
            `;
            document.head.appendChild(style);
            
            // Find and pulse the current player's name
                        const playerNameSpan = document.querySelector(`.player-name[data-player="${player.name}"]`);
            if (playerNameSpan) {
                playerNameSpan.classList.add('player-name-pulse');
                // Remove the pulse after 10 seconds
                setTimeout(() => playerNameSpan.classList.remove('player-name-pulse'), 10000);
            }
        }
        
        showAdvisory(`${player.name} can purchase ${displayName}`, 'info');
        // Mark a pending property decision so UI can be forced even if turn/movement flags are desynced
        try {
            if (typeof window !== 'undefined') {
                window.pendingPropertyDecision = {
                    playerName: player.name,
                    square: propertyInfo.square,
                    createdAt: Date.now(),
                    turnIndex: currentPlayerIndex
                };
                console.log('[handlePropertyLanding] Set pendingPropertyDecision:', window.pendingPropertyDecision);
            }
        } catch (e) {
            console.warn('[handlePropertyLanding] Could not set pendingPropertyDecision:', e);
        }
        updateInfoPanel(null, null, propertyInfo); // Show purchase buttons
        
        // IMMEDIATE FIX: Force immediate property purchase UI display
        console.log('[handlePropertyLanding] ðŸš¨ IMMEDIATE: Forcing property purchase UI display');
        setTimeout(() => {
            updateInfoPanel(null, null, propertyInfo);
        }, 10);
        
        // CRITICAL FIX: Ensure property purchase UI is immediately visible
        // Force the property info content to be populated if it's empty
        setTimeout(() => {
            let propertyInfoContent = document.getElementById('property-info-content');
            
            // Create element if it doesn't exist
            if (!propertyInfoContent) {
                console.log('[handlePropertyLanding] ðŸš¨ EMERGENCY: property-info-content element missing, creating it');
                propertyInfoContent = document.createElement('div');
                propertyInfoContent.id = 'property-info-content';
                
                const infoPanelContent = document.getElementById('info-panel-content');
                if (infoPanelContent) {
                    infoPanelContent.appendChild(propertyInfoContent);
                } else {
                    document.body.appendChild(propertyInfoContent);
                }
            }
            
            if (propertyInfoContent && (!propertyInfoContent.innerHTML || propertyInfoContent.innerHTML.trim() === '')) {
                console.log('[handlePropertyLanding] ðŸš¨ EMERGENCY: Property purchase UI not showing, forcing display');
                updateInfoPanel(null, null, propertyInfo);
                
                // Wait a bit more and check again
                setTimeout(() => {
                    if (!propertyInfoContent.innerHTML || propertyInfoContent.innerHTML.trim() === '') {
                        // Check if player just landed on property (not sitting there)
                        const playerJustLanded = player.isMoving || 
                            (player.movementTimestamp && Date.now() - player.movementTimestamp < 10000);
                        
                        if (playerJustLanded) {
                            console.log('[handlePropertyLanding] ðŸš¨ EMERGENCY: Still no UI, adding fallback purchase buttons');
                            const currentPlayerIndex = players.findIndex(p => p.name === player.name);
                            addEmergencyPurchaseButtons(propertyInfo, player, currentPlayerIndex);
                        } else {
                            console.log('[handlePropertyLanding] ðŸš« Player has been sitting on property - not showing emergency purchase UI');
                        }
                    }
                }, 50);
            }
        }, 100);
        
        updateGameFrame();
        
        const diceSection = document.getElementById('dice-section');
        if (diceSection) {
            // Check if player rolled doubles - if so, keep dice clickable in minimized mode
            const infoPanel = document.getElementById('info-panel');
            const isMinimized = infoPanel && infoPanel.classList.contains('minimized');
            
            if (isMinimized && lastRollWasDoubles) {
                console.log('[handlePropertyLanding] Player rolled doubles in minimized mode - keeping dice clickable');
                // Keep dice clickable but use player's color for pulse
                removeAllDicePulseClasses(diceSection);
                const currentPlayer = players[currentPlayerIndex];
                const playerPulseClass = getPlayerDicePulseClassByPlayer(currentPlayer);
                diceSection.classList.add(playerPulseClass); // Use player's color for doubles
                console.log(`[handlePropertyLanding] Applied player color pulse for doubles: ${playerPulseClass}`);
                // Don't set pointerEvents to none - keep it clickable
            } else {
            console.log('[handlePropertyLanding] Disabling dice section (pointerEvents: none, class: dice-pulse-red) for human purchase decision.');
            diceSection.style.pointerEvents = 'none';
            removeAllDicePulseClasses(diceSection);
            diceSection.classList.add('dice-pulse-red'); // Keep red for disabled state
            }
        } else {
            console.error('[handlePropertyLanding] CRITICAL: Dice section not found when trying to disable for purchase.');
        }
        console.log('[handlePropertyLanding] Human purchase decision pending. Turn flow paused, awaiting button click (handlePropertyPurchase/handleDeclinePurchase).');
        
        // Start 5-second timer for auto-decline if no action taken
        startAutoActionTimer('purchase');
    } else if (!state.owner && player.isAI) {
        console.log(`[handlePropertyLanding] Property ${displayName} is unowned. ${player.name} (AI) will consider purchasing.`);
        // AI purchase logic was moved primarily to handleAITurn after landing.
        // However, if called from a different context, direct AI purchase can be reconsidered here
        // For now, let's assume AI purchase decision is made within handleAITurn or a dedicated AI purchase function called from there.
        // If AI lands here as part of its move in handleAITurn, handleAITurn will proceed to make purchase decisions.
        // If an AI were to land here outside of its main turn logic (less likely), it needs a path forward.
        // Re-evaluating if AI purchase logic should be triggered here more directly.
        // The `handleAIPropertyPurchase` function exists but is more of a sub-routine for `handleAITurn`.
        // For now, `handleAITurn` calls `handlePropertyLanding`, then makes its own purchase evaluation.
        console.log(`[handlePropertyLanding] AI ${player.name} on unowned. Purchase logic is managed by the calling AI turn sequence (handleAITurn).`);
    } else if (state.owner === player.name) {
        console.log(`[handlePropertyLanding] ${player.name} landed on their own property: ${displayName}. No action.`);
    } else {
        console.log(`[handlePropertyLanding] Unhandled case for player ${player.name} on ${displayName}. Owner: ${state.owner}.`);
    }
    console.log('[handlePropertyLanding] Completed.');
}

function updateTurnInfo() {
    // Check if we have valid players and current player index
    if (!Array.isArray(players) || players.length === 0 || currentPlayerIndex < 0 || currentPlayerIndex >= players.length) {
        console.log('updateTurnInfo: No valid players or currentPlayerIndex');
        return;
    }

    const currentPlayer = players[currentPlayerIndex];
    if (!currentPlayer) {
        console.log('updateTurnInfo: Current player is undefined');
        return;
    }

    let turnInfo = document.getElementById('turn-info');
    const diceRollInfo = document.getElementById('dice-roll-info');
    
    // If turn-info element doesn't exist, create it
    if (!turnInfo) {
        console.log('âš ï¸ turn-info element not found, creating it...');
        
        // Try to find the info-panel-content to insert the turn-info element
        const infoPanelContent = document.getElementById('info-panel-content');
        if (infoPanelContent) {
            // Create the turn-info element
            turnInfo = document.createElement('h3');
            turnInfo.id = 'turn-info';
            turnInfo.className = 'turn-info';
            turnInfo.style.cssText = `
                margin: 5px 0;
                padding: 5px;
                text-align: center;
                font-size: 14px;
                font-weight: bold;
                color: #fff;
                text-shadow: 0 0 4px #00ff00;
                background: rgba(0, 0, 0, 0.7);
                border-radius: 5px;
                border: 1px solid #00ff00;
                box-shadow: 0 0 8px rgba(0, 255, 0, 0.3);
            `;
            
            // Insert it before the dice section if it exists, otherwise just append
            const diceSection = document.getElementById('dice-section');
            if (diceSection && diceSection.parentElement === infoPanelContent) {
                infoPanelContent.insertBefore(turnInfo, diceSection);
            } else {
                infoPanelContent.appendChild(turnInfo);
            }
            
            console.log('âœ… turn-info element created and inserted');
        } else {
            console.error('âŒ Could not find info-panel-content to insert turn-info');
        return;
        }
    }
    
    turnInfo.textContent = `${currentPlayer.name}'s Turn`;
    turnInfo.style.display = 'block'; // Show the turn info initially
    
    // Add Fire Bolt button for current player
    try {
        const infoPanelContent = document.getElementById('info-panel-content');
        if (infoPanelContent) {
            let fireBtn = document.getElementById('fire-bolt-btn');
            if (!fireBtn) {
                fireBtn = document.createElement('button');
                fireBtn.id = 'fire-bolt-btn';
                fireBtn.style.cssText = `margin: 4px auto; display: block; background: #ffeb3b; color: #000; border: 1px solid #fbc02d; padding: 3px 6px; border-radius: 3px; cursor: pointer; font-family: 'Courier New', monospace; font-weight: bold; font-size: 11px; text-shadow: 0 0 2px #fff;`;
                fireBtn.textContent = 'âš¡ Fire Bolt';
                fireBtn.onclick = () => toggleBoltTargetingMode();
                infoPanelContent.insertBefore(fireBtn, infoPanelContent.firstChild);
            }
            // Enable only if player has bolts and it's a human player's turn
            const cp = players[currentPlayerIndex];
            const canUse = cp && !cp.isAI && (cp.lightningBolts || 0) > 0;
            fireBtn.style.display = canUse ? 'block' : 'none';
        }
    } catch (_) {}
    
    // Clear dice roll info to prevent duplicate turn display
    if (diceRollInfo) {
        diceRollInfo.textContent = '';
    }
    
    // Clear the turn info after 3 seconds if it's not the initial roll
    if (!isInitialRoll) {
        setTimeout(() => {
            if (turnInfo) {
            turnInfo.style.display = 'none';
            }
        }, 3000);
    }
}

// Add a flag to prevent multiple simultaneous nextTurn calls
let isNextTurnInProgress = false;

// Store AI turn timeout to allow clearing
let aiTurnTimeout = null;

// Add a timestamp to prevent rapid duplicate nextTurn calls
let lastNextTurnTime = 0;
const NEXT_TURN_COOLDOWN = 500; // 0.5 second cooldown between nextTurn calls

function nextTurn() {
    // Clear any stored property info when turn changes
    currentPropertyInfo = null;
    
    // Reset dice click protection counters for new turn
    diceClickCount = 0;
    turnInProgress = false;
    console.log('ðŸ”„ Dice click counters reset for new turn');
    clearAutoActionTimer(); // Clear auto-action timer from previous turn
    // Clear any pending property decision on turn change
    try {
        if (typeof window !== 'undefined' && window.pendingPropertyDecision) {
            console.log('[nextTurn] Clearing pendingPropertyDecision on turn change:', window.pendingPropertyDecision);
            window.pendingPropertyDecision = null;
        }
    } catch (e) {
        console.warn('[nextTurn] Could not clear pendingPropertyDecision:', e);
    }
    
    // Check for rapid duplicate calls FIRST, before any other processing
    const currentTime = Date.now();
    const timeSinceLastCall = currentTime - lastNextTurnTime;
    
    console.log(`[nextTurn] TIMING CHECK: Current time: ${currentTime}, Last call: ${lastNextTurnTime}, Time since last: ${timeSinceLastCall}ms, Cooldown: ${NEXT_TURN_COOLDOWN}ms`);
    
    if (timeSinceLastCall < NEXT_TURN_COOLDOWN && lastNextTurnTime > 0) {
        console.warn(`[nextTurn] BLOCKED rapid duplicate call - only ${timeSinceLastCall}ms since last call. Minimum cooldown: ${NEXT_TURN_COOLDOWN}ms`);
        return; // Exit immediately
    }
    
    const nextTurnId = Math.random().toString(36).substr(2, 9);
    
    debugLog('NEXT_TURN_START', `nextTurn Called [ID: ${nextTurnId}]`, {
        nextTurnId,
        currentPlayerIndex,
        currentPlayerName: players[currentPlayerIndex]?.name,
        isNextTurnInProgress,
        totalPlayers: players.length
    });
    
    console.log('[nextTurn] Called.');
    

    
    // Check if we're already processing a turn change
    if (isNextTurnInProgress) {
        console.log('[nextTurn] Turn change already in progress. Skipping to prevent race condition.');
        
        debugLog('NEXT_TURN_BLOCKED', 'nextTurn blocked - already in progress', {
            nextTurnId,
            reason: 'race_condition_prevention'
        });
        
        return;
    }
    
    // Update the last call timestamp
    lastNextTurnTime = currentTime;
    console.log(`[nextTurn] Updated lastNextTurnTime to: ${lastNextTurnTime}`);
    
    // Set the flag to prevent concurrent calls
    isNextTurnInProgress = true;
    
    // Clear any pending AI turn timeout from previous turn
    if (aiTurnTimeout) {
        clearTimeout(aiTurnTimeout);
        aiTurnTimeout = null;
        debugLog('AI_TIMEOUT_CLEARED', 'Cleared pending AI turn timeout from previous turn', {
            nextTurnId,
            reason: 'turn_transition'
        });
    }
    
    if (isGameOver) {
        console.log('[nextTurn] Game over detected. Exiting.');
        
        // Clear AI timeout on game end
        if (aiTurnTimeout) {
            clearTimeout(aiTurnTimeout);
            aiTurnTimeout = null;
        }
        
        isNextTurnInProgress = false; // Reset flag
        return;
    }
    clearAutoRollTimer();
    // Clear property group highlighting from previous turn
    clearPropertyGroupHighlight();
    // Revert to standard minimized state if we're in property-decision mode
    revertToStandardMinimized();
    
    // Ensure dice stays in minimized content if panel is minimized
    ensureDiceInMinimizedContent();
    
    // Note: We no longer clear declined property states here - they persist until player leaves/re-enters property
    
    // Validate players array first
    if (!Array.isArray(players) || players.length === 0) {
        console.error('[nextTurn] Critical error: players array is invalid:', players);
        showAdvisory('Game error: No players found. Please restart the game.', 'error');
        isNextTurnInProgress = false; // Reset flag
        return;
    }
    
    // Check all players for bankruptcy before advancing turn
    console.log('[nextTurn] Checking all players for bankruptcy before advancing turn.');
    checkAllPlayersBankruptcy();
    
    // Use the proper function to get next eligible (non-bankrupt) player
    const previousPlayerIndex = currentPlayerIndex;
    const previousPlayerName = players[currentPlayerIndex]?.name;
    
    console.log(`[nextTurn] BEFORE getNextEligiblePlayerIndex: currentPlayerIndex=${currentPlayerIndex}, player=${previousPlayerName}`);
    console.log(`[nextTurn] Players array:`, players.map((p, i) => `${i}: ${p.name} (bankrupt: ${p.bankrupt})`));
    
    currentPlayerIndex = getNextEligiblePlayerIndex(currentPlayerIndex);
    
    console.log(`[nextTurn] AFTER getNextEligiblePlayerIndex: currentPlayerIndex=${currentPlayerIndex}, player=${players[currentPlayerIndex]?.name}`);
    
    debugLog('PLAYER_TRANSITION', `Player transition: ${previousPlayerName} (${previousPlayerIndex}) â†’ ${players[currentPlayerIndex]?.name} (${currentPlayerIndex})`, {
        nextTurnId,
        previousPlayerIndex,
        previousPlayerName,
        newPlayerIndex: currentPlayerIndex,
        newPlayerName: players[currentPlayerIndex]?.name,
        newPlayerIsAI: players[currentPlayerIndex]?.isAI
    });
    
    // Additional validation after getting next player index
    if (currentPlayerIndex < 0 || currentPlayerIndex >= players.length) {
        console.error('[nextTurn] Critical error: currentPlayerIndex out of bounds:', currentPlayerIndex, 'Players count:', players.length);
        
        debugLog('NEXT_TURN_ERROR', 'currentPlayerIndex out of bounds', {
            nextTurnId,
            currentPlayerIndex,
            playersCount: players.length,
            error: 'index_out_of_bounds'
        });
        
        currentPlayerIndex = 0; // Reset to first player as fallback
    }
    
    const currentPlayer = players[currentPlayerIndex];
    
    if (!currentPlayer) {
        console.error('[nextTurn] Critical error: currentPlayer is undefined. Index:', currentPlayerIndex, 'Players count:', players.length);
        console.error('[nextTurn] Players array:', players);
        
        debugLog('NEXT_TURN_ERROR', 'currentPlayer is undefined', {
            nextTurnId,
            currentPlayerIndex,
            playersCount: players.length,
            error: 'undefined_player'
        });
        
        // Try to recover by finding first valid player
        let foundValidPlayer = false;
        for (let i = 0; i < players.length; i++) {
            if (players[i] && !players[i].bankrupt) {
                console.log('[nextTurn] Recovering: Found valid player at index', i, ':', players[i].name);
                currentPlayerIndex = i;
                foundValidPlayer = true;
                break;
            }
        }
        
        if (!foundValidPlayer) {
            console.error('[nextTurn] No valid players found. Game may be in invalid state.');
            showAdvisory('Game error: No valid players found. Please restart the game.', 'error');
            isNextTurnInProgress = false; // Reset flag
            return;
        }
    }
    
    isAITurn = currentPlayer.isAI;
    
    console.log(`[nextTurn] Transitioning to player: ${currentPlayer.name}, Index: ${currentPlayerIndex}, Is AI: ${isAITurn}`);
    
    // Delay the "Next turn" message to allow rent/payment messages to be seen
    setTimeout(() => {
        showAdvisory(`Next turn: ${currentPlayer.name}`, 'turn');
    }, 2000); // 2 second delay to allow rent message to be visible
    
    updateTurnInfo();
    updateInfoPanel();
    
    console.log('[nextTurn] Calling enableDiceSection.');
    enableDiceSection(); 
    
    // Ensure dice is properly set up in minimized content after enabling
    // Note: ensureDiceInMinimizedContent will preserve the colors set by enableDiceSection
    ensureDiceInMinimizedContent(); 
    
    // Since we're using getNextEligiblePlayerIndex, the current player should never be bankrupt
    // But keep this check as a safety measure
    if (currentPlayer.bankrupt) {
        console.log(`[nextTurn] Player ${currentPlayer.name} is bankrupt. This should not happen with getNextEligiblePlayerIndex. Calling nextTurn() again.`);
        // Reset flag before recursive call
        isNextTurnInProgress = false;
        // Add a small delay to prevent rapid recursion if all players are bankrupt
        setTimeout(() => nextTurn(), 100); 
        return;
    }
    
    if (isAITurn) {
        console.log(`[nextTurn] Initiating AI turn for ${currentPlayer.name} in 1.5s.`);
        
        debugLog('AI_TURN_SCHEDULED', `AI turn scheduled for ${currentPlayer.name}`, {
            nextTurnId,
            playerName: currentPlayer.name,
            playerIndex: currentPlayerIndex,
            delay: '1.5s'
        });
        
        aiTurnTimeout = setTimeout(() => {
            // Clear the timeout reference since it's executing
            aiTurnTimeout = null;
            
            // Double-check the player is still AI before calling handleAITurn
            const currentPlayerAtCallback = players[currentPlayerIndex];
            if (currentPlayerAtCallback && currentPlayerAtCallback.isAI) {
                console.log(`[nextTurn] setTimeout callback: Calling handleAITurn for ${currentPlayerAtCallback.name} (verified AI).`);
                
                debugLog('AI_TURN_EXECUTED', `handleAITurn called for ${currentPlayerAtCallback.name}`, {
                    nextTurnId,
                    playerName: currentPlayerAtCallback.name,
                    playerIndex: currentPlayerIndex,
                    verified: 'true'
                });
                
            handleAITurn();
            } else {
                console.error(`[nextTurn] setTimeout callback: Player changed or is not AI! Current: ${currentPlayerAtCallback?.name}, isAI: ${currentPlayerAtCallback?.isAI}. Skipping handleAITurn.`);
                
                debugLog('AI_TURN_ERROR', `AI turn callback failed - player changed or not AI`, {
                    nextTurnId,
                    expectedPlayer: currentPlayer.name,
                    actualPlayer: currentPlayerAtCallback?.name,
                    actualIsAI: currentPlayerAtCallback?.isAI,
                    error: 'player_changed_or_not_ai'
                });
            }
        }, 1500);
    } else if (isMultiplayerGame) {
        console.log(`[nextTurn] Multiplayer human turn for ${currentPlayer.name}. No auto-roll timer needed.`);
        
        debugLog('MULTIPLAYER_HUMAN_TURN', `Multiplayer human turn for ${currentPlayer.name}`, {
            nextTurnId,
            playerName: currentPlayer.name,
            playerIndex: currentPlayerIndex,
            mode: 'manual_click'
        });
        
        // In multiplayer, players manually click to roll - no auto-roll timer
    } else {
        console.log(`[nextTurn] Initiating Human turn for ${currentPlayer.name} by calling startAutoRollTimer.`);
        
        debugLog('SINGLEPLAYER_HUMAN_TURN', `Single-player human turn for ${currentPlayer.name}`, {
            nextTurnId,
            playerName: currentPlayer.name,
            playerIndex: currentPlayerIndex,
            mode: 'auto_roll_timer'
        });
        
        startAutoRollTimer();
    }
    
    console.log('[nextTurn] Calling updateGameFrame.');
    updateGameFrame();
    
    // Clear manually declined properties for the new player when their turn starts
    // This ensures they can purchase properties they previously declined on different turns
    if (playerDeclinedProperties.has(currentPlayer.name)) {
        const declinedSet = playerDeclinedProperties.get(currentPlayer.name);
        const manuallyDeclined = Array.from(declinedSet).filter(prop => !prop.startsWith('auto_') && !prop.startsWith('dev_'));
        const autoDeclined = Array.from(declinedSet).filter(prop => prop.startsWith('auto_') || prop.startsWith('dev_'));
        
        // Clear manually declined properties (but keep auto-declined and development-declined)
        declinedSet.clear();
        autoDeclined.forEach(prop => declinedSet.add(prop));
        
        console.log(`[nextTurn] Cleared ${manuallyDeclined.length} manually declined properties for ${currentPlayer.name}, kept ${autoDeclined.length} auto/dev-declined properties`);
    }

    // Update info panel for the new player
    console.log('[nextTurn] Updating info panel for new player.');
    updateInfoPanel();
    
    // CRITICAL FIX: Delay Firebase sync to prevent race conditions during turn transitions
    if (isMultiplayerGame) {
        // Delay sync to allow UI updates to complete and prevent corruption
        setTimeout(() => {
            emergencySyncToFirebase(); // Turn changes need sync but not immediate
        }, 500); // 500ms delay to ensure all local state is consistent
    }
    
    console.log('[nextTurn] Completed.');
    
    debugLog('NEXT_TURN_END', `nextTurn completed successfully`, {
        nextTurnId,
        finalPlayerIndex: currentPlayerIndex,
        finalPlayerName: players[currentPlayerIndex]?.name,
        finalPlayerIsAI: players[currentPlayerIndex]?.isAI,
        isAITurn,
        isMultiplayerGame
    });
    
    // Reset the flag to allow future nextTurn calls
    isNextTurnInProgress = false;
}

// Add this function at the global scope, outside any other function
function toggleBoltTargetingMode() {
    const currentPlayer = players[currentPlayerIndex];
    if (!currentPlayer || currentPlayer.isAI) return;
    if ((currentPlayer.lightningBolts || 0) <= 0) {
        showAdvisory('No lightning bolts available.', 'info');
        return;
    }
    isBoltTargetingMode = !isBoltTargetingMode;
    if (isBoltTargetingMode) {
        showAdvisory('Bolt targeting ON: double-click/tap a property to strike.', 'turn');
    } else {
        showAdvisory('Bolt targeting OFF.', 'info');
    }
    updateGameFrame();
}

function handleLightningBoltFire(clickX, clickY) {
    try {
        const currentPlayer = players[currentPlayerIndex];
        if (!currentPlayer || currentPlayer.isAI) return;
        if ((currentPlayer.lightningBolts || 0) <= 0) {
            showAdvisory('No lightning bolts available.', 'info');
            isBoltTargetingMode = false;
            return;
        }
        if (!positionsMap || positionsMap.size === 0) {
            showAdvisory('Game positions not loaded yet.', 'error');
            return;
        }
        // Find closest property to click
        let bestSquare = null;
        let bestDist = Infinity;
        for (const [square, position] of positionsMap.entries()) {
            const dx = clickX - position.x;
            const dy = clickY - position.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            if (d < bestDist) {
                bestDist = d;
                bestSquare = square;
            }
        }
        if (!bestSquare || bestDist > 80) {
            showAdvisory('Tap closer to a property to strike it.', 'info');
            return;
        }
        // Spend a bolt
        currentPlayer.lightningBolts = (currentPlayer.lightningBolts || 0) - 1;
        isBoltTargetingMode = false;
        updateInfoPanel();
        updateGameFrame();
        
        // Update bottom player display to show new lightning bolt count
        if (typeof updateBottomPlayerDisplay === 'function') {
            updateBottomPlayerDisplay();
        }

        // Visuals and effect
        const pos = positionsMap.get(bestSquare);
        if (pos) {
            createLightningEffect(pos.x, pos.y);
        }
        createScorchMark(bestSquare);

        // Apply property effects
        (async () => {
            const msg = await applyLightningPropertyEffects(bestSquare);
            const info = getPropertyInfo(bestSquare);
            const name = info ? getPropertyDisplayNameWithoutNumber(info) : 'Unknown Location';
            let advisory = `âš¡ ${currentPlayer.name} fired a bolt at ${name}!`;
            if (msg) advisory += ` ${msg}`;
            showAdvisory(advisory, 'lightning');

            // Multiplayer syncs
            if (isMultiplayerGame) {
                try {
                    const pIdx = players.findIndex(p => p.name === currentPlayer.name);
                    if (pIdx !== -1) {
                        updatePlayerData(pIdx, { lightningBolts: currentPlayer.lightningBolts }).catch(() => {});
                    }
                    updatePropertyState(bestSquare, propertyState[bestSquare]).catch(() => {});
                    emergencySyncToFirebase();
                } catch (_) {}
            }
        })();
        playStrikeSound();
    } catch (e) {
        console.warn('Bolt fire failed:', e?.message || e);
        isBoltTargetingMode = false;
    }
}

// Expose helpers globally
window.toggleBoltTargetingMode = toggleBoltTargetingMode;
async function handlePropertyPurchase(square, playerIndex) {
    clearAutoActionTimer(); // Clear the auto-action timer since player took action
    
    const player = players[playerIndex];
    const propertyInfo = getPropertyInfo(square);

    console.log(`[handlePropertyPurchase] Called for square: ${square}, playerIndex: ${playerIndex}. Player: ${player ? player.name : 'N/A'}, Property: ${propertyInfo ? getPropertyDisplayName(propertyInfo) : 'N/A'}.`);

    if (!player) {
        console.error('[handlePropertyPurchase] CRITICAL: Player object is undefined for playerIndex:', playerIndex);
        return; 
    }
    if (!propertyInfo) {
        console.error(`[handlePropertyPurchase] CRITICAL: Property info not found for square: ${square}.`);
        return;
    }
    if (player.isAI) {
        console.warn(`[handlePropertyPurchase] WARNING: Human purchase function called for AI player ${player.name}. This should be handled by AI logic. Aborting.`);
        return;
    }
    
    // In multiplayer mode, verify it's actually this player's turn
    if (isMultiplayerGame) {
        const currentPlayer = players[currentPlayerIndex];
        let playerName = document.getElementById('player1-name').value.trim();
        
        // If player name is empty, try to get it from the stored local player name
        if (!playerName && window.localPlayerName) {
            playerName = window.localPlayerName;
        }
        
        // Check if this browser belongs to the current player by comparing names (case-insensitive)
        const isMyTurn = currentPlayer && currentPlayer.name.toLowerCase() === playerName.toLowerCase();
        
        if (!currentPlayer || !isMyTurn || playerIndex !== currentPlayerIndex) {
            console.warn(`[handlePropertyPurchase] Multiplayer validation failed. Current player: ${currentPlayer?.name}, Your name: ${playerName}, PlayerIndex: ${playerIndex}, CurrentPlayerIndex: ${currentPlayerIndex}`);
            showAdvisory("It's not your turn!", 'error');
            return;
        }
    }

    const displayName = getPropertyDisplayName(propertyInfo);
    console.log(`[handlePropertyPurchase] Player: ${player.name}, Current Money: Â£${player.money}, Property: ${displayName}, Cost: Â£${propertyInfo.cost}.`);

    if (player.bankrupt) {
        console.log(`[handlePropertyPurchase] Player ${player.name} is bankrupt. Cannot purchase.`);
        showAdvisory(`${player.name} is bankrupt and cannot purchase.`, 'error');
        return;
    }
    
    const state = propertyInfo.state;
    console.log(`[handlePropertyPurchase] Property state for ${square}:`, state);
    console.log(`[handlePropertyPurchase] Current propertyState for ${square}:`, propertyState[square]);
    
    if (state.owner) {
        console.warn(`[handlePropertyPurchase] Property ${displayName} already owned by ${state.owner}. Purchase attempt by ${player.name} denied.`);
        console.warn(`[handlePropertyPurchase] Property state owner: ${state.owner}, Player name: ${player.name}`);
        showAdvisory(`${displayName} is already owned by ${state.owner}.`, 'error');
        return;
    }
    if (player.money < propertyInfo.cost) {
        console.warn(`[handlePropertyPurchase] Player ${player.name} cannot afford ${displayName}. Money: Â£${player.money}, Cost: Â£${propertyInfo.cost}.`);
        showAdvisory(`${player.name} cannot afford to purchase ${displayName}.`, 'error');
        return;
    }

    console.log(`[handlePropertyPurchase] Purchase is valid. ${player.name} is purchasing ${displayName}.`);
    // Clear pending decision on success
    try {
        if (typeof window !== 'undefined' && window.pendingPropertyDecision && window.pendingPropertyDecision.square === square) {
            console.log('[handlePropertyPurchase] Clearing pendingPropertyDecision for', window.pendingPropertyDecision);
            window.pendingPropertyDecision = null;
        }
    } catch (e) {
        console.warn('[handlePropertyPurchase] Could not clear pendingPropertyDecision:', e);
    }
    player.money -= propertyInfo.cost;
    checkBankruptcy(player); // Important: check bankruptcy right after money deduction
    propertyState[square].owner = player.name;
    propertyState[square].declined = false;
    propertyState[square].ownerColor = player.color || getPlayerColor(player.name);
    propertyState[square].purchaseTimestamp = Date.now(); // Add local timestamp
    player.properties.push(square);
    console.log(`[handlePropertyPurchase] ðŸž LOCAL STATE UPDATED: ${square} owner is now ${propertyState[square].owner}`);
    console.log(`[handlePropertyPurchase] ${player.name} purchased ${displayName}. New money: Â£${player.money}. Properties:`, player.properties);
    
    // Check if this purchase completed a property set
    if (checkPropertySetCompletion(player, square)) {
        showAdvisory(`${player.name} purchased ${displayName} and completed a property set!`, 'payment');
        await playProperty3Sound(); // Play property set completion sound
    } else {
        showAdvisory(`${player.name} purchased ${displayName}`, 'payment');
        playHouseSound();
    }
    
    updateInfoPanel(); // Update UI to reflect purchase, remove buttons
    updateGameFrame(); // Update board visuals
    
    // Ensure bottom player display is updated after purchase
    if (typeof updateBottomPlayerDisplay === 'function') {
        updateBottomPlayerDisplay();
    }
    
    // Reset movement flags after property decision is made
    if (isMultiplayerGame) {
        const playerIndex = players.findIndex(p => p.name === player.name);
        if (playerIndex !== -1) {
            updatePlayerData(playerIndex, {
                isMoving: false, // Clear movement flag after property decision
                movementTimestamp: null // Clear movement timestamp
            }).catch(error => console.error('Error clearing movement flags:', error));
        }
    }
    
    // Sync state to Firebase if in multiplayer mode
    if (isMultiplayerGame) {
        // Ensure all owned properties have colors before syncing
        ensurePropertyColors();
        // Force an immediate sync so other clients see the purchase without waiting for the batched delay
        await emergencySyncToFirebase();
    }
    
    // Update the info panel to show development options for the newly purchased property
    console.log('[handlePropertyPurchase] Updating info panel to show development options after purchase.');
    updateInfoPanel(null, null, propertyInfo);
    await updateGameFrame();
    
    console.log(`[handlePropertyPurchase] Continuing turn for ${player.name} after purchase. Last roll was doubles: ${lastRollWasDoubles}.`);
    
    // Wait for the development buttons to be created (they are created with a 50ms delay in updateInfoPanel)
    setTimeout(() => {
        // After purchasing a property, handle turn continuation based on doubles
        if (lastRollWasDoubles) {
            console.log(`[handlePropertyPurchase] ${player.name} rolled doubles. Checking for development options...`);
            
            // Check if player now has development options after purchase
            if (hasDevelopmentButtonsVisible()) {
                console.log(`[handlePropertyPurchase] Development buttons visible after purchase. Not auto-rolling.`);
                showAdvisory(`Doubles! You can develop ${getPropertyDisplayName(propertyInfo)} now, or click dice to roll again and develop later.`, 'turn');
                return;
            }
            
            // If no development options, enable dice for rolling again
            console.log('[handlePropertyPurchase] No development options after purchase - enabling dice for doubles roll.');
            enableDiceSection();
            
            // Handle doubles differently for multiplayer vs single player
            if (isMultiplayerGame) {
                showAdvisory("Doubles! Click dice to roll again.", 'turn');
                console.log(`[handlePropertyPurchase] Multiplayer doubles: Waiting for ${player.name} to click dice again.`);
                // Don't auto-roll in multiplayer - player must click dice
            } else {
                showAdvisory("Doubles! Auto-rolling again...", 'turn');
                // Auto-roll for single player mode only
                setTimeout(() => {
                    if (player.isAI) {
                        handleAITurn();
                    } else {
                        console.log('[handlePropertyPurchase] Auto-rolling dice after purchase');
                        takeTurn();
                    }
                }, 1000);
            }
        } else {
            console.log(`[handlePropertyPurchase] ${player.name} did not roll doubles. Checking for development options...`);

            // If development buttons are visible after the purchase, wait for player action
            if (hasDevelopmentButtonsVisible()) {
                console.log(`[handlePropertyPurchase] Development buttons visible after purchase. Waiting for player's decision.`);
                showAdvisory(`You can develop ${getPropertyDisplayName(propertyInfo)} now, or click dice to end your turn and develop later.`, 'info');
                return; // Pause turn until player chooses to build or decline
            }

            // If no development options, enable dice and end turn
            console.log('[handlePropertyPurchase] No development options after purchase - enabling dice and ending turn.');
            enableDiceSection();
            console.log(`[handlePropertyPurchase] No development options. Turn ends. Calling nextTurn().`);
            setTimeout(() => {
                nextTurn();
            }, 1000);
        }
    }, 100); // Wait 100ms for development buttons to be created (50ms delay + buffer)
    console.log('[handlePropertyPurchase] Completed.');
}

// Add this function at the global scope, outside any other function
function handlePropertyDevelopment(square, playerIndex) {
    clearAutoActionTimer(); // Clear the auto-action timer since player took action
    
    console.log('handlePropertyDevelopment called for square:', square);
    const propertyInfo = getPropertyInfo(square);
    const currentPlayer = players[playerIndex];
    
    if (!currentPlayer) {
        console.error('Player not found for index:', playerIndex);
        return;
    }
    
    // In multiplayer mode, verify it's actually this player's turn
    if (isMultiplayerGame) {
        const activePlayer = players[currentPlayerIndex];
        let playerName = document.getElementById('player1-name').value.trim();
        
        // If player name is empty, try to get it from the stored local player name
        if (!playerName && window.localPlayerName) {
            playerName = window.localPlayerName;
        }
        
        // Additional debugging for player data corruption
        console.log('[handlePropertyDevelopment] Multiplayer validation debug:', {
            activePlayer: activePlayer,
            activePlayerName: activePlayer?.name,
            localPlayerName: playerName,
            playerIndex: playerIndex,
            currentPlayerIndex: currentPlayerIndex,
            playersArray: players.map(p => ({ name: p.name, userId: p.userId, isHost: p.isHost }))
        });
        
        // Check if this browser belongs to the current player by comparing names (case-insensitive)
        // Handle corrupted player names by also checking if we're the current player index
        const isMyTurn = activePlayer && (
            (activePlayer.name && playerName && activePlayer.name.toLowerCase() === playerName.toLowerCase()) ||
            (playerIndex === currentPlayerIndex && window.localPlayerName)
        );
        
        if (!activePlayer || !isMyTurn || playerIndex !== currentPlayerIndex) {
            console.warn(`[handlePropertyDevelopment] Multiplayer validation failed. Current player: ${activePlayer?.name}, Your name: ${playerName}, PlayerIndex: ${playerIndex}, CurrentPlayerIndex: ${currentPlayerIndex}`);
            showAdvisory("It's not your turn!", 'error');
            return;
        }
    }
    
    // Prevent bankrupt players from developing
    if (currentPlayer.bankrupt) {
        console.log('Bankrupt player cannot develop property:', currentPlayer.name);
        return;
    }
    
    if (!propertyInfo) {
        console.error('Property info not found for square:', square);
        return;
    }
    
    const devInfo = getDevelopmentCost(square);
    if (devInfo && currentPlayer.money >= devInfo.cost) {
        console.log('Development is valid, proceeding with development');
        // Develop the property
        if (developProperty(currentPlayer, square)) {
            console.log('Property developed:', {
                square: square,
                type: devInfo.type,
                cost: devInfo.cost,
                remainingMoney: currentPlayer.money
            });
            
            // Show development advisory
            showAdvisory(
                `${currentPlayer.name} built a ${devInfo.type} on ${square} for Â£${devInfo.cost}`,
                'development'
            );
            
            // Development sound is now played in developProperty function
            
            // Clear stored property info since development is complete
            currentPropertyInfo = null;
            
            // Update the display
            updateInfoPanel(null, null, propertyInfo);
            updateGameFrame();
            
            // Ensure bottom player display is updated after development
            if (typeof updateBottomPlayerDisplay === 'function') {
                updateBottomPlayerDisplay();
            }
            
            // Sync state to Firebase if in multiplayer mode
            if (isMultiplayerGame) {
                // Update both player data and property state
                updatePlayerData(playerIndex, {
                    money: currentPlayer.money,
                    properties: currentPlayer.properties
                }).catch(error => console.error('Error updating player data:', error));
                
                updatePropertyState(square, propertyState[square])
                    .catch(error => console.error('Error updating property state:', error));
            }
            
            // Check if player can still develop this property and has enough cash
            const nextDevInfo = getDevelopmentCost(square);
            if (
                nextDevInfo &&
                canDevelopProperty(currentPlayer, square) &&
                currentPlayer.money >= nextDevInfo.cost
            ) {
                // Give player choice to continue developing or exit
                showAdvisory(
                    `Development successful! You can build another ${nextDevInfo.type} on ${getPropertyDisplayName(propertyInfo)} for Â£${nextDevInfo.cost}, develop later, or click dice to continue your turn.`,
                    'info'
                );
                // Update info panel to show development buttons again, but also enable dice
                updateInfoPanel(null, null, propertyInfo);
                // Enable dice section so player can choose to exit
                enableDiceSection();
                return; // Pause for player decision - they can choose to develop more or click dice to continue
            }
            
            // No more development possible, continue the turn
            enableDiceSection();
            setTimeout(() => {
                // Check if it was doubles - if so, player gets another turn
                if (lastRollWasDoubles) {
                    console.log('Doubles rolled, checking for more development options...');
                    
                    // Check if player still has development options after building
                    if (hasDevelopmentButtonsVisible()) {
                        console.log('Development buttons still visible after building. Not auto-rolling.');
                        showAdvisory("Doubles! You can continue developing properties or click dice to roll again and develop later.", 'turn');
                        return;
                    }
                    
                    // Handle doubles differently for multiplayer vs single player
                    if (isMultiplayerGame) {
                        showAdvisory("Doubles! Click dice to roll again.", 'turn');
                        console.log(`[handlePropertyDevelopment] Multiplayer doubles: Waiting for ${currentPlayer.name} to click dice again.`);
                        // Don't auto-roll in multiplayer - player must click dice
                    } else {
                        showAdvisory("Doubles! Auto-rolling again...", 'turn');
                        // Auto-roll for single player mode only
                        if (currentPlayer.isAI) {
                            handleAITurn();
                        } else {
                            console.log('[handlePropertyDevelopment] Auto-rolling dice after development');
                            takeTurn();
                        }
                    }
                } else {
                    // Not doubles, advance to next player
                    nextTurn();
                }
            }, 5000); // 5 second delay to give more time to see development options
        }
    } else {
        console.error('Invalid development attempt:', {
            square: square,
            playerMoney: currentPlayer.money,
            devCost: devInfo ? devInfo.cost : 'unknown',
            type: devInfo ? devInfo.type : 'unknown'
        });
    }
}

// Add function to handle declining development
async function handleDeclineDevelopment(square, playerIndex) {
    clearAutoActionTimer(); // Clear the auto-action timer since player took action
    
    const player = players[playerIndex];
    const propertyInfo = getPropertyInfo(square);

    console.log(`[handleDeclineDevelopment] Called for square: ${square}, playerIndex: ${playerIndex}. Player: ${player ? player.name : 'N/A'}.`);

    if (!player) {
        console.error('[handleDeclineDevelopment] CRITICAL: Player object is undefined for playerIndex:', playerIndex);
        return; 
    }
    if (!propertyInfo) {
        console.error(`[handleDeclineDevelopment] CRITICAL: Property info not found for square: ${square}.`);
        return;
    }
    if (player.isAI) {
        console.warn(`[handleDeclineDevelopment] WARNING: Human decline function called for AI player ${player.name}. AI decisions should be internal. Aborting.`);
        return;
    }
    
    // In multiplayer mode, verify it's actually this player's turn
    if (isMultiplayerGame) {
        const currentPlayer = players[currentPlayerIndex];
        let playerName = document.getElementById('player1-name').value.trim();
        
        // If player name is empty, try to get it from the stored local player name
        if (!playerName && window.localPlayerName) {
            playerName = window.localPlayerName;
        }
        
        // Check if this browser belongs to the current player by comparing names (case-insensitive)
        const isMyTurn = currentPlayer && currentPlayer.name.toLowerCase() === playerName.toLowerCase();
        
        if (!currentPlayer || !isMyTurn || playerIndex !== currentPlayerIndex) {
            console.warn(`[handleDeclineDevelopment] Multiplayer validation failed. Current player: ${currentPlayer?.name}, Your name: ${playerName}, PlayerIndex: ${playerIndex}, CurrentPlayerIndex: ${currentPlayerIndex}`);
            showAdvisory("It's not your turn!", 'error');
            return;
        }
    }

    clearAutoRollTimer(); // Clear any pending auto-roll timer

    const displayName = getPropertyDisplayName(propertyInfo);
    console.log(`[handleDeclineDevelopment] Player ${player.name} declined to develop ${displayName}.`);
    showAdvisory(`${player.name} will develop ${displayName} later. You can still develop it on future turns.`, 'info');

    // Mark property as declined for development by this player
    if (!playerDeclinedProperties.has(player.name)) {
        playerDeclinedProperties.set(player.name, new Set());
    }
    playerDeclinedProperties.get(player.name).add(`dev_${square}`); // Use "dev_" prefix to distinguish from purchase declines
    console.log(`[handleDeclineDevelopment] Added dev_${square} to ${player.name}'s declined properties list.`);
    
    // Clear stored property info since development is declined
    currentPropertyInfo = null;
    
    updateInfoPanel(); // Update UI to remove development buttons
    
    console.log('[handleDeclineDevelopment] Re-enabling dice section after decline.');
    enableDiceSection(); 
    
    console.log(`[handleDeclineDevelopment] Player ${player.name} declined development. Continuing turn. Last roll was doubles: ${lastRollWasDoubles}.`);
    
    // Continue the turn based on whether doubles were rolled - AUTO ROLL after skipping development
    // After declining development, handle turn continuation based on doubles
    if (lastRollWasDoubles) {
        console.log(`[handleDeclineDevelopment] ${player.name} rolled doubles. Checking for other development options...`);
        
        // Check if there are still other development options visible
        if (hasDevelopmentButtonsVisible()) {
            console.log(`[handleDeclineDevelopment] Other development buttons still visible. Not auto-rolling.`);
            showAdvisory("Doubles! You can develop other properties or click dice to roll again.", 'turn');
            return;
        }
        
        // Handle doubles differently for multiplayer vs single player
        if (isMultiplayerGame) {
            showAdvisory("Doubles! Click dice to roll again.", 'turn');
            console.log(`[handleDeclineDevelopment] Multiplayer doubles: Waiting for ${player.name} to click dice again.`);
            // Don't auto-roll in multiplayer - player must click dice
        } else {
            showAdvisory("Doubles! Auto-rolling again...", 'turn');
            // Auto-roll for single player mode only
            setTimeout(() => {
                if (player.isAI) {
                    handleAITurn();
                } else {
                    console.log('[handleDeclineDevelopment] Auto-rolling dice after skipping development');
                    takeTurn();
                }
            }, 1000);
        }
    } else {
        console.log(`[handleDeclineDevelopment] ${player.name} did not roll doubles. Turn ends. Calling nextTurn().`);
        setTimeout(() => {
            nextTurn();
        }, 1000);
    }
    console.log('[handleDeclineDevelopment] Completed.');
}

// Add function to handle declining property purchase
async function handleDeclinePurchase(square, playerIndex) {
    clearAutoActionTimer(); // Clear the auto-action timer since player took action
    
    const player = players[playerIndex];
    const propertyInfo = getPropertyInfo(square);

    console.log(`[handleDeclinePurchase] Called for square: ${square}, playerIndex: ${playerIndex}. Player: ${player ? player.name : 'N/A'}, Property: ${propertyInfo ? getPropertyDisplayName(propertyInfo) : 'N/A'}.`);

    if (!player) {
        console.error('[handleDeclinePurchase] CRITICAL: Player object is undefined for playerIndex:', playerIndex);
        return; 
    }
    if (!propertyInfo) {
        console.error(`[handleDeclinePurchase] CRITICAL: Property info not found for square: ${square}.`);
        return;
    }
    if (player.isAI) {
        console.warn(`[handleDeclinePurchase] WARNING: Human decline function called for AI player ${player.name}. AI decisions should be internal. Aborting.`);
        return;
    }
    
    // In multiplayer mode, verify it's actually this player's turn
    if (isMultiplayerGame) {
        const currentPlayer = players[currentPlayerIndex];
        let playerName = document.getElementById('player1-name').value.trim();
        
        // If player name is empty, try to get it from the stored local player name
        if (!playerName && window.localPlayerName) {
            playerName = window.localPlayerName;
        }
        
        // Check if this browser belongs to the current player by comparing names (case-insensitive)
        const isMyTurn = currentPlayer && currentPlayer.name.toLowerCase() === playerName.toLowerCase();
        
        if (!currentPlayer || !isMyTurn || playerIndex !== currentPlayerIndex) {
            console.warn(`[handleDeclinePurchase] Multiplayer validation failed. Current player: ${currentPlayer?.name}, Your name: ${playerName}, PlayerIndex: ${playerIndex}, CurrentPlayerIndex: ${currentPlayerIndex}`);
            showAdvisory("It's not your turn!", 'error');
            return;
        }
    }

    clearAutoRollTimer(); // Clear any pending auto-roll timer

    const displayName = getPropertyDisplayName(propertyInfo);
    console.log(`[handleDeclinePurchase] Player ${player.name} declined to purchase ${displayName}.`);
    showAdvisory(`${player.name} declined to purchase ${displayName}.`, 'info');
    // Clear pending decision on decline
    try {
        if (typeof window !== 'undefined' && window.pendingPropertyDecision && window.pendingPropertyDecision.square === square) {
            console.log('[handleDeclinePurchase] Clearing pendingPropertyDecision for', window.pendingPropertyDecision);
            window.pendingPropertyDecision = null;
        }
    } catch (e) {
        console.warn('[handleDeclinePurchase] Could not clear pendingPropertyDecision:', e);
    }

    // Mark property as declined by this player permanently (until they leave/re-enter the property)
    propertyState[square].declined = true;
    propertyState[square].declinedBy = player.name;
    if (!playerDeclinedProperties.has(player.name)) {
        playerDeclinedProperties.set(player.name, new Set());
    }
    playerDeclinedProperties.get(player.name).add(square);
    console.log(`[handleDeclinePurchase] Added ${square} to ${player.name}'s declined properties list.`);

    // Reset movement flags after property decision is made
    if (isMultiplayerGame) {
        const playerIndex = players.findIndex(p => p.name === player.name);
        if (playerIndex !== -1) {
            updatePlayerData(playerIndex, {
                isMoving: false, // Clear movement flag after property decision
                movementTimestamp: null // Clear movement timestamp
            }).catch(error => console.error('Error clearing movement flags:', error));
        }
        // Sync the decline decision immediately
        await emergencySyncToFirebase();
    }

    updateInfoPanel(); // Update UI to remove purchase buttons

    console.log('[handleDeclinePurchase] Re-enabling dice section before continuing turn.');
    enableDiceSection();

    console.log(`[handleDeclinePurchase] Continuing turn for ${player.name} after decline. Last roll was doubles: ${lastRollWasDoubles}.`);
    
    // After declining a purchase, the player should be able to continue their turn
    // Only advance to next player if they originally didn't roll doubles
    if (lastRollWasDoubles) {
        console.log(`[handleDeclinePurchase] ${player.name} rolled doubles. Checking for development options...`);
        
        // Check if player has development options after declining purchase
        if (hasDevelopmentButtonsVisible()) {
            console.log(`[handleDeclinePurchase] Development buttons visible after decline. Not auto-rolling.`);
            showAdvisory("Doubles! You can develop properties or click dice to roll again.", 'turn');
            return;
        }
        
        // Handle doubles differently for multiplayer vs single player
        if (isMultiplayerGame) {
            showAdvisory("Doubles! Click dice to roll again.", 'turn');
            console.log(`[handleDeclinePurchase] Multiplayer doubles: Waiting for ${player.name} to click dice again.`);
            // Don't auto-roll in multiplayer - player must click dice
        } else {
            showAdvisory("Doubles! Auto-rolling again...", 'turn');
            // Auto-roll for single player mode only
            setTimeout(() => {
                if (player.isAI) {
                    handleAITurn();
                } else {
                    console.log('[handleDeclinePurchase] Auto-rolling dice after decline');
                    takeTurn();
                }
            }, 1000);
        }
    } else {
            console.log(`[handleDeclinePurchase] ${player.name} did not roll doubles. Turn ends. Calling nextTurn().`);
    
    // Clear the property info panel before transitioning turns
    updateInfoPanel();
    
    setTimeout(() => {
        nextTurn();
    }, 1000);
    }

    console.log('[handleDeclinePurchase] Completed.');
}

// Expose functions for inline event handlers
window.handlePropertyPurchase = handlePropertyPurchase;
window.handlePropertyDevelopment = handlePropertyDevelopment;
window.handleDeclinePurchase = handleDeclinePurchase;
window.handleDeclineDevelopment = handleDeclineDevelopment;

// Expose startAIGame function for preset rooms
window.startAIGame = startAIGame;

// Enhanced bankruptcy check - checks if player money is <= 0
function checkBankruptcy(player) {
    if (!player.bankrupt && player.money <= 0) {
        player.money = 0;
        player.bankrupt = true;
        console.log(`${player.name} has gone bankrupt! Money: ${player.money}`);
        
        // Release all properties owned by the bankrupt player
        releasePlayerProperties(player);
        
        // Remove bankrupt player from active gameplay
        removePlayerFromGame(player);
        
        // Update player data in Firebase if in multiplayer mode
        if (isMultiplayerGame) {
            const playerIndex = players.indexOf(player);
            if (playerIndex !== -1) {
                updatePlayerData(playerIndex, {
                    money: player.money,
                    bankrupt: player.bankrupt,
                    properties: player.properties
                }).catch(error => console.error('Error updating bankrupt player data:', error));
            }
        }
        
        // Check if only one player remains
        const activePlayers = players.filter(p => !p.bankrupt);
        if (activePlayers.length <= 1) {
            handleGameEnd(activePlayers[0]);
        } else {
            showAdvisory(`${player.name} has gone bankrupt! ${activePlayers.length} players remain in the game.`, 'payment');
        }
        
        playScreamSound(); // Play scream sound when player goes bankrupt
        return true; // Return true if player went bankrupt
    }
    return false; // Return false if player is still solvent
}

// Release all properties owned by a bankrupt player and make them immediately available to all remaining players
function releasePlayerProperties(bankruptPlayer) {
    console.log(`[releasePlayerProperties] Releasing all properties owned by ${bankruptPlayer.name} and making them available to all remaining players`);
    
    // Clear the player's properties array
    const propertiesReleased = [...bankruptPlayer.properties];
    bankruptPlayer.properties = [];
    
    // Get list of remaining active players
    const remainingPlayers = players.filter(p => !p.bankrupt && p.name !== bankruptPlayer.name);
    
    // Clear ownership from propertyState and reset development, making them available to all
    propertiesReleased.forEach(square => {
        if (propertyState[square]) {
            console.log(`[releasePlayerProperties] Releasing ${square} from ${bankruptPlayer.name} - now available to all remaining players`);
            
            // Clear ownership - properties become unowned and available for purchase
            propertyState[square].owner = null;
            propertyState[square].ownerColor = null;
            
            // Reset all development (graveyards and crypts)
            propertyState[square].graveyards = 0;
            propertyState[square].crypts = 0;
            
            // Clear any declined status so all players can purchase
            propertyState[square].declined = false;
            propertyState[square].declinedBy = null;
            
            // Mark as available to all remaining players
            propertyState[square].availableToAll = true;
            propertyState[square].bankruptcyRelease = true;
            
            // Sync to Firebase if in multiplayer mode
            if (isMultiplayerGame) {
                updatePropertyState(square, propertyState[square])
                    .catch(error => console.error('Error updating released property state:', error));
            }
        }
    });
    
    // Update the game frame to show property ownership changes
    updateGameFrame();
    
    console.log(`[releasePlayerProperties] Released ${propertiesReleased.length} properties: [${propertiesReleased.join(', ')}] - now available to ${remainingPlayers.length} remaining players`);
    
    if (propertiesReleased.length > 0) {
        const remainingPlayerNames = remainingPlayers.map(p => p.name).join(', ');
        showAdvisory(`ðŸ’° ${bankruptPlayer.name}'s ${propertiesReleased.length} properties are now immediately available for purchase by all remaining players: ${remainingPlayerNames}!`, 'info');
        
        // Log detailed property release info
        console.log(`[releasePlayerProperties] Properties released from bankruptcy:`, {
            bankruptPlayer: bankruptPlayer.name,
            propertiesReleased: propertiesReleased,
            remainingPlayers: remainingPlayerNames,
            availableToAllPlayers: true
        });
    }
}

// Remove bankrupt player from active gameplay
function removePlayerFromGame(bankruptPlayer) {
    console.log(`[removePlayerFromGame] Removing ${bankruptPlayer.name} from active gameplay`);
    
    // Mark player as completely removed from game
    bankruptPlayer.activeInGame = false;
    bankruptPlayer.removedFromGame = true;
    
    // Update UI to show player as bankrupt/eliminated
    updatePlayerStatusInUI(bankruptPlayer);
    
    console.log(`[removePlayerFromGame] ${bankruptPlayer.name} has been removed from active gameplay`);
}

// Handle game end when only one player remains
function handleGameEnd(winner = null) {
    if (isGameOver) return;
    
    isGameOver = true;
    console.log('[handleGameEnd] Game ending - only one player remains or all players bankrupt');
    
    // Stop lightning system
    stopLightningSystem();
    

    
    if (winner) {
        console.log(`[handleGameEnd] Winner: ${winner.name} with Â£${winner.money}`);
        showAdvisory(`ðŸŽ‰ Game Over! ${winner.name} wins with Â£${winner.money}! ðŸŽ‰`, 'info');
        playGetyouMusic();
    } else {
        console.log('[handleGameEnd] All players bankrupt - no winner');
        showAdvisory('Game Over - All players bankrupt!', 'info');
        playScreamSound();
    }
    
    // Disable game controls
    clearAutoRollTimer();
    clearAutoActionTimer();
    const diceSection = document.getElementById('dice-section');
    if (diceSection) {
        diceSection.style.pointerEvents = 'none';
    }
    
    // Sync final game state to Firebase
    if (isMultiplayerGame) {
        syncGameStateToFirebase().catch(error => console.error('Error syncing final game state:', error));
    }
}

// Update player status in UI
function updatePlayerStatusInUI(player) {
    // This function can be expanded to update specific UI elements showing player status
    console.log(`[updatePlayerStatusInUI] Updating UI for ${player.name} - Bankrupt: ${player.bankrupt}`);
    
    // Update info panel if it exists
    updateInfoPanel();
    
    // Update multiplayer status if in multiplayer mode
    if (isMultiplayerGame) {
        updateMultiplayerStatus(players);
    }
}

// Check all players for bankruptcy before each turn
function checkAllPlayersBankruptcy() {
    let bankruptcyOccurred = false;
    players.forEach(player => {
        if (checkBankruptcy(player)) {
            bankruptcyOccurred = true;
        }
    });
    
    // Check if only one or no players remain
    const activePlayers = players.filter(p => !p.bankrupt);
    if (activePlayers.length <= 1) {
        handleGameEnd(activePlayers[0] || null);
    }
    
    return bankruptcyOccurred;
}

// Handle scenario where everyone is bankrupt
function handleAllPlayersBankrupt() {
    if (isGameOver) return;
    isGameOver = true;
    
    // Stop lightning system
    stopLightningSystem();
    

    
    showAdvisory('Game Over', 'info');
    playGetyouMusic();
    clearAutoRollTimer();
    clearAutoActionTimer();
    const diceSection = document.getElementById('dice-section');
    if (diceSection) {
        diceSection.style.pointerEvents = 'none';
    }
}

// Call checkBankruptcy after any money deduction (e.g., after paying rent, buying property, etc.)
// Example for rent:
// player.money -= rentInfo.amount;
// checkBankruptcy(player);
// For purchases:
// currentPlayer.money -= propertyInfo.cost;
// checkBankruptcy(currentPlayer);
// For development:
// currentPlayer.money -= devInfo.cost;
// checkBankruptcy(currentPlayer);

// In turn progression, skip bankrupt players
function getNextEligiblePlayerIndex(startIndex) {
    console.log(`[getNextEligiblePlayerIndex] Called with startIndex: ${startIndex}, players.length: ${players.length}`);
    
    let idx = (startIndex + 1) % players.length;
    let count = 0;
    
    console.log(`[getNextEligiblePlayerIndex] Initial calculation: (${startIndex} + 1) % ${players.length} = ${idx}`);
    
    // First check if any non-bankrupt players remain
    const anyPlayersRemain = players.some(p => !p.bankrupt);
    console.log(`[getNextEligiblePlayerIndex] Any non-bankrupt players remain: ${anyPlayersRemain}`);
    
    if (!anyPlayersRemain) {
        // Game is over - all players are bankrupt
        console.log(`[getNextEligiblePlayerIndex] All players bankrupt - ending game`);
        handleAllPlayersBankrupt();
        return startIndex; // Stay on current player
    }
    
    // Find next non-bankrupt player
    console.log(`[getNextEligiblePlayerIndex] Looking for next non-bankrupt player starting from index ${idx}`);
    while (players[idx].bankrupt && count < players.length) {
        console.log(`[getNextEligiblePlayerIndex] Player at index ${idx} (${players[idx].name}) is bankrupt, trying next...`);
        idx = (idx + 1) % players.length;
        count++;
    }
    
    console.log(`[getNextEligiblePlayerIndex] Found next eligible player: index ${idx} (${players[idx]?.name}), bankrupt: ${players[idx]?.bankrupt}`);
    
    return idx;
}

// In takeTurn, replace advancing to next player with:
// currentPlayerIndex = getNextEligiblePlayerIndex(currentPlayerIndex);
// isAITurn = players[currentPlayerIndex].isAI;

// Add these variables at the top with other game state variables
let db;
let isHost = false;
let currentRoomId = null;
let currentUserId = null;
let gameStateUnsubscribe = null;
let autoStartFlag = false;

// Track declined properties per player to prevent showing same options repeatedly
let playerDeclinedProperties = new Map(); // Map of playerName -> Set of declined property squares

// Function to clear auto-declined properties for a player (useful for new games or resets)
function clearAutoDeclinedProperties(playerName = null) {
    if (playerName) {
        // Clear for specific player
        if (playerDeclinedProperties.has(playerName)) {
            const declinedSet = playerDeclinedProperties.get(playerName);
            const manuallyDeclined = Array.from(declinedSet).filter(prop => !prop.startsWith('auto_'));
            declinedSet.clear();
            manuallyDeclined.forEach(prop => declinedSet.add(prop));
            console.log(`[clearAutoDeclinedProperties] Cleared auto-declined properties for ${playerName}`);
        }
    } else {
        // Clear for all players
        for (const [playerName, declinedSet] of playerDeclinedProperties.entries()) {
            const manuallyDeclined = Array.from(declinedSet).filter(prop => !prop.startsWith('auto_'));
            declinedSet.clear();
            manuallyDeclined.forEach(prop => declinedSet.add(prop));
        }
        console.log(`[clearAutoDeclinedProperties] Cleared auto-declined properties for all players`);
    }
}

// Make function available globally for console access
window.clearAutoDeclinedProperties = clearAutoDeclinedProperties;

// Money tracking for pulse animations
let previousPlayerMoney = new Map(); // Track previous money values by player name

// Declare variables for multiplayer elements (moved to top of file)
// let createRoomBtn; // Moved to top of file
// let joinRoomBtn; // Moved to top of file
// let roomIdInput; // Moved to top of file
// let roomCode; // Moved to top of file
// let roomList; // Moved to top of file
// let playerList; // Moved to top of file

// Initialize Firebase when the game loads
db = initFirebaseHorropoly();

// Debug functions for multiplayer troubleshooting
window.debugMultiplayerState = function() {
    console.log('=== MULTIPLAYER DEBUG STATE ===');
    console.log('isMultiplayerGame:', isMultiplayerGame);
    console.log('currentRoomId:', currentRoomId);
    console.log('isHost:', isHost);
    console.log('currentUserId:', currentUserId);
    console.log('localPlayerName:', window.localPlayerName);
    console.log('players array:', players);
    console.log('players length:', players?.length);
    console.log('currentPlayerIndex:', currentPlayerIndex);
    console.log('currentPlayer:', players?.[currentPlayerIndex]);
    console.log('gameStarted:', gameStarted);
    console.log('================================');
};

window.debugPlayerNames = function() {
    console.log('=== PLAYER NAMES DEBUG ===');
    console.log('localPlayerName:', window.localPlayerName);
    console.log('player1-name input:', document.getElementById('player1-name')?.value);
    if (players && Array.isArray(players)) {
        players.forEach((player, index) => {
            console.log(`Player ${index}:`, {
                name: player.name,
                userId: player.userId,
                isHost: player.isHost,
                nameValid: !!player.name && player.name !== 'undefined'
            });
        });
    }
    console.log('==========================');
};

window.fixPlayerData = function() {
    console.log('=== FIXING PLAYER DATA ===');
    if (players && Array.isArray(players)) {
        const playerName = document.getElementById('player1-name')?.value?.trim() || window.localPlayerName;
        if (playerName && playerName !== 'undefined') {
            players.forEach((player, index) => {
                if (!player.name || player.name === 'undefined') {
                    console.log(`Fixing player ${index} name from "${player.name}" to "${playerName}"`);
                    player.name = playerName;
                    // If this is the host and we're the host, update it
                    if (isHost && player.isHost) {
                        player.name = playerName;
                    }
                }
            });
            
            // Sync to Firebase
            if (isMultiplayerGame) {
                syncGameStateToFirebase();
            }
            
            // Update UI
            updatePlayerList(players);
            updateGameFrame();
        }
    }
    console.log('==========================');
};

window.addSecondPlayer = function(playerName = 'Player2') {
    console.log('=== ADDING SECOND PLAYER ===');
    if (players && Array.isArray(players) && players.length === 1) {
        const newPlayer = {
            name: playerName,
            userId: 'user_' + Math.random().toString(36).substring(2, 10),
            isHost: false,
            position: 0,
            currentSquare: 'go',
            currentPathKey: 'gamePath',
            currentIndexOnPath: 0,
            isMovingReverse: false,
            x: 0,
            y: 0,
            size: 62,
            money: 16500,
            properties: [],
            isAI: false,
            bankrupt: false,
            tokenImage: 'assets/images/t2.png',
            tokenIndex: 1,
            inJail: false,
            jailTurns: 0,
            consecutiveDoubles: 0
        };
        
        players.push(newPlayer);
        console.log('Added second player:', newPlayer);
        
        // Sync to Firebase
        if (isMultiplayerGame) {
            syncGameStateToFirebase();
        }
        
        // Update UI
        updatePlayerList(players);
        updateGameFrame();
        
        console.log('Second player added successfully. Players array now:', players);
    } else {
        console.log('Cannot add second player. Current players:', players?.length);
    }
    console.log('===============================');
};

// Test UserIDs panel on page load (disabled - not needed)
// document.addEventListener('DOMContentLoaded', () => {
//     console.log('DOM loaded, testing UserIDs panel');
//     setTimeout(() => {
//         updateUserIDsPanel([
//             { name: 'Test Player 1', userId: 'test_12345', isHost: true },
//             { name: 'Test Player 2', userId: 'test_67890', isHost: false }
//         ]);
//     }, 1000);
// });

// Function to initialize multiplayer controls
async function initializeMultiplayerControls() {
    // Get DOM elements
    createRoomBtn = document.getElementById('create-room-btn');
    joinRoomBtn = document.getElementById('join-room-btn');
    roomIdInput = document.getElementById('room-id-input');
    roomCode = document.getElementById('room-code');
    roomList = document.getElementById('room-list');
    playerList = document.getElementById('player-list');

    if (!createRoomBtn || !joinRoomBtn) {
        console.error('Multiplayer control elements not found:', {
            createRoomBtn: !!createRoomBtn,
            joinRoomBtn: !!joinRoomBtn,
            roomCode: !!roomCode,
            roomList: !!roomList,
            playerList: !!playerList
        });
        return;
    }

    // Mobile-specific Firebase initialization check
    if (isMobile) {
        console.log('ðŸ“± Mobile device detected - checking Firebase availability');
        
        // Add extra delay for mobile devices to ensure Firebase is loaded
        let attempts = 0;
        while (!window.initFirebaseHorropoly && attempts < 10) {
            console.log(`ðŸ“± Waiting for Firebase to load... attempt ${attempts + 1}`);
            await new Promise(resolve => setTimeout(resolve, 500));
            attempts++;
        }
        
        if (!window.initFirebaseHorropoly) {
            console.error('ðŸ“± Firebase failed to load on mobile device');
            showAdvisory('Firebase not loaded on mobile. Please check your internet connection and refresh.', 'error');
            return;
        } else {
            console.log('ðŸ“± Firebase successfully loaded on mobile device');
        }
    }
    
    // Additional debugging for roomList
    console.log('roomList element details:', {
        exists: !!roomList,
        id: roomList ? roomList.id : 'N/A',
        className: roomList ? roomList.className : 'N/A',
        currentDisplay: roomList ? window.getComputedStyle(roomList).display : 'N/A'
    });

    console.log('Multiplayer controls initialized successfully');
    console.log('Element references:', {
        createRoomBtn: !!createRoomBtn,
        joinRoomBtn: !!joinRoomBtn,
        roomCode: !!roomCode,
        roomList: !!roomList,
        playerList: !!playerList
    });

        // Add event listeners for multiplayer controls
    createRoomBtn.addEventListener('click', async () => {
        console.log('Create room button clicked');
        const playerName = document.getElementById('player1-name').value.trim();
        if (!playerName) {
            showAdvisory('Please enter your name first', 'error');
            return;
        }

        console.log('Creating room for player:', playerName);
        
        // Store the player name globally for later use
        window.localPlayerName = playerName;
        
        const maxPlayersSelect = document.getElementById('max-players');
        const maxPlayers = parseInt(maxPlayersSelect.value, 10) || 2;
        try {
            console.log('About to call createGameRoom...');
            console.log('createGameRoom function type:', typeof createGameRoom);
            
            // Add a timeout to detect hanging promises
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('createGameRoom timeout after 10 seconds')), 10000);
            });
            
            const roomData = await Promise.race([
                createGameRoom(playerName, maxPlayers, 0, null, null, `${playerName}'s Dungeon`),
                timeoutPromise
            ]);
            
            currentRoomId = roomData.roomId;
            currentUserId = roomData.userId;
            
            console.log('Room created with ID:', currentRoomId);
            console.log('User ID assigned:', currentUserId);
            console.log('Room data received:', roomData);
            console.log('Firebase createGameRoom completed successfully');
            console.log('Type of currentRoomId:', typeof currentRoomId, 'Value:', currentRoomId);
            
            if (!currentRoomId) {
                throw new Error('Room ID is null or undefined');
            }
            
            console.log('Setting isHost to true...');
            isHost = true;
            isMultiplayerGame = true; // Set multiplayer flag when creating room
            console.log('isHost set, proceeding with UI updates...');
            
            try {
                // Debug: Check if multiplayer controls are visible
                const multiplayerControls = document.querySelector('.multiplayer-controls');
                console.log('Multiplayer controls visibility:', {
                    exists: !!multiplayerControls,
                    display: multiplayerControls ? window.getComputedStyle(multiplayerControls).display : 'N/A'
                });
                
                // Update room code display
                if (roomCode) {
                    roomCode.textContent = `Room Code: ${currentRoomId}`;
                    roomCode.style.display = 'block';
                    roomCode.style.visibility = 'visible';
                    roomCode.style.opacity = '1';
                    console.log('Room code element updated:', roomCode.textContent);
                    console.log('Room code element styles:', {
                        display: roomCode.style.display,
                        visibility: roomCode.style.visibility,
                        opacity: roomCode.style.opacity
                    });
                    console.log('Room code element computed styles:', window.getComputedStyle(roomCode).display);
                } else {
                    console.error('Room code element not found!');
                }
                
                // Hide/show buttons
                if (createRoomBtn) createRoomBtn.style.display = 'none';
                if (joinRoomBtn) joinRoomBtn.style.display = 'none';
                
                const startGameBtn = document.getElementById('start-game-btn');
                if (startGameBtn) {
                    startGameBtn.style.display = 'block';
                    console.log('Start game button shown');
                } else {
                    console.error('Start game button not found!');
                }
                
                console.log('About to call subscribeToGameRoom...');
                try {
                    subscribeToGameRoom();
                    console.log('subscribeToGameRoom completed');
                } catch (subError) {
                    console.error('Error in subscribeToGameRoom:', subError);
                }
                
                console.log('About to show advisory...');
                showAdvisory('Room created! Share the room code with another player.', 'success');
                
                console.log('About to show multiplayer status...');
                // Show multiplayer status window (disabled)
                // showMultiplayerStatus(); // Disabled - don't show multiplayer status window
                
                // Show UserIDs panel (disabled)
                // showUserIDsPanel(); // Disabled - don't show UserIDs window
                
                // Test with dummy data to verify panel works (disabled)
                console.log('Testing UserIDs panel with dummy data (disabled)');
                // updateUserIDsPanel([
                //     { name: playerName, userId: currentUserId, isHost: true },
                //     { name: 'Waiting for player...', userId: 'pending', isHost: false }
                // ]);
                
                console.log('Room creation UI updates completed successfully');
                
            } catch (uiError) {
                console.error('Error during UI updates:', uiError);
                console.error('UI Error stack:', uiError.stack);
                // UI updates failed, but room was still created successfully
                console.log('Room created successfully despite UI update errors');
            }
        } catch (error) {
            console.error('Error creating room:', error);
            console.error('Error stack:', error.stack);
            showAdvisory('Failed to create room: ' + error.message, 'error');
        }
        
        console.log('Create room event handler completed');
    });

// Add event listener for multiplayer start game button
document.getElementById('start-game-btn').addEventListener('click', async (event) => {
    console.log('Start game button clicked');
    
    // Prevent multiple simultaneous clicks
    const startBtn = document.getElementById('start-game-btn');
    if (startBtn.disabled || isInitializing) {
        console.log('Start game button disabled or already initializing, ignoring click');
        return;
    }
    
    // Disable button immediately
    startBtn.disabled = true;
    startBtn.textContent = 'Starting...';
    console.log('Start game button disabled');
    
    if (!isHost) {
        showAdvisory('Only the host can start the game', 'error');
        startBtn.disabled = false;
        startBtn.textContent = 'Start Game';
        return;
    }

    if (!currentRoomId) {
        showAdvisory('No room connected', 'error');
        startBtn.disabled = false;
        startBtn.textContent = 'Start Game';
        return;
    }

    try {
        console.log('About to get room state for starting game...');
        
        // Use the same approach as joinGameRoom to avoid hanging getDoc
        let gameState;
        let roomExists = false;
        
        try {
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('getDoc timeout')), 2000);
            });
            
            const roomDoc = await Promise.race([getDoc(doc(db, 'gameRooms', currentRoomId)), timeoutPromise]);
            console.log('getDoc completed for start game, document exists:', roomDoc.exists());
            
            if (roomDoc.exists()) {
                gameState = roomDoc.data();
                roomExists = true;
                console.log('Retrieved game state for start:', gameState);
            }
        } catch (getDocError) {
            console.log('getDoc failed or timed out for start game, proceeding optimistically:', getDocError.message);
            // We'll proceed optimistically - assume we have at least 2 players since someone joined
        }
        
        // If we got the game state, do validation
        if (roomExists && gameState) {
            if (gameState.players.length < 2) {
                showAdvisory('Need at least 2 players to start the game', 'error');
                return;
            }

            if (gameState.players.length > (gameState.maxPlayers || 2)) {
                showAdvisory(`Maximum ${gameState.maxPlayers || 2} players allowed`, 'error');
                return;
            }

            console.log('Starting multiplayer game with', gameState.players.length, 'players');

            const aiCount = parseInt(aiPlayerCountSelect?.value, 10) || 0;
            const playersToStart = [...gameState.players];
            const maxP = gameState.maxPlayers || 4;
            const available = Math.max(0, maxP - playersToStart.length);
            const aiToAdd = Math.min(aiCount, available);
            for (let i = 0; i < aiToAdd; i++) {
                const index = playersToStart.length;
                playersToStart.push({
                    name: `AI Player ${i + 1}`,
                    userId: 'ai_' + Math.random().toString(36).substring(2, 10),
                    isHost: false,
                    isAI: true,
                    tokenIndex: index,
                    tokenImage: `assets/images/t${(index % 9) + 1}.png`,
                    money: 16500,
                    properties: [],
                    bankrupt: false,
                    goPassCount: 0,
                    inJail: false,
                    jailTurns: 0,
                    consecutiveDoubles: 0,
                    size: 62
                });
            }

            // Initialize game state for multiplayer
            await startMultiplayerGame(playersToStart);
        } else {
            // Optimistic start - assume we have valid players
            console.log('Starting game optimistically without room validation');
            showAdvisory('Starting game...', 'info');
            const basicPlayers = [
                { name: 'Host', isHost: true },
                { name: 'Guest', isHost: false }
            ];

            const aiCount = parseInt(aiPlayerCountSelect?.value, 10) || 0;
            for (let i = 0; i < aiCount; i++) {
                basicPlayers.push({
                    name: `AI Player ${i + 1}`,
                    userId: 'ai_' + Math.random().toString(36).substring(2, 10),
                    isHost: false,
                    isAI: true,
                    tokenIndex: basicPlayers.length,
                    tokenImage: `assets/images/t${(basicPlayers.length % 9) + 1}.png`,
                    money: 16500,
                    properties: [],
                    bankrupt: false,
                    goPassCount: 0,
                    inJail: false,
                    jailTurns: 0,
                    consecutiveDoubles: 0,
                    size: 62
                });
            }

            await startMultiplayerGame(basicPlayers);
        }
        
        // Re-enable button and update text on success
        const startBtn = document.getElementById('start-game-btn');
        startBtn.disabled = false;
        startBtn.textContent = 'Game Started';
        startBtn.style.background = '#4CAF50';
        
    } catch (error) {
        console.error('Error starting multiplayer game:', error);
        showAdvisory('Failed to start game: ' + error.message, 'error');
        
        // Re-enable button on error
        const startBtn = document.getElementById('start-game-btn');
        startBtn.disabled = false;
        startBtn.textContent = 'Start Game';
    }
});

joinRoomBtn.addEventListener('click', async () => {
    console.log('Join room button clicked');
    try {
        console.log('About to call findAvailableRooms...');
        showAdvisory('Searching for available rooms...', 'info');
        const availableRooms = await findAvailableRooms();
        console.log('findAvailableRooms returned:', availableRooms);
        console.log('Number of rooms found:', availableRooms.length);
        roomList.innerHTML = '';
        
        // Add manual room ID input section
        const manualJoinDiv = document.createElement('div');
        manualJoinDiv.style.cssText = 'margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 4px;';
        manualJoinDiv.innerHTML = `
            <div style="margin-bottom: 8px; font-size: 14px; color: #ccc;">Enter Room Code:</div>
            <div style="display: flex; gap: 8px;">
                <input id="manual-room-input" type="text" placeholder="Room code" style="flex: 1; padding: 6px; border-radius: 4px; border: 1px solid #666; background: rgba(0,0,0,0.3); color: white;">
                <button onclick="joinRoomManually()" style="padding: 6px 12px; background: #4CAF50; border: none; border-radius: 4px; color: white; cursor: pointer;">Join</button>
            </div>
        `;
        roomList.appendChild(manualJoinDiv);
        console.log('Manual join div added');
        
        // Add separator
        const separator = document.createElement('div');
        separator.style.cssText = 'border-top: 1px solid #666; margin: 15px 0; padding-top: 15px;';
        separator.innerHTML = '<div style="text-align: center; color: #ccc; font-size: 14px;">Available Rooms</div>';
        roomList.appendChild(separator);
        console.log('Separator added');
        
        if (availableRooms.length === 0) {
            console.log('No available rooms found, showing message');
            const noRoomsDiv = document.createElement('div');
            noRoomsDiv.style.cssText = 'text-align: center; padding: 10px; color: #999;';
            noRoomsDiv.textContent = 'No available rooms found';
            roomList.appendChild(noRoomsDiv);
        } else {
            console.log('Adding', availableRooms.length, 'rooms to the list');
            availableRooms.forEach(room => {
                console.log('Adding room:', room.id, 'with', room.players.length, 'players');
                const roomElement = document.createElement('div');
                roomElement.className = 'room-item';
                
                // Format creation time
                const createdAt = room.createdAt ? new Date(room.createdAt).toLocaleTimeString() : 'Unknown';
                
                // Get host name
                const hostPlayer = room.players.find(p => p.isHost);
                const hostName = hostPlayer ? hostPlayer.name : 'Unknown';
                
                // Skip rooms with Unknown creators
                if (hostName === 'Unknown') {
                    console.log('Skipping room with Unknown creator:', room.id);
                    return;
                }
                
                roomElement.innerHTML = `
                    <div style="flex: 1;">
                        <div style="font-weight: bold; color: #4CAF50;">Room: ${room.id}</div>
                        <div style="font-size: 12px; color: #ccc;">Host: ${hostName}</div>
                        <div style="font-size: 12px; color: #ccc;">Players: ${room.players.length}/${room.maxPlayers || 2}</div>
                        <div style="font-size: 12px; color: #ccc;">Created: ${createdAt}</div>
                    </div>
                    <button onclick="joinRoom('${room.id}')" style="padding: 6px 12px; background: #2196F3; border: none; border-radius: 4px; color: white; cursor: pointer; margin-left: 10px;">Join</button>
                `;
                roomElement.style.cssText = 'display: flex; align-items: center; padding: 12px; background: rgba(255, 255, 255, 0.1); margin-bottom: 8px; border-radius: 4px; border: 1px solid #666;';
                roomList.appendChild(roomElement);
            });
        }
        
        // Add refresh and debug buttons
        const refreshDiv = document.createElement('div');
        refreshDiv.style.cssText = 'text-align: center; margin-top: 15px; padding-top: 15px; border-top: 1px solid #666;';
        refreshDiv.innerHTML = `
            <button onclick="refreshRoomList()" style="padding: 8px 16px; background: #666; border: none; border-radius: 4px; color: white; cursor: pointer; margin-right: 4px;">ðŸ”„ Refresh Room List</button>
            <button onclick="showAllRooms()" style="padding: 8px 16px; background: #ff9800; border: none; border-radius: 4px; color: white; cursor: pointer; margin-right: 4px;">ðŸ” Debug: Show All Rooms</button>
        `;
        roomList.appendChild(refreshDiv);
        
        console.log('About to show room list');
        roomList.style.display = 'block';
        console.log('Room list display set to block, current style:', roomList.style.display);
    } catch (error) {
        console.error('Error loading available rooms:', error);
        showAdvisory('Failed to load available rooms: ' + error.message, 'error');
    }
});

// Add function to join room manually
window.joinRoomManually = async () => {
    console.log('joinRoomManually called');
    const manualRoomInput = document.getElementById('manual-room-input');
    const roomId = manualRoomInput.value.trim().toUpperCase();
    const playerName = document.getElementById('player1-name').value.trim();
    
    console.log('Manual join attempt:', {
        roomId: roomId,
        playerName: playerName,
        roomIdLength: roomId.length,
        playerNameLength: playerName.length
    });
    
    if (!playerName) {
        console.log('No player name provided for manual join');
        showAdvisory('Please enter your name first', 'error');
        return;
    }
    
    if (!roomId) {
        console.log('No room code provided for manual join');
        showAdvisory('Please enter a room code', 'error');
        return;
    }
    
    console.log('Calling joinRoom with roomId:', roomId);
    
    // Store the player name globally for later use
    window.localPlayerName = playerName;
    
    await joinRoom(roomId);
};

// Add function to refresh room list
window.refreshRoomList = async () => {
    console.log('Refreshing room list...');
    showAdvisory('Refreshing room list...', 'info');
    
    // Trigger the join room button click to refresh the list
    if (joinRoomBtn) {
        joinRoomBtn.click();
    }
};

// Add debug function to show all rooms
window.showAllRooms = async () => {
    console.log('Debug: Showing all rooms...');
            // showAdvisory('Debug: Fetching all rooms (including started/full)...', 'info'); // Disabled - don't show debug messages
    
    try {
        // Call findAvailableRooms but also get all rooms for debugging
        const allRooms = await findAllRoomsDebug();
        console.log('Debug: All rooms found:', allRooms);
        
        roomList.innerHTML = '';
        
        // Add manual room ID input section
        const manualJoinDiv = document.createElement('div');
        manualJoinDiv.style.cssText = 'margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 4px;';
        manualJoinDiv.innerHTML = `
            <div style="margin-bottom: 8px; font-size: 14px; color: #ccc;">Enter Room Code:</div>
            <div style="display: flex; gap: 8px;">
                <input id="manual-room-input" type="text" placeholder="Room code" style="flex: 1; padding: 6px; border-radius: 4px; border: 1px solid #666; background: rgba(0,0,0,0.3); color: white;">
                <button onclick="joinRoomManually()" style="padding: 6px 12px; background: #4CAF50; border: none; border-radius: 4px; color: white; cursor: pointer;">Join</button>
            </div>
        `;
        roomList.appendChild(manualJoinDiv);
        
        // Add separator
        const separator = document.createElement('div');
        separator.style.cssText = 'border-top: 1px solid #666; margin: 15px 0; padding-top: 15px;';
        separator.innerHTML = '<div style="text-align: center; color: #ccc; font-size: 14px;">All Rooms (Debug Mode)</div>';
        roomList.appendChild(separator);
        
        if (allRooms.length === 0) {
            const noRoomsDiv = document.createElement('div');
            noRoomsDiv.style.cssText = 'text-align: center; padding: 10px; color: #999;';
            noRoomsDiv.textContent = 'No rooms found in database';
            roomList.appendChild(noRoomsDiv);
        } else {
            allRooms.forEach(room => {
                const roomElement = document.createElement('div');
                
                const createdAt = room.createdAt ? new Date(room.createdAt).toLocaleTimeString() : 'Unknown';
                const hostPlayer = room.players.find(p => p.isHost);
                const hostName = hostPlayer ? hostPlayer.name : 'Unknown';
                const isAvailable = !room.gameStarted && room.players.length < (room.maxPlayers || 2);
                
                roomElement.innerHTML = `
                    <div style="flex: 1;">
                        <div style="font-weight: bold; color: ${isAvailable ? '#4CAF50' : '#f44336'};">Room: ${room.id}</div>
                        <div style="font-size: 12px; color: #ccc;">Host: ${hostName}</div>
                        <div style="font-size: 12px; color: #ccc;">Players: ${room.players.length}/${room.maxPlayers || 2}</div>
                        <div style="font-size: 12px; color: #ccc;">Status: ${room.gameStarted ? 'Started' : 'Waiting'}</div>
                        <div style="font-size: 12px; color: #ccc;">Created: ${createdAt}</div>
                    </div>
                    ${isAvailable ? `<button onclick="joinRoom('${room.id}')" style="padding: 6px 12px; background: #2196F3; border: none; border-radius: 4px; color: white; cursor: pointer; margin-left: 10px;">Join</button>` : '<span style="color: #f44336; margin-left: 10px;">Unavailable</span>'}
                `;
                roomElement.style.cssText = `display: flex; align-items: center; padding: 12px; background: rgba(255, 255, 255, 0.1); margin-bottom: 8px; border-radius: 4px; border: 1px solid ${isAvailable ? '#4CAF50' : '#f44336'};`;
                roomList.appendChild(roomElement);
            });
        }
        
        // Add back button
        const backDiv = document.createElement('div');
        backDiv.style.cssText = 'text-align: center; margin-top: 15px; padding-top: 15px; border-top: 1px solid #666;';
        backDiv.innerHTML = '<button onclick="refreshRoomList()" style="padding: 8px 16px; background: #666; border: none; border-radius: 4px; color: white; cursor: pointer;">â† Back to Available Rooms</button>';
        roomList.appendChild(backDiv);
        
        roomList.style.display = 'block';
        
    } catch (error) {
        console.error('Error in debug room listing:', error);
        showAdvisory('Failed to load debug room list: ' + error.message, 'error');
    }
};

// Test room creation disabled
}

// Add this function to handle joining a room
window.joinRoom = async (roomId) => {
    console.log('joinRoom called with roomId:', roomId);
    
    // Debug the player name input field
    const playerNameElement = document.getElementById('player1-name');
    console.log('Player name element details:', {
        exists: !!playerNameElement,
        value: playerNameElement ? playerNameElement.value : 'ELEMENT NOT FOUND',
        trimmedValue: playerNameElement ? playerNameElement.value.trim() : 'ELEMENT NOT FOUND'
    });
    
    const playerName = playerNameElement ? playerNameElement.value.trim() : '';
    
    console.log('joinRoom details:', {
        roomId: roomId,
        playerName: playerName,
        roomIdType: typeof roomId,
        playerNameType: typeof playerName,
        playerNameLength: playerName.length
    });
    
    if (!playerName) {
        console.log('No player name provided in joinRoom');
        showAdvisory('Please enter your name in the "Player Name" field at the top of the screen first, then try joining again', 'error');
        
        // Try to focus the player name input field
        if (playerNameElement) {
            playerNameElement.focus();
            playerNameElement.style.border = '2px solid #ff0000';
            setTimeout(() => {
                playerNameElement.style.border = '';
            }, 3000);
        }
        return;
    }

    try {
        console.log('About to call joinGameRoom with:', roomId, playerName);
        showAdvisory('Joining room...', 'info');
        
        // Store the player name globally for later use
        window.localPlayerName = playerName;
        
        const joinData = await joinGameRoom(roomId, playerName);
        console.log('joinGameRoom completed successfully');
        
        // Check if name was changed due to conflict
        if (joinData.nameChanged) {
          console.log(`Name changed from "${playerName}" to "${joinData.playerName}" due to conflict`);
          showAdvisory(`Your name was changed to "${joinData.playerName}" to avoid conflict with existing player.`, 'warning');
          // Update the player name input field
          const playerNameElement = document.getElementById('player1-name');
          if (playerNameElement) {
            playerNameElement.value = joinData.playerName;
          }
          window.localPlayerName = joinData.playerName;
        }
        
        currentRoomId = roomId;
        currentUserId = joinData.userId;
        isHost = false;
        isMultiplayerGame = true; // Set multiplayer flag when joining
        
        console.log('User ID assigned:', currentUserId);
        console.log('Join data received:', joinData);
        
        console.log('Updating UI elements...');
        // Hide UI elements
        if (roomList) roomList.style.display = 'none';
        if (roomIdInput) roomIdInput.style.display = 'none';
        if (createRoomBtn) createRoomBtn.style.display = 'none';
        if (joinRoomBtn) joinRoomBtn.style.display = 'none';
        
        console.log('About to subscribe to game room...');
        subscribeToGameRoom();
        console.log('Subscription completed');
        
        showAdvisory('Successfully joined room: ' + roomId + '. Waiting for other players...', 'success');
        
        console.log('About to show multiplayer status...');
        // Show multiplayer status window (disabled)
        // showMultiplayerStatus(); // Disabled - don't show multiplayer status window
        
        // Show UserIDs panel (disabled)
        // showUserIDsPanel(); // Disabled - don't show UserIDs window
        
        // Test with dummy data to verify panel works for guest (disabled)
        console.log('Testing UserIDs panel with dummy data for guest (disabled)');
        // updateUserIDsPanel([
        //     { name: 'Host Player', userId: 'host_12345', isHost: true },
        //     { name: playerName, userId: currentUserId, isHost: false }
        // ]);
        console.log('joinRoom completed successfully');
    } catch (error) {
        console.error('Error in joinRoom:', error);
        showAdvisory('Failed to join room: ' + error.message, 'error');
    }
};

function subscribeToGameRoom() {
    if (gameStateUnsubscribe) {
        gameStateUnsubscribe();
    }
    if (!currentRoomId) {
        console.error('subscribeToGameRoom called but currentRoomId is null');
        showAdvisory('Please join or create a room first.', 'error');
        return;
    }
    try {
        // Ensure firebase-init.js has a valid reference to the current room before subscribing
        const ref = ensureGameRoomConnection(currentRoomId);
        console.log('subscribeToGameRoom using ref:', ref?.id);
        if (!ref) {
            console.error('Failed to establish connection to room:', currentRoomId);
            showAdvisory('Failed to connect to room', 'error');
            return;
        }

        // Output current multiplayer state for debugging (disabled)
        // if (window.debugMultiplayerState) {
        //     window.debugMultiplayerState(); // Disabled - don't show debug info automatically
        // }
        const startSubscription = () => subscribeToGameState(async (gameState) => {
            console.log('ðŸŽ® Game state update received:', gameState);
            console.log('ðŸŽ® Current state - isHost:', isHost, 'gameStarted:', gameState?.gameStarted, 'players:', gameState?.players?.length);
            
            // Production-safe: Check for immediate auto-start on first state update
            if (gameState && !gameState.gameStarted && gameState.players?.length >= (gameState.maxPlayers || 2)) {
                console.log('ðŸŽ® PRODUCTION: Detected full room on state update, triggering auto-start check');
            }
        
        // Validate gameState before proceeding
        if (!gameState) {
            console.warn('Received null or undefined gameState');
            console.log('ðŸ” Debug: gameState is null/undefined, this is normal before game starts');
            return;
        }
        
        console.log('Update conditions:', {
            gameStarted: gameState.gameStarted,
            isHost: isHost,
            currentPlayerIndex: currentPlayerIndex,
            gameStateCurrentTurn: gameState.currentTurn,
            isMultiplayerGame: isMultiplayerGame,
            hasPlayers: Array.isArray(gameState.players),
            playersLength: gameState.players?.length
        });
        
        // Only update player list if we have valid players array
        if (gameState.players) {
            // Double-check that players is an array after Firebase processing
            if (!Array.isArray(gameState.players)) {
                console.warn('Players is still not an array after Firebase processing, attempting local fix');
                if (typeof gameState.players === 'object') {
                    const keys = Object.keys(gameState.players).sort((a, b) => parseInt(a) - parseInt(b));
                    gameState.players = keys.map(key => gameState.players[key]);
                    console.log('Locally converted players object to array:', gameState.players);
                }
            }
            updatePlayerList(gameState.players);

            console.log('ðŸŽ® Auto-start check - isHost:', isHost, 'gameStarted:', gameState.gameStarted, 'playersLength:', gameState.players.length, 'maxPlayers:', gameState.maxPlayers || 2);
            
            // Enhanced auto-start logic with fallback for rooms without maxPlayers
            const effectiveMaxPlayers = gameState.maxPlayers || 2;
            const hasAIBots = gameState.aiBots > 0;
            const hasHumanPlayer = gameState.players.some(p => !p.isAI);
            
            // Enhanced auto-start conditions
            const shouldAutoStart = !gameState.gameStarted && (
                // Room is full
                gameState.players.length >= effectiveMaxPlayers ||
                // OR room has AI bots and at least one human player
                (hasAIBots && hasHumanPlayer)
            );
            
            console.log('ðŸŽ® Enhanced auto-start check:', {
                gameStarted: gameState.gameStarted,
                playersLength: gameState.players.length,
                effectiveMaxPlayers: effectiveMaxPlayers,
                hasAIBots: hasAIBots,
                hasHumanPlayer: hasHumanPlayer,
                shouldAutoStart: shouldAutoStart
            });
            
            if (shouldAutoStart) {
                // Check if any player in the room is a host
                const hasHost = gameState.players.some(p => p.isHost);
                if (hasHost) {
                    console.log('ðŸŽ® Room has host and meets auto-start conditions, starting game');
                    const startBtn = document.getElementById('start-game-btn');
                    if (startBtn) {
                        startBtn.disabled = true;
                    }
                    startMultiplayerGame(gameState.players);
                } else {
                    // If no host but meets conditions, start the game anyway (first player becomes de facto host)
                    console.log('ðŸŽ® Room meets auto-start conditions, starting game (first player will be host)');
                    const startBtn = document.getElementById('start-game-btn');
                    if (startBtn) {
                        startBtn.disabled = true;
                    }
                    startMultiplayerGame(gameState.players);
                }
            }
        } else {
            console.warn('gameState.players is missing or invalid:', gameState.players);
        }
        
        // Only start the game if it hasn't been started yet and we're not the host
        const gameContainer = document.getElementById('game-container');
        const isGameContainerHidden = gameContainer.style.display === 'none' || gameContainer.style.display === '';
        
        console.log('ðŸŽ® Guest auto-start check - gameStarted:', gameState.gameStarted, 'isHost:', isHost, 'isGameContainerHidden:', isGameContainerHidden);
        if (gameState.gameStarted && !isHost && isGameContainerHidden) {
            console.log('ðŸŽ® Guest: Starting game from Firebase state');
            console.log('Game container display:', gameContainer.style.display);
            startGame(gameState);
        }
        
        // Update game state if it's already started (for ongoing gameplay)
        // Apply updates for BOTH host and guest when game is running
        if (gameState.gameStarted && !isGameContainerHidden && isMultiplayerGame) {
            console.log('Applying game state update from Firebase');
            updateGameFromState(gameState);
            
            // Force immediate visual update to show token movements
            console.log('Forcing immediate visual update after Firebase sync');
            setTimeout(async () => {
                // Safety check - only update if canvas is available
                if (canvas && !isInitializing) {
                    await updateGameFrame();
                    console.log('Forced visual update completed');
                } else {
                    console.log('Forced visual update skipped - canvas not ready or initialization in progress');
                }
            }, 100);
        }
        });

        try {
            gameStateUnsubscribe = startSubscription();
        } catch (subErr) {
            console.warn('Initial subscribeToGameState failed, retrying...', subErr);
            
            // Check if it's a connection error
            if (subErr.message?.includes('NS_BASE_STREAM_CLOSED') || 
                subErr.code === 'unavailable' ||
                subErr.message?.includes('stream closed')) {
                console.log('ðŸ”„ Connection error detected, attempting recovery...');
                
                // Wait a bit before retrying
                setTimeout(() => {
                    try {
                        ensureGameRoomConnection(currentRoomId);
                        gameStateUnsubscribe = startSubscription();
                        console.log('âœ… Connection recovery successful');
                    } catch (recoveryError) {
                        console.error('âŒ Connection recovery failed:', recoveryError);
                        showAdvisory('Connection lost. Please refresh the page to reconnect.', 'warning');
                    }
                }, 2000);
            } else {
                // For other errors, try immediate retry
                ensureGameRoomConnection(currentRoomId);
                gameStateUnsubscribe = startSubscription();
            }
        }
    } catch (error) {
        console.error('subscribeToGameState failed:', error);
        
        // Provide more specific error messages
        if (error.message?.includes('NS_BASE_STREAM_CLOSED') || 
            error.code === 'unavailable') {
            showAdvisory('Connection lost. The game will attempt to reconnect automatically.', 'warning');
        } else if (error.message?.includes('Not connected to a game room')) {
            showAdvisory('Failed to subscribe to game state. Please join a room first.', 'error');
        } else {
            showAdvisory('Failed to connect to game state: ' + error.message, 'error');
        }
    }
}

function updatePlayerList(players) {
    console.log('updatePlayerList called with:', players);
    
    // Validate that players is an array
    if (!Array.isArray(players)) {
        console.warn('updatePlayerList called with non-array players:', typeof players, players);
        players = []; // Default to empty array
    }
    
    // Debug player data integrity
    console.log('Player data integrity check:');
    players.forEach((player, index) => {
        console.log(`Player ${index}:`, {
            name: player.name,
            userId: player.userId,
            isHost: player.isHost,
            hasName: !!player.name,
            hasUserId: !!player.userId,
            hasIsHost: player.isHost !== undefined,
            fullPlayerObject: player
        });
    });
    
    if (playerList) {
        playerList.innerHTML = '';
        playerList.style.display = 'block';
        
        players.forEach(player => {
            const playerElement = document.createElement('div');
            playerElement.className = 'player-list-item';
            playerElement.textContent = player.name || 'Unknown Player';
            if (player.isHost) {
                playerElement.innerHTML += '<span class="host-badge">Host</span>';
            }
            playerList.appendChild(playerElement);
        });
    }
    
    // Also update the multiplayer status window (disabled)
    // updateMultiplayerStatus(players); // Disabled - don't update multiplayer status window
    
    // Update the UserIDs panel (disabled)
    console.log('About to call updateUserIDsPanel from updatePlayerList (disabled)');
    // updateUserIDsPanel(players); // Disabled - don't update UserIDs window
}

// Function to show/create multiplayer status window
function showMultiplayerStatus() {
    console.log('showMultiplayerStatus called, currentRoomId:', currentRoomId, 'isHost:', isHost);
    let statusWindow = document.getElementById('multiplayer-status');
    
    if (!statusWindow) {
        console.log('Creating new multiplayer status window');
        statusWindow = document.createElement('div');
        statusWindow.id = 'multiplayer-status';
        statusWindow.style.cssText = `
            position: fixed;
            top: 20px;
            left: 20px;
            width: 280px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #4CAF50;
            border-radius: 8px;
            padding: 15px;
            color: white;
            font-family: Arial, sans-serif;
            z-index: 1001;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        `;
        document.body.appendChild(statusWindow);
        console.log('Status window created and added to body');
    } else {
        console.log('Status window already exists, updating content');
    }
    
    // Create the HTML content in parts to avoid template literal issues
    const headerHtml = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="margin: 0; color: #4CAF50;">Player Info Multiplayer</h3>
            <button onclick="hideMultiplayerStatus()" style="background: #f44336; border: none; color: white; padding: 4px 8px; border-radius: 4px; cursor: pointer;">Ã—</button>
        </div>
    `;
    
    const contentHtml = `
        <div id="status-content">
            <div style="margin-bottom: 8px;">
                <strong>Room Code:</strong> 
                <span style="font-family: monospace; background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px; color: #4CAF50; font-size: 16px;">${currentRoomId || 'Loading...'}</span>
            </div>
            <div style="margin-bottom: 8px;">
                <strong>Status:</strong> ${isHost ? 'Host' : 'Guest'}
            </div>
            <div style="margin-bottom: 8px;">
                <strong>Players:</strong>
                <div id="status-players" style="margin-top: 4px;"></div>
            </div>
        </div>
    `;
    
    const buttonHtml = isHost ? 
        '<div style="margin-top: 10px;"><button id="status-start-game-btn" style="background: #4CAF50; border: none; color: white; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px; width: 100%;">ðŸŽ® Start Game</button></div>' : 
        '<div style="margin-top: 10px;"><button id="status-debug-start-btn" style="background: #ff9800; border: none; color: white; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px; width: 100%;">ðŸ”§ Debug: Force Start</button></div>';
    
    // Validate HTML content before setting innerHTML
    const fullHtml = headerHtml + contentHtml + buttonHtml;
    console.log('Setting multiplayer status HTML content:', fullHtml.substring(0, 200) + '...');
    
    try {
        statusWindow.innerHTML = fullHtml;
        console.log('Multiplayer status HTML content set successfully');
    } catch (error) {
        console.error('Error setting multiplayer status HTML:', error);
        // Fallback to text content if HTML fails
        statusWindow.textContent = `Room: ${currentRoomId || 'Loading...'} | Status: ${isHost ? 'Host' : 'Guest'}`;
    }
    
    // Add event listener for the start game button in the status window
    if (isHost) {
        console.log('Adding start game button event listener to status window');
        const statusStartBtn = statusWindow.querySelector('#status-start-game-btn');
        if (statusStartBtn) {
            statusStartBtn.addEventListener('click', () => {
                console.log('Status window start game button clicked');
                // Prevent double-clicking by checking if already disabled
                const mainStartBtn = document.getElementById('start-game-btn');
                if (mainStartBtn && !mainStartBtn.disabled && !isInitializing) {
                    // Trigger the same event as the main start game button
                    mainStartBtn.click();
                } else {
                    console.log('Main start game button already disabled or initializing, ignoring status button click');
                }
            });
        }
    } else {
        // Add debug start button for guests
        console.log('Adding debug start button event listener to status window');
        const debugStartBtn = statusWindow.querySelector('#status-debug-start-btn');
        if (debugStartBtn) {
            debugStartBtn.addEventListener('click', async () => {
                console.log('Debug force start button clicked');
                try {
                    // Force start the game for debugging
                    const mockGameState = {
                        gameStarted: true,
                        players: [
                            { name: 'Host', currentSquare: 'go', money: 16500, properties: [], isHost: true },
                            { name: 'Guest', currentSquare: 'go', money: 16500, properties: [], isHost: false }
                        ],
                        currentTurn: 0,
                        lastDiceRoll: null,
                        properties: {}
                    };
                    await startGame(mockGameState);
                    // showAdvisory('Debug: Game force started!', 'info'); // Disabled - don't show debug messages
                } catch (error) {
                    console.error('Debug start failed:', error);
                    showAdvisory('Debug start failed: ' + error.message, 'error');
                }
            });
        }
    }
    
    statusWindow.style.display = 'block';
}

// Function to update multiplayer status window
function updateMultiplayerStatus(players = []) {
    const statusWindow = document.getElementById('multiplayer-status');
    if (!statusWindow) return;
    
    // Validate that players is an array
    if (!Array.isArray(players)) {
        console.warn('updateMultiplayerStatus called with non-array players:', typeof players, players);
        players = []; // Default to empty array
    }
    
    const playersDiv = document.getElementById('status-players');
    if (playersDiv && players.length > 0) {
        playersDiv.innerHTML = players.map(player => `
            <div style="padding: 3px 0; font-size: 14px;">
                ${player?.name || 'Unknown'} ${player?.isHost ? '<span style="background: #4CAF50; padding: 1px 4px; border-radius: 2px; font-size: 10px;">HOST</span>' : ''}
            </div>
        `).join('');
    }
}

// Function to show UserIDs panel
function showUserIDsPanel() {
    console.log('showUserIDsPanel called');
    const useridsPanel = document.getElementById('userids-panel');
    if (useridsPanel) {
        useridsPanel.style.display = 'block';
        console.log('UserIDs panel shown');
    } else {
        console.log('userids-panel element not found');
    }
}

// Function to hide UserIDs panel
function hideUserIDsPanel() {
    const useridsPanel = document.getElementById('userids-panel');
    if (useridsPanel) {
        useridsPanel.style.display = 'none';
    }
}

// Function to update UserIDs panel
function updateUserIDsPanel(players = []) {
    console.log('updateUserIDsPanel called with players:', players);
    const useridsContent = document.getElementById('userids-content');
    if (!useridsContent) {
        console.log('userids-content element not found');
        return;
    }
    
    // Validate that players is an array
    if (!Array.isArray(players)) {
        console.warn('updateUserIDsPanel called with non-array players:', typeof players, players);
        players = []; // Default to empty array
    }
    
    if (players.length === 0) {
        console.log('No players provided to updateUserIDsPanel');
        useridsContent.innerHTML = '<div style="text-align: center; color: #999;">No players</div>';
        return;
    }
    
    console.log('Updating UserIDs panel with', players.length, 'players');
    players.forEach((player, index) => {
        console.log(`Player ${index}:`, {
            name: player?.name,
            userId: player?.userId,
            isHost: player?.isHost
        });
    });
    
    useridsContent.innerHTML = players.map(player => `
        <div style="padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; flex-direction: column;">
            <div style="font-weight: bold; color: ${player?.isHost ? '#4CAF50' : '#fff'}; margin-bottom: 2px; display: flex; align-items: center;">
                <span style="display: inline-block; width: 12px; height: 12px; background-color: ${player?.color || '#ffffff'}; border: 1px solid #000; border-radius: 50%; margin-right: 6px;"></span>
                ${player?.name || 'Unknown'} ${player?.colorName ? `(${player.colorName})` : ''} ${player?.isHost ? '(Host)' : ''}
            </div>
            <div style="color: #aaa; font-family: monospace; font-size: 10px; word-break: break-all;">
                ${player?.userId || 'No ID'}
            </div>
        </div>
    `).join('');
    
    console.log('UserIDs panel updated with HTML:', useridsContent.innerHTML);
}

// Function to hide multiplayer status window
window.hideMultiplayerStatus = function() {
    const statusWindow = document.getElementById('multiplayer-status');
    if (statusWindow) {
        statusWindow.style.display = 'none';
    }
};

// Batched Firebase sync system to reduce quota usage
let pendingFirebaseSync = false;
let firebaseSyncTimeout = null;
const FIREBASE_SYNC_DELAY = 2000; // Wait 2 seconds before syncing to batch operations

// Helper function to sync game state with Firebase (batched)
async function syncGameStateToFirebase() {
    if (!isMultiplayerGame || !currentRoomId) return;
    
    // If a sync is already pending, don't create another one
    if (pendingFirebaseSync) {
        console.log('syncGameStateToFirebase: Sync already pending, skipping duplicate');
        return;
    }
    
    // Mark sync as pending and set timer
    pendingFirebaseSync = true;
    
    // Clear any existing timeout
    if (firebaseSyncTimeout) {
        clearTimeout(firebaseSyncTimeout);
    }
    
    // Batch multiple sync requests into one operation
    firebaseSyncTimeout = setTimeout(async () => {
        try {
            await performActualFirebaseSync();
        } catch (error) {
            console.error('Batched Firebase sync failed:', error);
        } finally {
            pendingFirebaseSync = false;
            firebaseSyncTimeout = null;
        }
    }, FIREBASE_SYNC_DELAY);
    
    console.log('syncGameStateToFirebase: Batched sync scheduled');
}

// Perform the actual Firebase sync operation
async function performActualFirebaseSync() {
    if (!isMultiplayerGame || !currentRoomId) return;
    
    try {
        // CRITICAL FIX: Enhanced validation to prevent player data corruption
        if (!Array.isArray(players) || players.length === 0) {
            console.error('performActualFirebaseSync: Invalid players array, aborting sync:', players);
            return;
        }
        
        // Validate currentPlayerIndex
        if (currentPlayerIndex < 0 || currentPlayerIndex >= players.length) {
            console.error('performActualFirebaseSync: Invalid currentPlayerIndex, resetting to 0:', currentPlayerIndex);
            currentPlayerIndex = 0;
        }
        
        // Filter out any completely corrupted player data (but preserve players with missing names)
        const validPlayers = players.filter(p => {
            // Keep players that exist as objects, even if name is missing/undefined
            if (!p || typeof p !== 'object') return false;
            
            // Keep players that have at least some identifying information
            return p.userId || p.name || p.isHost !== undefined || p.x !== undefined;
        });
        
        if (validPlayers.length === 0) {
            console.error('performActualFirebaseSync: No valid players after filtering, aborting sync');
            return;
        }
        
        if (validPlayers.length !== players.length) {
            console.warn('performActualFirebaseSync: Filtered out completely corrupted players', {
                originalCount: players.length,
                validCount: validPlayers.length,
                filteredOut: players.length - validPlayers.length
            });
        }
        
        const gameStateUpdate = {
            players: validPlayers.map((p, index) => {
                // Ensure player name is preserved - check multiple sources
                let playerName = p.name;
                if (!playerName || playerName === 'undefined') {
                    // Try to get name from stored local player name if this is the current player
                    if (index === currentPlayerIndex && window.localPlayerName) {
                        playerName = window.localPlayerName;
                        console.log(`ðŸ”§ Recovered name for current player (${index}): ${playerName}`);
                    } else if (p.isHost && index === 0) {
                        // For host player, try to get from input field
                        const inputName = document.getElementById('player1-name')?.value.trim();
                        if (inputName) {
                            playerName = inputName;
                            console.log(`ðŸ”§ Recovered name for host player: ${playerName}`);
                        }
                    } else if (p.userId) {
                        // Try to find name from existing players array by userId
                        const existingPlayer = players.find(existing => existing.userId === p.userId && existing.name && existing.name !== 'undefined');
                        if (existingPlayer) {
                            playerName = existingPlayer.name;
                            console.log(`ðŸ”§ Recovered name from existing player data: ${playerName}`);
                        }
                    }
                }
                
                const finalName = playerName || `Player ${index + 1}`;
                console.log(`ðŸ”§ Syncing player ${index}: name="${finalName}", userId="${p.userId}", originalName="${p.name}"`);
                
                return {
                    name: finalName,
                    userId: p.userId || `user_${index}`,
                    position: p.currentIndexOnPath || 0,
                    currentSquare: p.currentSquare || 'go',
                    currentPathKey: p.currentPathKey || 'gamePath',
                    currentIndexOnPath: p.currentIndexOnPath || 0,
                    isMovingReverse: p.isMovingReverse || false,
                    x: p.x || 0,
                    y: p.y || 0,
                    size: p.size || 62,
                    money: p.money || 16500,
                    properties: p.properties || [],
                    isAI: p.isAI || false,
                    bankrupt: p.bankrupt || false,
                    isHost: p.isHost || false,
                    tokenImage: p.tokenImage || `assets/images/t${index + 1}.png`,
                    tokenIndex: p.tokenIndex || index,
                    inJail: p.inJail || false,
                    jailTurns: p.jailTurns || 0,
                    consecutiveDoubles: p.consecutiveDoubles || 0,
                    stealCards: p.stealCards || 0,
                    goPassCount: p.goPassCount || 0,
                    color: p.color || playerColors[index % playerColors.length],
                    colorName: p.colorName || ['Red', 'Blue', 'Green', 'Yellow', 'Purple'][index % playerColors.length]
                    // Note: Excluding 'image' property to avoid HTMLImageElement serialization
                };
            }),
            currentTurn: currentPlayerIndex,
            lastDiceRoll: { 
                die1: die1Element?.textContent || 0, 
                die2: die2Element?.textContent || 0 
            },
            lastRollWasDoubles: lastRollWasDoubles || false,
            consecutiveDoublesCount: consecutiveDoublesCount || 0,
            diceValues: { 
                die1: parseInt(die1Element?.textContent) || 0, 
                die2: parseInt(die2Element?.textContent) || 0 
            },
            properties: propertyState || {},
            snakePathMoney: snakePathMoney || {}, // Add snake path money synchronization
            boardState: {
                eyePositions: eyePositions || [],
        
                soundSettings: {
                    musicEnabled: currentMusicState !== 'Off',
                    soundEffectsEnabled: true
                }
            }
        };
        
        console.log('Syncing comprehensive game state to Firebase (batched):', gameStateUpdate);
        await syncCompleteGameState(gameStateUpdate);
    } catch (error) {
        console.error('Error syncing game state to Firebase:', error);
    }
}

// Emergency sync function for critical operations (bypasses batching)
async function emergencySyncToFirebase() {
    console.log('Emergency Firebase sync requested - bypassing batch system');
    
    // Clear any pending batched sync
    if (firebaseSyncTimeout) {
        clearTimeout(firebaseSyncTimeout);
        firebaseSyncTimeout = null;
    }
    pendingFirebaseSync = false;
    
    // CRITICAL FIX: Validate player data before emergency sync
    if (!Array.isArray(players) || players.length === 0) {
        console.error('Emergency sync aborted - invalid players array:', players);
        return;
    }
    
    // Validate currentPlayerIndex before sync
    if (currentPlayerIndex < 0 || currentPlayerIndex >= players.length) {
        console.error('Emergency sync aborted - invalid currentPlayerIndex:', currentPlayerIndex, 'players length:', players.length);
        // Reset to valid index
        currentPlayerIndex = 0;
    }
    
    // Perform immediate sync
    await performActualFirebaseSync();
}

// Function to start a multiplayer game
async function startMultiplayerGame(playersFromRoom) {
    try {
        console.log('ðŸš€ startMultiplayerGame called with players:', playersFromRoom);
        console.log('ðŸš€ Players from room length:', playersFromRoom?.length);
        
        // Set multiplayer mode
        isMultiplayerGame = true;

        // Hide the start button if it exists (auto-start scenario)
        const startBtn = document.getElementById('start-game-btn');
        if (startBtn) {
            startBtn.style.display = 'none';
        }
        
        // Reset game state
        isInitialRoll = true; // We'll roll to determine first player
        consecutiveDoublesCount = 0;
        lastRollWasDoubles = false;
        isAITurnInProgress = false; // reset AI turn flag
        currentPlayerIndex = 0;
        console.log('Multiplayer game starting with currentPlayerIndex:', currentPlayerIndex);
        
        // Mobile-specific initialization fixes
        if (isMobile) {
            console.log('ðŸ“± Mobile device detected - applying mobile-specific fixes');
            
            // Reset mobile pan position
            try {
                resetCanvasPan();
            } catch (error) {
                console.warn('resetCanvasPan failed:', error);
            }
            
            // Ensure mobile controls are properly initialized
            setTimeout(() => {
                try {
                    initializeMobileControls();
                } catch (error) {
                    console.warn('Mobile controls initialization failed:', error);
                }
            }, 500);
        }

        // Hide intro screen and show game container with mobile-safe approach
        try {
            const introScreen = document.getElementById('intro-screen');
            const gameContainer = document.getElementById('game-container');
            
            if (introScreen) {
                introScreen.style.display = 'none';
            }
            if (gameContainer) {
                gameContainer.style.display = 'block';
                
                // Force viewport adjustment for mobile devices
                if (isMobile) {
                    gameContainer.style.touchAction = 'pan-x pan-y';
                    gameContainer.style.userSelect = 'none';
                    gameContainer.style.webkitUserSelect = 'none';
                }
            }
        } catch (error) {
            console.error('Failed to toggle screen visibility:', error);
        }

        // Initialize the game board first (only if not already initialized)
        const existingCanvas = document.getElementById('gameCanvas');
        const gameContainer = document.getElementById('game-container');
        
        // Check if already initialized first
        if (isGameInitialized && canvas && positionsMap && Object.keys(positionsMap).length > 0) {
            console.log('Game board already fully initialized for multiplayer, skipping all initialization');
        } else {
            console.log('Game board needs initialization for multiplayer...');
            
            // Remove ALL existing canvases to prevent duplicates
            const allCanvasesInDocument = document.querySelectorAll('canvas');
            if (allCanvasesInDocument.length > 0) {
                console.log('Removing', allCanvasesInDocument.length, 'existing canvas elements from startMultiplayerGame');
                allCanvasesInDocument.forEach(canvasEl => canvasEl.remove());
            }
            
            // Reset canvas reference
            canvas = null;
            
            console.log('Calling initGame for multiplayer...');
            try {
                await initGame();
                
                // Mobile-specific post-initialization fixes
                if (isMobile && canvas) {
                    console.log('ðŸ“± Applying mobile canvas fixes');
                    
                    // Ensure canvas is properly sized for mobile
                    const canvasContainer = canvas.parentElement;
                    if (canvasContainer) {
                        canvasContainer.style.touchAction = 'pan-x pan-y';
                        canvasContainer.style.overflow = 'hidden';
                    }
                    
                    // Add mobile-specific event listeners
                    canvas.style.touchAction = 'pan-x pan-y';
                    canvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
                    canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
                }
            } catch (initError) {
                console.error('Failed to initialize game for multiplayer:', initError);
                showAdvisory('Failed to initialize game. Please refresh and try again.', 'error');
                return;
            }
        }

        // Now positionsMap should be loaded
        const startPos = positionsMap.get('go');
        if (!startPos) throw new Error('Starting position "go" not found');

        // Load tokens based on number of players
        const allTokenUrls = [
            'assets/images/t1.png',
            'assets/images/t2.png',
            'assets/images/t3.png',
            'assets/images/t4.png',
            'assets/images/t5.png',
            'assets/images/t6.png',
            'assets/images/t7.png',
            'assets/images/t8.png',
            'assets/images/t9.png'
        ];
        const tokenImages = await loadTokens(allTokenUrls.slice(0, playersFromRoom.length));

        // Initialize players with proper starting positions (all human players in multiplayer)
        if (!Array.isArray(playersFromRoom)) {
            throw new Error('startMultiplayerGame: playersFromRoom is not an array');
        }
        
        players = playersFromRoom.map((playerData, index) => ({
            name: playerData.displayName || playerData.name, // Support both displayName and name
            userId: playerData.uid || playerData.userId || `user_${index}`, // Support both uid and userId
            image: tokenImages[playerData.tokenIndex != null ? playerData.tokenIndex : index],
            tokenImage: playerData.tokenImage || allTokenUrls[index],
            tokenIndex: playerData.tokenIndex != null ? playerData.tokenIndex : index,
            x: startPos.x,
            y: startPos.y,
            currentSquare: 'go',
            currentPathKey: "gamePath",
            currentIndexOnPath: 0,
            isMovingReverse: false,
            size: playerData.size || 62,
            money: playerData.money || 16500,
            isAI: playerData.isAI || false,
            properties: playerData.properties || [],
            bankrupt: playerData.bankrupt || false,
            isCurrentPlayer: index === 0,
            isHost: playerData.isHost, // Use the isHost field from player data
            stealCards: 0, // Reset steal cards at game start
            goPassCount: playerData.goPassCount || 0,
            color: playerData.color,
            colorName: playerData.colorName,
            inJail: playerData.inJail || false,
            jailTurns: playerData.jailTurns || 0,
            consecutiveDoubles: playerData.consecutiveDoubles || 0
        }));

        // Assign colors to all players (only if they don't already have colors)
        const needsColorAssignment = players.some(player => !player.color);
        console.log('ðŸŽ¨ Color assignment check:');
        players.forEach((p, i) => console.log(`  Player ${i}: ${p.name} - color: ${p.color}, colorName: ${p.colorName}`));
        
        if (needsColorAssignment) {
            console.log('Some players missing colors, assigning colors to all players');
            assignPlayerColors(players);
            console.log('ðŸŽ¨ After color assignment:');
            players.forEach((p, i) => console.log(`  Player ${i}: ${p.name} - color: ${p.color}, colorName: ${p.colorName}`));
        } else {
            console.log('All players already have colors assigned, skipping color assignment');
        }

        // Update game_utils with player state
        setPlayers(players);
        
        // Force a re-render to ensure token colors are updated
        console.log('ðŸŽ¨ Forcing game frame update to apply color changes...');
        setTimeout(() => {
            if (typeof updateGameFrame === 'function') {
                updateGameFrame();
            }
        }, 100);

        // Validate that we have valid players before proceeding
        if (!players || players.length === 0) {
            throw new Error('No players initialized for multiplayer game');
        }

        // Ensure currentPlayerIndex is valid
        if (currentPlayerIndex >= players.length) {
            console.warn('currentPlayerIndex out of bounds, resetting to 0');
            currentPlayerIndex = 0;
        }

        // Validate current player exists
        const currentPlayer = players[currentPlayerIndex];
        if (!currentPlayer) {
            throw new Error(`Current player is undefined at index ${currentPlayerIndex}`);
        }

        console.log('Multiplayer players initialized:', players.map(p => ({ name: p.name, isHost: p.isHost })));
        console.log('Current player:', currentPlayer.name, 'at index:', currentPlayerIndex);

        // Update Firebase with the initialized game state using comprehensive initialization
        console.log('Host: Initializing Firebase with complete game state');

        // Ensure firebase-init knows which room to update in case the page was
        // reloaded and the connection reference was lost.
        ensureGameRoomConnection(currentRoomId);
        await startGameWithInitialization(players, positionsMap);
        console.log('Host: Firebase initialization completed');

        // Update game frame to show initial positions
        await updateGameFrame();

        // Show info panel for multiplayer game (UserIDs panel disabled)
        document.getElementById('info-panel').style.display = 'block';
        // showUserIDsPanel(); // Disabled - don't show UserIDs window
        // updateUserIDsPanel(players); // Disabled - don't update UserIDs window
        initializeInfoPanelChecks();
        
        // Start auto-roll timer for first turn
        startAutoRollTimer();

        // Determine first player by dice roll
        isInitialRoll = true;
        const firstMsg = await determineFirstPlayerMultiplayer();
        showAdvisory(firstMsg, 'turn');
        isInitialRoll = false;

        // Mark the player who won the roll as the current player
        players.forEach((p, idx) => {
            p.isCurrentPlayer = (idx === currentPlayerIndex);
        });
        emergencySyncToFirebase();

        // Start the first turn (no auto-roll for multiplayer)
        updateTurnInfo();
        enableDiceSection();
        
        showAdvisory('Multiplayer game started! Take turns rolling the dice.', 'success');
        
        // Start the gojail glow system for multiplayer
        startGojailGlowSystem();
        
        // Start the gojail graves shaking system for multiplayer
        startGojailGravesShakingSystem();
        
        // Initialize bottom player display for multiplayer
        if (typeof updateBottomPlayerDisplay === 'function') {
            updateBottomPlayerDisplay();
        }
        
        // Ensure bottom display is visible in multiplayer mode
        ensureBottomPlayerDisplayVisible();
        
        // Ensure tablet steal card touch handling is working
        if (window.refreshTabletStealCardTouch) {
            setTimeout(() => {
                window.refreshTabletStealCardTouch();
            }, 1000);
        }
        
        // Reset and start the lightning system for multiplayer
        resetLightningSystem();
        startLightningSystem();
        

        
        // Update status window to show game started
        const statusWindow = document.getElementById('multiplayer-status');
        if (statusWindow) {
            const statusContent = statusWindow.querySelector('#status-content');
            if (statusContent) {
                statusContent.innerHTML += '<div style="margin-top: 10px; padding: 8px; background: rgba(76, 175, 80, 0.2); border-radius: 4px; color: #4CAF50; font-weight: bold;">ðŸŽ® Game Started!</div>';
            }
        }
        
        console.log('startMultiplayerGame completed successfully!');
    } catch (error) {
        console.error('Error starting multiplayer game:', error);
        throw error;
    }
}

// Function to start the game
async function startGame(gameState = null) {
    console.log('startGame called with gameState:', gameState);
    
    try {
        // If gameState is provided, use it to initialize the game
        if (gameState) {
            console.log('Initializing guest game from Firebase state');
            
            // Validate gameState.players before using it
            if (!Array.isArray(gameState.players)) {
                console.error('startGame: gameState.players is not an array:', typeof gameState.players, gameState.players);
                throw new Error('Invalid game state: players is not an array');
            }
            
            // Get the "go" position coordinates first
            const goPosition = positionsMap?.get('go') || { x: 0, y: 0 };
            console.log('Go position for player initialization:', goPosition);
            
            // Initialize players from game state (all human in multiplayer)
            players = gameState.players.map((p, index) => {
                // Use provided coordinates if valid, otherwise use go position
                const playerX = (p.x && p.x !== 0) ? p.x : goPosition.x;
                const playerY = (p.y && p.y !== 0) ? p.y : goPosition.y;
                
                console.log(`Initializing player ${p.name}: provided coords (${p.x}, ${p.y}), using coords (${playerX}, ${playerY})`);
                
                return {
                    name: p.name,
                    userId: p.userId || `user_${index}`,
                    image: null, // Will be loaded immediately below
                    x: playerX,
                    y: playerY,
                    position: p.position || 0,
                    currentSquare: p.currentSquare || 'go',
                    currentPathKey: p.currentPathKey || "gamePath",
                    currentIndexOnPath: p.currentIndexOnPath || 0,
                    isMovingReverse: p.isMovingReverse || false,
                    size: p.size || 62,
                    money: p.money || 16500,
                    properties: p.properties || [],
                    isAI: p.isAI || false, // All players are human in multiplayer
                    bankrupt: p.bankrupt || false,
                    isHost: p.isHost || false,
                    tokenImage: p.tokenImage || `assets/images/t${index + 1}.png`,
                    tokenIndex: p.tokenIndex || index,
                    inJail: p.inJail || false,
                    jailTurns: p.jailTurns || 0,
                    consecutiveDoubles: p.consecutiveDoubles || 0,
                    stealCards: 0, // Reset steal cards at game start
                    goPassCount: p.goPassCount || 0,
                    color: p.color || playerColors[index % playerColors.length],
                    colorName: p.colorName || ['Red', 'Blue', 'Green', 'Yellow', 'Purple'][index % playerColors.length]
                };
            });
            
            // Load token images immediately for all players to ensure visibility
            console.log('Guest: Loading token images immediately...');
            await Promise.all(players.map((player, index) => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        player.image = img;
                        console.log(`Guest: Token image loaded for ${player.name}: ${player.tokenImage}`);
                        resolve();
                    };
                    img.onerror = () => {
                        console.error(`Guest: Failed to load token image for ${player.name}: ${player.tokenImage}`);
                        resolve(); // Continue even if image fails to load
                    };
                    img.src = player.tokenImage;
                });
            }));
            console.log('Guest: All token images loaded');
            
            currentPlayerIndex = gameState.currentTurn || 0;
            const currentPlayer = players[currentPlayerIndex];
            isAITurn = currentPlayer ? currentPlayer.isAI : false;

            // Ensure each player reflects the correct current turn
            players.forEach((p, idx) => {
                p.isCurrentPlayer = (idx === currentPlayerIndex);
            });
            
            console.log('Guest: Received game state with currentTurn:', gameState.currentTurn);
            console.log('Guest: Set currentPlayerIndex to:', currentPlayerIndex);
            console.log('Players initialized:', players);
            console.log('Current player index:', currentPlayerIndex);
            
            // Set game start timestamp for deterministic multiplayer synchronization
            if (!window.gameStartTimestamp) {
                window.gameStartTimestamp = Date.now();
                console.log('Game start timestamp set:', window.gameStartTimestamp);
            }
            
            // Start snake path money spawning system
            if (snakePathMoneyTimer) {
                clearTimeout(snakePathMoneyTimer);
            }
            spawnSnakePathMoney(); // Spawn first money immediately
            console.log('Snake path money spawning system started in startGame');
            
            // Force sync to Firebase so other players can see this player's token immediately
            console.log('Guest: Force syncing player data to make tokens visible...');
            setTimeout(() => {
                if (isMultiplayerGame) {
                    syncGameStateToFirebase();
                }
            }, 1000); // Small delay to ensure game is fully initialized
        }

        // Hide intro screen and show game
        console.log('Showing game UI...');
        document.getElementById('intro-screen').style.display = 'none';
        document.getElementById('game-container').style.display = 'block';

        // Show UserIDs panel if in multiplayer mode (disabled)
        if (isMultiplayerGame && players && players.length > 0) {
            // showUserIDsPanel(); // Disabled - don't show UserIDs window
            // updateUserIDsPanel(players); // Disabled - don't update UserIDs window
            
            // Try to set the local player name if not already set
            if (!window.localPlayerName && players.length > 0) {
                // Try to find the player that matches this browser's role (host/guest)
                const matchingPlayer = players.find(p => p.isHost === isHost);
                if (matchingPlayer) {
                    window.localPlayerName = matchingPlayer.name;
                    document.getElementById('player1-name').value = matchingPlayer.name;
                    console.log('Set local player name from game state:', matchingPlayer.name);
                }
            }
        }

        // Initialize the game board (only if not already initialized)
        if (isGameInitialized && canvas && positionsMap && Object.keys(positionsMap).length > 0) {
            console.log('Game board already fully initialized for guest, skipping all initialization');
        } else {
            console.log('Game board needs initialization for guest...');
            
            // Remove ALL existing canvases to prevent duplicates
            const allCanvasesInDocument = document.querySelectorAll('canvas');
            if (allCanvasesInDocument.length > 0) {
                console.log('Removing', allCanvasesInDocument.length, 'existing canvas elements for guest');
                allCanvasesInDocument.forEach(canvasEl => canvasEl.remove());
            }
            
            // Reset canvas reference
            canvas = null;
            
            console.log('Calling initGame for guest...');
            await initGame();
        }

        // Load token images if we have players but no images
        if (players && players.length > 0 && !players[0].image) {
            console.log('Loading token images for guest...', players.length, 'players');
            const allTokenUrls = [
                'assets/images/t1.png',
                'assets/images/t2.png',
                'assets/images/t3.png',
                'assets/images/t4.png',
                'assets/images/t5.png',
                'assets/images/t6.png',
                'assets/images/t7.png',
                'assets/images/t8.png',
                'assets/images/t9.png'
            ];
            
            try {
                const tokenImages = await loadTokens(allTokenUrls.slice(0, players.length));
                console.log('Token images loaded successfully:', tokenImages.length);
                
                // Assign token images to players
                players.forEach((player, index) => {
                    player.image = tokenImages[index];
                    console.log('Assigned token to player:', player.name, 'image:', !!player.image);
                });
            } catch (tokenError) {
                console.error('Failed to load token images:', tokenError);
                // Continue without token images - renderTokens will use fallback circles
            }
        }

        // Update positions on the board
        if (positionsMap && players) {
            console.log('Updating player positions on board...');
            players.forEach(player => {
                const pos = positionsMap.get(player.currentSquare);
                if (pos) {
                    player.x = pos.x;
                    player.y = pos.y;
                    console.log('Player', player.name, 'positioned at', player.currentSquare, ':', pos.x, pos.y);
                } else {
                    console.error('No position found for square:', player.currentSquare, 'for player:', player.name);
                }
            });
        } else {
            console.error('Missing positionsMap or players for positioning:', {
                positionsMap: !!positionsMap,
                players: !!players,
                playersLength: players?.length
            });
        }

        // Update game_utils with player state
        if (players) {
            console.log('Setting players in game_utils:', players.length, 'players');
            setPlayers(players);
        }

        // Update UI
        console.log('About to call updateGameFrame...');
        await updateGameFrame();
        console.log('updateGameFrame completed');
        updateInfoPanel();
        updateTurnInfo();
        enableDiceSection();
        
        // Initialize bottom player display
        if (typeof updateBottomPlayerDisplay === 'function') {
            updateBottomPlayerDisplay();
        }
        
        // Ensure bottom display is visible for all game modes
        ensureBottomPlayerDisplayVisible();

        // Start first turn for AI if needed
        if (players && players[currentPlayerIndex] && players[currentPlayerIndex].isAI) {
            await handleAITurn();
        }
        
        // Start the gojail glow system for multiplayer games too
        if (isMultiplayerGame) {
            startGojailGlowSystem();
            startGojailGravesShakingSystem();
            resetLightningSystem();
            startLightningSystem();

        }
        
        console.log('Guest game initialization completed');
        
    } catch (error) {
        console.error('Error in startGame:', error);
        showAdvisory('Failed to start game: ' + error.message, 'error');
    }
}

// Smoothly animate a player's token to a new position without re-syncing to Firebase
function animateTokenTo(player, targetX, targetY, duration = 200) {
    const key = player.userId || player.name;
    if (tokenAnimations[key]) {
        clearInterval(tokenAnimations[key]);
    }

    const steps = Math.max(3, Math.floor(duration / 50)); // More steps for smoother animation
    const startX = player.x;
    const startY = player.y;
    let step = 0;

    // Skip animation if already at target position
    if (Math.abs(startX - targetX) < 1 && Math.abs(startY - targetY) < 1) {
        player.x = targetX;
        player.y = targetY;
        updateGameFrame();
        return;
    }

    tokenAnimations[key] = setInterval(() => {
        step++;
        const progress = step / steps;
        
        // Use easing for smoother animation
        const easedProgress = 1 - Math.pow(1 - progress, 3); // Ease-out cubic
        
        player.x = startX + (targetX - startX) * easedProgress;
        player.y = startY + (targetY - startY) * easedProgress;
        
        // Always update game frame for smooth animation
        updateGameFrame();
        
        if (step >= steps) {
            clearInterval(tokenAnimations[key]);
            tokenAnimations[key] = null;
            player.x = targetX;
            player.y = targetY;
            updateGameFrame(); // Final update
        }
    }, duration / steps);
}

// Helper function to assess if player data corruption is temporary or serious
function assessPlayerDataCorruption(gameState, existingPlayers) {
    if (!gameState.players || !Array.isArray(gameState.players)) {
        return { isTemporary: true, severity: 'low', reason: 'Missing or non-array players data' };
    }
    
    const validPlayers = gameState.players.filter(p => p && p.name && p.name !== 'undefined');
    const invalidCount = gameState.players.length - validPlayers.length;
    
    // If we have no valid players but existing players exist, likely temporary
    if (validPlayers.length === 0 && existingPlayers && existingPlayers.length > 0) {
        return { isTemporary: true, severity: 'medium', reason: 'All players invalid but local data exists' };
    }
    
    // If more than half the players are invalid, might be serious
    if (invalidCount > gameState.players.length / 2) {
        return { isTemporary: false, severity: 'high', reason: 'Majority of players corrupted' };
    }
    
    // Single invalid player is likely temporary
    if (invalidCount === 1) {
        return { isTemporary: true, severity: 'low', reason: 'Single invalid player entry' };
    }
    
    return { isTemporary: false, severity: 'medium', reason: 'Multiple invalid players' };
}

// Function to update game state from multiplayer state
async function updateGameFromState(gameState) {
    if (!gameState || !isMultiplayerGame) {
        console.log('Skipping updateGameFromState - invalid conditions:', {
            hasGameState: !!gameState,
            isMultiplayerGame: isMultiplayerGame
        });
        return;
    }
    
    // Debug logging to understand what we're receiving
    console.log('ðŸ”„ updateGameFromState called with:', {
        hasPlayers: !!gameState.players,
        playersType: typeof gameState.players,
        isArray: Array.isArray(gameState.players),
        playersLength: gameState.players?.length,
        playersPreview: gameState.players?.map(p => ({ name: p?.name, hasName: !!p?.name }))
    });

    // Use intelligent corruption assessment
    const currentPlayers = Array.isArray(players) ? players.map(p => ({ ...p })) : [];
    const corruptionAssessment = assessPlayerDataCorruption(gameState, currentPlayers);
    
    console.log('ðŸ” Player data corruption assessment:', corruptionAssessment);
    
    // Enhanced validation logic - more tolerant of temporary states
    if (!gameState.players || !Array.isArray(gameState.players)) {
        console.error('ðŸš¨ Invalid players array received from Firebase. Rejecting update.', gameState);
        
        // Only show user advisory for serious corruption, not temporary sync issues
        if (!corruptionAssessment.isTemporary && corruptionAssessment.severity === 'high') {
            showAdvisory('Connection issue detected. Preserving local game state.', 'warning');
        }
        return;
    }
    
    // Filter out any invalid player entries but don't reject the entire update
    const validPlayers = gameState.players.filter(p => p && p.name && p.name !== 'undefined' && p.name !== undefined);
    
    // If no valid players but we have local players, try to repair the data
    if (validPlayers.length === 0 && currentPlayers.length > 0) {
        console.warn('ðŸ”§ Attempting to repair corrupted player data using local state');
        
        // Use local player data to repair Firebase data
        const repairedPlayers = currentPlayers.map((localPlayer, index) => ({
            ...localPlayer,
            // Ensure all required fields are present
            name: localPlayer.name || `Player ${index + 1}`,
            userId: localPlayer.userId || `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            isHost: localPlayer.isHost !== undefined ? localPlayer.isHost : (index === 0)
        }));
        
        // Update the game state with repaired data
        gameState.players = repairedPlayers;
        console.log('ðŸ”§ Repaired player data:', repairedPlayers);
        
        // Sync the repaired data back to Firebase
        if (typeof syncGameStateToFirebase === 'function') {
            syncGameStateToFirebase();
        }
    } else if (validPlayers.length === 0) {
        console.error('ðŸš¨ No valid players found in game state. Rejecting update.', gameState);
        
        // Only show user advisory for serious issues, not temporary sync problems
        if (!corruptionAssessment.isTemporary && currentPlayers.length > 0) {
            console.warn('ðŸ”„ Temporary player data sync issue detected, preserving local state');
            // Only show message for persistent issues
            // showAdvisory('Temporary sync issue. Game continues with local data.', 'info');
        }
        return;
    }
    
    // If we filtered out some invalid players, log it but continue with valid ones
    if (validPlayers.length !== gameState.players.length) {
        const invalidCount = gameState.players.length - validPlayers.length;
        console.warn('âš ï¸ Cleaned up player data - filtered out invalid entries:', {
            originalCount: gameState.players.length,
            validCount: validPlayers.length,
            invalidEntries: invalidCount,
            assessment: corruptionAssessment
        });
        
        // Only show user message for serious corruption, not temporary issues
        if (!corruptionAssessment.isTemporary && corruptionAssessment.severity === 'high') {
            showAdvisory(`Recovered from sync issue. Game continues normally.`, 'info');
        }
        
        gameState.players = validPlayers;
    }

    // Ensure we have valid game state before proceeding
    if (!gameState.players || !Array.isArray(gameState.players) || gameState.players.length === 0) {
        console.log('updateGameFromState: Invalid or empty players array');
        return;
    }

    // CRITICAL FIX: Enhanced currentTurn validation with recovery
    if (typeof gameState.currentTurn !== 'number' || 
        gameState.currentTurn < 0 || 
        gameState.currentTurn >= gameState.players.length) {
        console.warn('updateGameFromState: Invalid currentTurn in game state, attempting recovery:', {
            currentTurn: gameState.currentTurn,
            playersLength: gameState.players.length,
            localCurrentPlayerIndex: currentPlayerIndex
        });
        
        // Try to recover by using local currentPlayerIndex if it's valid
        if (currentPlayerIndex >= 0 && currentPlayerIndex < gameState.players.length) {
            console.log('updateGameFromState: Using local currentPlayerIndex for recovery:', currentPlayerIndex);
            gameState.currentTurn = currentPlayerIndex;
        } else {
            // Reset to 0 as last resort
            console.log('updateGameFromState: Resetting currentTurn to 0 as last resort');
            gameState.currentTurn = 0;
            currentPlayerIndex = 0;
        }
    }
    
    // Validate gameState.players is an array
    if (!Array.isArray(gameState.players)) {
        console.warn('updateGameFromState: gameState.players is not an array:', typeof gameState.players, gameState.players);
        
        // Try to fix the array corruption automatically
        if (gameState.players && typeof gameState.players === 'object') {
            console.log('Attempting to fix players array corruption...');
            // Import and call the fix function
            import('./firebase-init.js').then(firebaseModule => {
                firebaseModule.fixPlayersArrayIntegrity().catch(error => {
                    console.error('Failed to fix players array:', error);
                });
            });
        }
        return;
    }
    
    console.log('Updating game state from Firebase:', gameState);
    console.log('Current local state before update:', {
        currentPlayerIndex: currentPlayerIndex,
        localPlayers: Array.isArray(players) ? players.map(p => ({ name: p.name, currentSquare: p.currentSquare, money: p.money })) : 'players is not array'
    });
    
    // Preserve previous player data for position comparison
    const existingPlayers = Array.isArray(players) ? players.map(p => ({ ...p })) : [];
    
    // Validate incoming player data before processing
    if (!gameState.players || !Array.isArray(gameState.players)) {
        console.error('Invalid players data from Firebase:', gameState.players);
        return; // Don't update if data is invalid
    }
    
    // Check if incoming data has corrupted player information
    const hasCorruptedData = gameState.players.some(p => 
        !p || 
        (p.name === undefined && p.userId === undefined && p.isHost === undefined)
    );
    
    if (hasCorruptedData) {
        console.warn('Detected corrupted player data from Firebase, preserving local data:', {
            incomingPlayers: gameState.players,
            existingPlayers: existingPlayers
        });
        
        // If we have good existing data, don't overwrite it with corrupted data
        if (existingPlayers.length > 0 && existingPlayers.some(p => p.name && p.name !== 'undefined')) {
            console.log('Preserving existing good player data instead of using corrupted Firebase data');
            // Still update other game state but skip player updates
            if (gameState.properties) {
                // Use the robust merge logic here as well
                Object.entries(gameState.properties).forEach(([square, firebaseProp]) => {
                    const localProp = propertyState[square];
                    const timeSincePurchase = localProp?.purchaseTimestamp ? Date.now() - localProp.purchaseTimestamp : Infinity;

                    if (localProp && localProp.owner && !firebaseProp.owner && timeSincePurchase < 15000) {
                        console.log(`[updateGameFromState] ðŸ›¡ï¸ IGNORING stale Firebase update for recently purchased property ${square} (corrupted player data context).`);
                        return;
                    }

                    if (localProp && localProp.owner && !firebaseProp.owner) {
                        console.log(`Merged property ${square} (keeping local owner, corrupted player data context)`);
                        propertyState[square] = { ...firebaseProp, owner: localProp.owner, ownerColor: localProp.ownerColor };
                    } else {
                        propertyState[square] = { ...firebaseProp };
                    }
                });

                Object.values(propertyState).forEach(prop => {
                    if (prop.owner && !prop.ownerColor) {
                        const p = players.find(pl => pl.name === prop.owner);
                        if (p && p.color) {
                            prop.ownerColor = p.color;
                        }
                    }
                });
            }
            currentPlayerIndex = gameState.currentTurn || currentPlayerIndex;
            lastRollWasDoubles = gameState.lastRollWasDoubles || false;
            consecutiveDoublesCount = gameState.consecutiveDoublesCount || 0;

            players.forEach((p, idx) => {
                p.isCurrentPlayer = (idx === currentPlayerIndex);
            });
            
            // Update UI with existing data
            updateGameFrame();
            updateInfoPanel();
            updateTurnInfo();
            enableDiceSection();
            return;
        }
    }
    
    // CRITICAL FIX: Enhanced multiplayer player recovery
    if (isMultiplayerGame && gameState.players.length < existingPlayers.length) {
        console.warn('Detected missing players in multiplayer game. Attempting auto-recovery.', {
            incomingCount: gameState.players.length,
            existingCount: existingPlayers.length
        });
        
        // Find missing players by comparing names and userIds
        const incomingPlayerIds = gameState.players.map(p => p.userId || p.name);
        const missingPlayers = existingPlayers.filter(p => 
            !incomingPlayerIds.includes(p.userId || p.name) && 
            p.name && p.name !== 'undefined'
        );
        
        if (missingPlayers.length > 0) {
            console.log('Auto-recovering missing players:', missingPlayers.map(p => p.name));
            gameState.players.push(...missingPlayers);
            
            // Ensure currentTurn is still valid after recovery
            if (gameState.currentTurn >= gameState.players.length) {
                gameState.currentTurn = 0;
                console.log('Adjusted currentTurn after player recovery:', gameState.currentTurn);
            }
        }
    }
    
    players = gameState.players.map((p, index) => {
        // Preserve player names - check multiple sources
        let playerName = p.name;
        if (!playerName || playerName === 'undefined') {
            // Try to get from existing local data
            if (existingPlayers[index]?.name && existingPlayers[index].name !== 'undefined') {
                playerName = existingPlayers[index].name;
            } else if (window.localPlayerName && (p.isHost === isHost)) {
                // If this player matches our role (host/guest), use our stored name
                playerName = window.localPlayerName;
            } else {
                playerName = `Player ${index + 1}`; // Fallback
            }
        }
        
        // Preserve other critical fields
        let userId = p.userId;
        if (!userId || userId === 'undefined') {
            userId = existingPlayers[index]?.userId || `user_${index}`;
        }
        
        let isHostValue = p.isHost;
        if (isHostValue === undefined) {
            isHostValue = existingPlayers[index]?.isHost || (index === 0);
        }
        
        return {
            name: playerName,
            userId: userId,
            image: existingPlayers[index]?.image || null, // Keep existing token images
            x: p.x || 0,
            y: p.y || 0,
            position: p.position || 0,
            currentSquare: p.currentSquare || 'go',
            currentPathKey: p.currentPathKey || "gamePath",
            currentIndexOnPath: p.currentIndexOnPath || 0,
            isMovingReverse: p.isMovingReverse || false,
            size: p.size || 62,
                                money: p.money || 16500,
            properties: p.properties || [],
            isAI: p.isAI || false,
            bankrupt: p.bankrupt || false,
            isHost: isHostValue,
            tokenImage: p.tokenImage || `assets/tokens/t${index + 1}.png`,
                            tokenIndex: p.tokenIndex || index,
                inJail: p.inJail || false,
                jailTurns: p.jailTurns || 0,
                consecutiveDoubles: p.consecutiveDoubles || 0,
                stealCards: p.stealCards || 0,
                goPassCount: p.goPassCount || 0,
                color: p.color,
                colorName: p.colorName,
                // CRITICAL: Preserve movement flags from Firebase or existing local data
                isMoving: p.hasOwnProperty('isMoving') ? p.isMoving : existingPlayers[index]?.isMoving,
                movementTimestamp: p.hasOwnProperty('movementTimestamp') ? p.movementTimestamp : existingPlayers[index]?.movementTimestamp,
                movementStep: p.hasOwnProperty('movementStep') ? p.movementStep : existingPlayers[index]?.movementStep,
                totalMovementSteps: p.hasOwnProperty('totalMovementSteps') ? p.totalMovementSteps : existingPlayers[index]?.totalMovementSteps
            };
        });

        console.log('ðŸŽ¨ updateGameFromState - player colors after reconstruction:');
        players.forEach((p, i) => console.log(`  Player ${i}: ${p.name} - color: ${p.color}, colorName: ${p.colorName}`));
        
        // Debug: Log movement flags after full player sync
        console.log('ðŸŽ¯ updateGameFromState - movement flags after full player sync:');
        players.forEach((p, i) => {
            console.log(`  Player ${i}: ${p.name} - isMoving: ${p.isMoving}, movementTimestamp: ${p.movementTimestamp}`);
        });
        
        // Debug: Log Firebase player data for comparison
        console.log('ðŸ” Firebase player data received:');
        gameState.players.forEach((p, i) => {
            console.log(`  Firebase Player ${i}: name=${p.name}, isMoving=${p.isMoving}, movementTimestamp=${p.movementTimestamp}`);
        });
        
        // Debug: Log existing local player data for comparison
        console.log('ðŸ” Existing local player data before reconstruction:');
        existingPlayers.forEach((p, i) => {
            console.log(`  Local Player ${i}: name=${p.name}, isMoving=${p.isMoving}, movementTimestamp=${p.movementTimestamp}`);
        });
        
        // Update game_utils with the reconstructed players to ensure colors are applied
        setPlayers(players);

    // Update positions on the board - use real-time x,y coordinates when available
    players.forEach((player, idx) => {
        const gameStatePlayer = gameState.players[idx];
        const prev = existingPlayers[idx];
        
        // Use real-time coordinates from Firebase if available, otherwise fall back to position map
        let targetX, targetY;
        if (gameStatePlayer && gameStatePlayer.x !== undefined && gameStatePlayer.y !== undefined && 
            !(gameStatePlayer.x === 0 && gameStatePlayer.y === 0)) {
            // Use real-time coordinates from Firebase (sent during movement) - but not if they're both zero
            targetX = gameStatePlayer.x;
            targetY = gameStatePlayer.y;
        } else {
            // Fall back to position map based on current square
            const pos = positionsMap?.get(player.currentSquare);
            if (pos) {
                targetX = pos.x;
                targetY = pos.y;
                console.log(`Using position map for ${player.name} at ${player.currentSquare}: (${targetX}, ${targetY})`);
            } else {
                console.warn(`No position found for square ${player.currentSquare} for player ${player.name}`);
                return; // Skip if no position data available
            }
        }
        
        // Check if position actually changed
        const positionChanged = !prev || prev.x !== targetX || prev.y !== targetY;
        
        console.log(`Position update for ${player.name}: currentSquare=${player.currentSquare}, target=(${targetX}, ${targetY}), changed=${positionChanged}, realTimeCoords=${gameStatePlayer?.x !== undefined}`);
        
        if (positionChanged) {
            // For other players (not current user), animate the movement smoothly and play ping sound
            if (player.userId !== currentUserId) {
                // Play ping sound for other player movement (only if they're actively moving)
                if (gameStatePlayer?.isMoving && gameStatePlayer?.movementTimestamp) {
                    // Check if this is a new movement step (prevent duplicate sounds)
                    if (!player.lastMovementTimestamp || gameStatePlayer.movementTimestamp > player.lastMovementTimestamp) {
                        console.log(`ðŸ”Š Playing ping sound for ${player.name} movement step ${gameStatePlayer.movementStep}/${gameStatePlayer.totalMovementSteps}`);
                        playNextPing().catch(error => console.warn('Could not play ping sound for player movement:', error));
                        player.lastMovementTimestamp = gameStatePlayer.movementTimestamp;
                    }
                }
                
                // Only animate if there was a previous position to animate from
                if (prev && (prev.x !== targetX || prev.y !== targetY)) {
                    console.log(`Animating ${player.name} from (${prev.x}, ${prev.y}) to (${targetX}, ${targetY})`);
                    // Use shorter animation for real-time movement sync to match the movement interval
                    const animationDuration = gameStatePlayer?.isMoving ? 200 : 300; // Match moveInterval from moveToken
                    animateTokenTo(player, targetX, targetY, animationDuration);
                } else {
                    // Update position immediately if no previous position
                    player.x = targetX;
                    player.y = targetY;
                }
            } else {
                // For current user, update position directly without animation
                player.x = targetX;
                player.y = targetY;
                console.log(`Updated current player ${player.name} position to (${targetX}, ${targetY})`);
            }
        } else {
            // Position didn't change, just ensure it's set correctly
            player.x = targetX;
            player.y = targetY;
            console.log(`Position unchanged for ${player.name}, ensuring correct position (${targetX}, ${targetY})`);
        }
        
        // Ensure token images are loaded for all players
        if (!player.image && player.tokenImage) {
            console.log(`Loading missing token image for ${player.name}: ${player.tokenImage}`);
            const img = new Image();
            img.onload = () => {
                player.image = img;
                console.log(`Token image loaded for ${player.name}`);
                updateGameFrame(); // Redraw when image loads
                
                // Force sync to Firebase to make this player's token visible to others
                if (isMultiplayerGame) {
                    console.log(`Syncing ${player.name}'s token visibility to Firebase...`);
                    syncGameStateToFirebase();
                }
            };
            img.onerror = () => {
                console.error(`Failed to load token image for ${player.name}: ${player.tokenImage}`);
            };
            img.src = player.tokenImage;
        }
    });

    // Update property states if they exist in the game state
    if (gameState.properties) {
        console.log('ðŸ° Restoring property state from Firebase with crypt preservation:', gameState.properties);
        console.log('ðŸž Current local property state before restore:', JSON.stringify(propertyState));
        
        // Track properties that had crypts before sync
        const propertiesWithCryptsBefore = {};
        Object.entries(propertyState).forEach(([square, state]) => {
            if (state?.hasCrypt) {
                propertiesWithCryptsBefore[square] = true;
            }
        });
        
        // Enhanced merge function that preserves development state
        function mergePropertyStatePreservingDevelopment(localProp, firebaseProp, square) {
            console.log(`[mergePropertyState] ðŸ° Merging ${square}: Local hasCrypt=${localProp?.hasCrypt}, Firebase hasCrypt=${firebaseProp?.hasCrypt}`);
            
            // If local property has development (crypts/graveyards) but Firebase doesn't, preserve local development
            const localHasCrypt = localProp?.hasCrypt || false;
            const localGraveyards = localProp?.graveyards || 0;
            const firebaseHasCrypt = firebaseProp?.hasCrypt || false;
            const firebaseGraveyards = firebaseProp?.graveyards || 0;
            
            // Determine which development state to use
            let finalHasCrypt = firebaseHasCrypt;
            let finalGraveyards = firebaseGraveyards;
            
            // If local has more development than Firebase, preserve local development
            if (localHasCrypt && !firebaseHasCrypt) {
                console.log(`[mergePropertyState] ðŸ° Preserving local crypt for ${square}`);
                finalHasCrypt = true;
                finalGraveyards = 0; // Crypts reset graveyards
            } else if (!localHasCrypt && !firebaseHasCrypt && localGraveyards > firebaseGraveyards) {
                console.log(`[mergePropertyState] ðŸª¦ Preserving local graveyards (${localGraveyards}) for ${square}`);
                finalGraveyards = localGraveyards;
            }
            
            // Create merged state preserving the most developed version
            const mergedState = {
                ...firebaseProp,
                hasCrypt: finalHasCrypt,
                graveyards: finalGraveyards,
                group: localProp?.group || firebaseProp?.group, // Preserve group info
                declined: firebaseProp?.declined || localProp?.declined || false
            };
            
            console.log(`[mergePropertyState] ðŸ° Final state for ${square}:`, {
                owner: mergedState.owner,
                hasCrypt: mergedState.hasCrypt,
                graveyards: mergedState.graveyards
            });
            
            return mergedState;
        }
        
        // Merge property state carefully to avoid overwriting recent local changes AND preserve development
        Object.entries(gameState.properties).forEach(([square, firebaseProp]) => {
            const localProp = propertyState[square];
            console.log(`[updateGameFromState] ðŸž MERGE CHECK for ${square}: Local owner: ${localProp?.owner}, Firebase owner: ${firebaseProp?.owner}`);
            console.log(`[updateGameFromState] ðŸ° CRYPT CHECK for ${square}: Local hasCrypt: ${localProp?.hasCrypt}, Firebase hasCrypt: ${firebaseProp?.hasCrypt}`);
            
            const timeSincePurchase = localProp?.purchaseTimestamp ? Date.now() - localProp.purchaseTimestamp : Infinity;
            const lightningStrikeTs = firebaseProp?.lastLightningStrike || 0;
            const recentlyStruck = lightningStrikeTs && (Date.now() - lightningStrikeTs < 30000);

            // If local property was purchased recently and Firebase update is trying to nullify owner, ignore it unless struck by lightning
            if (localProp && localProp.owner && !firebaseProp.owner && timeSincePurchase < 15000 && !recentlyStruck) {
                console.log(`[updateGameFromState] ðŸ›¡ï¸ IGNORING stale Firebase update for recently purchased property ${square}.`);
                return; // Skip update for this property
            }

            // Accept Firebase update (handles lightning strikes and legitimate ownership removals)
            if (localProp && localProp.owner && !firebaseProp.owner) {
                console.log(`[updateGameFromState] âš¡ Accepting Firebase ownership removal for ${square}${recentlyStruck ? ' due to lightning' : ''}.`);
                propertyState[square] = mergePropertyStatePreservingDevelopment(localProp, firebaseProp, square);
                if (recentlyStruck) {
                    if (!window.recentLightningStrikes) {
                        window.recentLightningStrikes = new Map();
                    }
                    window.recentLightningStrikes.set(square, Date.now());
                }
            } else {
                // Use enhanced merge that preserves development
                propertyState[square] = mergePropertyStatePreservingDevelopment(localProp, firebaseProp, square);
            }
        });
        
        // Check for lost crypts and report
        const propertiesWithCryptsAfter = {};
        Object.entries(propertyState).forEach(([square, state]) => {
            if (state?.hasCrypt) {
                propertiesWithCryptsAfter[square] = true;
            }
        });
        
        // Report any crypts that were preserved or lost
        Object.keys(propertiesWithCryptsBefore).forEach(square => {
            if (!propertiesWithCryptsAfter[square]) {
                console.warn(`ðŸ° CRYPT LOST during sync for ${square}! This should not happen with the enhanced merge.`);
            } else {
                console.log(`ðŸ° CRYPT PRESERVED for ${square} âœ…`);
            }
        });
        
        console.log('ðŸž Current local property state after restore:', JSON.stringify(propertyState));
        // Ensure ownerColor is set based on player colors
        Object.values(propertyState).forEach(prop => {
            if (prop.owner && !prop.ownerColor) {
                const p = players.find(pl => pl.name.toLowerCase() === (prop.owner || '').toLowerCase());
                if (p && p.color) {
                    prop.ownerColor = p.color;
                }
            }
        });
        
        console.log('Property state after restore:', propertyState);

        // Ensure crypt/graveyard visuals update immediately after merge
        try {
            updateGameFrame();
        } catch (e) {
            console.warn('updateGameFrame failed after property restore:', e);
        }
        
        // CRITICAL FIX: Rebuild player property arrays to match propertyState ownership
        // This ensures player.properties arrays are synchronized with actual ownership
        rebuildPlayerPropertyArrays();
    }

    // Update snake path money if it exists in the game state
    if (gameState.snakePathMoney) {
        console.log('Restoring snake path money from Firebase:', gameState.snakePathMoney);
        console.log('Current local snake path money before restore:', snakePathMoney);
        
        // Only update if we don't have local snake path money or if Firebase has more recent data
        if (!snakePathMoney || Object.keys(snakePathMoney).length === 0) {
            snakePathMoney = { ...gameState.snakePathMoney };
            console.log('Snake path money restored from Firebase:', snakePathMoney);
        } else {
            // Merge carefully - preserve collected status locally but update positions/amounts from Firebase
            Object.entries(gameState.snakePathMoney).forEach(([square, firebaseMoney]) => {
                const localMoney = snakePathMoney[square];
                
                // If we don't have this position locally, add it from Firebase
                if (!localMoney) {
                    snakePathMoney[square] = { ...firebaseMoney };
                    console.log(`Added snake path money ${square} from Firebase:`, firebaseMoney);
                }
                // If we have it locally but it's not collected, update from Firebase
                else if (!localMoney.collected && !firebaseMoney.collected) {
                    snakePathMoney[square] = { ...firebaseMoney };
                    console.log(`Updated snake path money ${square} from Firebase:`, firebaseMoney);
                }
                // Keep local collected status if already collected
                else if (localMoney.collected) {
                    console.log(`Keeping local collected status for ${square}`);
                }
            });
            
            console.log('Snake path money after merge:', snakePathMoney);
        }
    }

    // Handle lightning broadcast (ensures all clients use the same strike target)
    try {
        if (isMultiplayerGame && gameState.lightning && gameState.lightning.currentProperty && gameState.lightning.strikeTimestamp) {
            const ts = gameState.lightning.strikeTimestamp;
            if (!lastProcessedLightningTs || ts > lastProcessedLightningTs) {
                const prop = gameState.lightning.currentProperty;
                console.log(`âš¡ Applying broadcast lightning strike on ${prop} (ts=${ts})`);
                lastProcessedLightningTs = ts;
                // Render effects and apply property/player outcomes deterministically
                const pos = positionsMap?.get(prop);
                if (pos) {
                    createLightningEffect(pos.x, pos.y);
                }
                // If any players are currently on that property, mirror penalty locally
                const playersOn = players.filter(p => !p.bankrupt && p.currentSquare === prop);
                if (playersOn.length > 0) {
                    (async () => {
                        for (const p of playersOn) {
                            await applyLightningPenalty(p, prop);
                        }
                    })();
                } else {
                    (async () => {
                        const msg = await applyLightningPropertyEffects(prop);
                        const info = getPropertyInfo(prop);
                        const name = info ? getPropertyDisplayNameWithoutNumber(info) : 'Unknown Location';
                        const owned = propertyState[prop]?.owner;
                        if (owned) {
                            showAdvisory(`âš¡ Lightning strikes ${name}! Luckily no players were there.${msg ? ' ' + msg : ''}`, 'lightning');
                        } else {
                            showAdvisory(`Lightning Strikes ${name}`, 'warning');
                        }
                    })();
                }
            }
        }
    } catch (e) {
        console.warn('âš¡ Lightning broadcast apply failed:', e?.message || e);
    }

    // Update game variables
    currentPlayerIndex = gameState.currentTurn || 0;
    lastRollWasDoubles = gameState.lastRollWasDoubles || false;
    consecutiveDoublesCount = gameState.consecutiveDoublesCount || 0;
    
    const currentPlayer = players[currentPlayerIndex];
    if (currentPlayer) {
        isAITurn = currentPlayer.isAI;
    }
    
    // Update dice display if available
    if (gameState.lastDiceRoll) {
        const die1Element = document.getElementById('die1');
        const die2Element = document.getElementById('die2');
        
        if (die1Element && die2Element) {
            die1Element.textContent = gameState.lastDiceRoll.die1 || '?';
            die2Element.textContent = gameState.lastDiceRoll.die2 || '?';
        }
    }
    
    // Update game_utils with player state
    setPlayers(players);
    
    // Ensure positionsMap is available for steal card system
    if (!positionsMap || positionsMap.size === 0) {
        console.warn('positionsMap not initialized, attempting to load positions');
        loadPositions().then(() => {
            console.log('Positions loaded successfully after game state update');
            setPositionsMap(positionsMap);
        }).catch(error => {
            console.error('Failed to load positions after game state update:', error);
        });
    } else {
        // Ensure game_utils has the updated positionsMap
        setPositionsMap(positionsMap);
    }
    
    // Update UI
    console.log('Updated local state after Firebase sync:', {
        currentPlayerIndex: currentPlayerIndex,
        localPlayers: Array.isArray(players) ? players.map(p => ({ name: p.name, currentSquare: p.currentSquare, money: p.money })) : 'players is not array'
    });
    
    // Force immediate visual update with proper async handling
    console.log('updateGameFromState: Calling updateGameFrame to refresh visuals');
    
    // Add safety check to ensure game is initialized before updating
    if (!canvas && !isGameInitialized) {
        console.warn('updateGameFromState: Game not initialized, attempting to initialize first...');
        try {
            await initGame();
            // Double-check that canvas is now available after initialization
            if (!canvas) {
                console.warn('updateGameFromState: Canvas still not available after initialization, skipping visual update');
                return;
            }
        } catch (error) {
            console.error('updateGameFromState: Failed to initialize game:', error);
            return;
        }
    }
    
    // Additional safety check - if initialization is in progress, wait for it
    if (isInitializing) {
        console.log('updateGameFromState: Game initialization in progress, skipping visual update');
        return;
    }
    
    // Final safety check before calling updateGameFrame
    if (!canvas) {
        console.warn('updateGameFromState: No canvas available, skipping visual update');
        return;
    }
    
    updateGameFrame().then(() => {
        console.log('updateGameFromState: Visual update completed');
        // Double-check that tokens are visible by logging player positions
        console.log('updateGameFromState: Updated player positions:', 
            players.map(p => ({ 
                name: p.name, 
                currentSquare: p.currentSquare, 
                x: p.x, 
                y: p.y, 
                hasImage: !!p.image 
            }))
        );
    });
    
    // Only update info panel if no player is currently moving to prevent button flashing
    if (!isPlayerMoving) {
        updateInfoPanel();
    } else {
        console.log('updateGameFromState: Skipping updateInfoPanel() - player is currently moving');
    }
    
    updateTurnInfo();
    enableDiceSection();
    
    // Ensure bottom player display is updated after Firebase sync
    if (typeof updateBottomPlayerDisplay === 'function') {
        updateBottomPlayerDisplay();
    }
    
    // Ensure bottom display remains visible after state sync
    ensureBottomPlayerDisplayVisible();
    
    console.log('updateGameFromState completed - UI updated');
}

// Clean up when the window is closed
window.addEventListener('beforeunload', () => {
    if (gameStateUnsubscribe) {
        gameStateUnsubscribe();
    }
    disconnectFromGame();
});

// Add this helper function
function getPropertyDisplayName(propertyInfo) {
    if (!propertyInfo) return '';
    
    // Get the group name and capitalize first letter
    const groupName = propertyInfo.group.charAt(0).toUpperCase() + propertyInfo.group.slice(1);
    
    // Special case for drowning, strangulation, insanity, and cave - return just the group name
    if (propertyInfo.group === 'drowning') {
        return 'Drowning';
    } else if (propertyInfo.group === 'strangulation') {
        return 'Strangulation';
    } else if (propertyInfo.group === 'insanity') {
        return 'Insanity';
    } else if (propertyInfo.group === 'cave') {
        return 'Cave';
    }
    
    return groupName;
}

function getPropertyDisplayNameWithoutNumber(propertyInfo) {
    if (!propertyInfo) return '';
    
    // Get the group name and capitalize first letter
    const groupName = propertyInfo.group.charAt(0).toUpperCase() + propertyInfo.group.slice(1);
    
    // Special case for drowning, strangulation, and cave - return just the group name
    if (propertyInfo.group === 'drowning') {
        return 'Drowning';
    } else if (propertyInfo.group === 'strangulation') {
        return 'Strangulation';
    } else if (propertyInfo.group === 'insanity') {
        return 'Insanity';
    } else if (propertyInfo.group === 'cave') {
        return 'Cave';
    }
    
    return groupName;
}

// Helper function to get ordinal suffix (1st, 2nd, 3rd, etc.)
function getOrdinalSuffix(number) {
    const j = number % 10;
    const k = number % 100;
    if (j === 1 && k !== 11) {
        return 'st';
    }
    if (j === 2 && k !== 12) {
        return 'nd';
    }
    if (j === 3 && k !== 13) {
        return 'rd';
    }
    return 'th';
}

// Helper function to get player color dice pulse class
function getPlayerDicePulseClass(playerIndex) {
    const colorNames = ['red', 'blue', 'green', 'yellow', 'purple'];
    const colorName = colorNames[playerIndex % colorNames.length];
    return `dice-pulse-player-${colorName}`;
}

// Helper function to get player color dice pulse class by player object
function getPlayerDicePulseClassByPlayer(player) {
    if (!player) {
        return 'dice-pulse'; // fallback to default
    }
    
    // Try to get color name from various sources
    let colorName = null;
    
    // First try colorName property
    if (player.colorName) {
        colorName = player.colorName.toLowerCase();
    }
    // Then try color property and extract color name
    else if (player.color) {
        const colorMap = {
            '#ff0000': 'red',
            '#0000ff': 'blue', 
            '#00ff00': 'green',
            '#ffff00': 'yellow',
            '#800080': 'purple',
            'red': 'red',
            'blue': 'blue',
            'green': 'green', 
            'yellow': 'yellow',
            'purple': 'purple'
        };
        colorName = colorMap[player.color.toLowerCase()] || null;
    }
    // Fallback to player index-based color
    else {
        const playerIndex = players.findIndex(p => p === player);
        if (playerIndex >= 0) {
            const colorNames = ['red', 'blue', 'green', 'yellow', 'purple'];
            colorName = colorNames[playerIndex % colorNames.length];
        }
    }
    
    if (colorName) {
        return `dice-pulse-player-${colorName}`;
    }
    
    return 'dice-pulse'; // fallback to default
}

// Helper function to remove all dice pulse classes
function removeAllDicePulseClasses(diceSection) {
    if (!diceSection) return;
    
    const allPulseClasses = [
        'dice-pulse', 
        'dice-pulse-red', 
        'dice-pulse-blue',
        'dice-pulse-player-red',
        'dice-pulse-player-blue', 
        'dice-pulse-player-green',
        'dice-pulse-player-yellow',
        'dice-pulse-player-purple'
    ];
    
    allPulseClasses.forEach(className => {
        diceSection.classList.remove(className);
    });
}

// Function to force dice colors via inline styles as fallback
function forceDiceColors(diceSection, player) {
    if (!diceSection || !player) return;
    
    const dice = diceSection.querySelectorAll('.die');
    if (dice.length === 0) return;
    
    // Get player color
    const playerColor = player.color || '#ff0000'; // Default to red
    
    // Convert hex to rgba
    let r, g, b;
    if (playerColor.startsWith('#')) {
        const hex = playerColor.slice(1);
        r = parseInt(hex.substr(0, 2), 16);
        g = parseInt(hex.substr(2, 2), 16);
        b = parseInt(hex.substr(4, 2), 16);
    } else {
        // Handle named colors
        const colorMap = {
            'red': [255, 0, 0],
            'blue': [0, 0, 255],
            'green': [0, 255, 0],
            'yellow': [255, 255, 0],
            'purple': [128, 0, 128]
        };
        [r, g, b] = colorMap[playerColor.toLowerCase()] || [255, 0, 0];
    }
    
    const bgColor = `rgba(${r}, ${g}, ${b}, 0.9)`;
    const borderColor = `rgba(${r}, ${g}, ${b}, 1)`;
    const shadowColor = `rgba(${r}, ${g}, ${b}, 0.6)`;
    const textColor = (r + g + b) > 400 ? 'black' : 'white'; // Light colors get black text
    
    // Apply colors to individual dice
    dice.forEach(die => {
        die.style.background = bgColor;
        die.style.color = textColor;
        die.style.border = `2px solid ${borderColor}`;
        die.style.boxShadow = `0 0 8px ${shadowColor}`;
    });
    
    // Apply pulse animation to the dice section
    const colorName = player.colorName || getColorNameFromHex(playerColor);
    const animationName = `dicePulsePlayer${colorName.charAt(0).toUpperCase() + colorName.slice(1)}`;
    diceSection.style.animation = `${animationName} 1.2s ease-in-out infinite`;
    
    console.log(`ðŸŽ² Forced dice colors and pulse for ${player.name}: ${bgColor}, animation: ${animationName}`);
}

// Helper function to get color name from hex
function getColorNameFromHex(hex) {
    const colorMap = {
        '#ff0000': 'red',
        '#0000ff': 'blue', 
        '#00ff00': 'green',
        '#ffff00': 'yellow',
        '#800080': 'purple'
    };
    return colorMap[hex.toLowerCase()] || 'red';
}

// Add function to re-enable dice section
function enableDiceSection() {
    console.log('[enableDiceSection] Called.');
    
    // Check for duplicate dice sections first
    const allDiceSections = document.querySelectorAll('[id="dice-section"]');
    if (allDiceSections.length > 1) {
        console.log(`[enableDiceSection] Found ${allDiceSections.length} dice sections - removing duplicates`);
        // Keep only the first one, remove the rest
        for (let i = 1; i < allDiceSections.length; i++) {
            allDiceSections[i].remove();
            console.log(`[enableDiceSection] Removed duplicate dice section ${i + 1}`);
        }
    }
    
    let diceSection = document.getElementById('dice-section');
    
    if (!diceSection) {
        console.error('[enableDiceSection] CRITICAL: Dice section element NOT FOUND. Retrying in 500ms...');
        setTimeout(() => {
            const retryDiceSection = document.getElementById('dice-section');
            if (!retryDiceSection) {
                console.error('[enableDiceSection] RETRY FAILED: Dice section still not found. Attempting to recreate...');
                
                // First check if dice section is in temporary storage
                const tempDiceStorage = document.getElementById('temp-dice-storage');
                if (tempDiceStorage) {
                    const tempDiceSection = tempDiceStorage.querySelector('#dice-section');
                    if (tempDiceSection) {
                        console.log('[enableDiceSection] Found dice section in temporary storage - restoring');
                        const diceContent = document.getElementById('dice-content');
                        const infoPanelContent = document.getElementById('info-panel-content');
                        
                        if (diceContent) {
                            diceContent.appendChild(tempDiceSection);
                            console.log('[enableDiceSection] Restored dice section to dice-content from temp storage');
                        } else if (infoPanelContent) {
                            infoPanelContent.appendChild(tempDiceSection);
                            console.log('[enableDiceSection] Restored dice section to info-panel-content from temp storage');
                        }
                        
                        // Clean up temporary storage
                        tempDiceStorage.remove();
                        console.log('[enableDiceSection] Cleaned up temporary dice storage');
                        
                        // Retry the function with the restored dice section
                        setTimeout(() => {
                            enableDiceSection();
                        }, 100);
                        return;
                    }
                }
                
                // Try to recreate the dice section
                const infoPanel = document.getElementById('info-panel');
                const diceContent = document.getElementById('dice-content');
                
                if (infoPanel && diceContent) {
                    // Check if dice section already exists in dice-content to prevent duplicates
                    const existingDiceSection = diceContent.querySelector('#dice-section');
                    if (existingDiceSection) {
                        console.log('[enableDiceSection] Dice section already exists in dice-content, using existing');
                        diceSection = existingDiceSection;
                    } else {
                        // Create a new dice section
                        const newDiceSection = document.createElement('div');
                        newDiceSection.id = 'dice-section';
                        newDiceSection.className = 'dice-section';
                        newDiceSection.innerHTML = `
                            <div id="die1" class="die">1</div>
                            <div id="die2" class="die">1</div>
                        `;
                        
                        diceContent.appendChild(newDiceSection);
                        console.log('[enableDiceSection] Recreated dice section');
                        diceSection = newDiceSection;
                    }
                    
                    // Retry the function with the dice section
                    setTimeout(() => {
                        enableDiceSection();
                    }, 100);
                    return;
                }
                
                // Try one more time with a longer delay
                setTimeout(() => {
                    const finalRetryDiceSection = document.getElementById('dice-section');
                    if (!finalRetryDiceSection) {
                        console.error('[enableDiceSection] FINAL RETRY FAILED: Dice section element missing from DOM. Game may not be properly initialized.');
                        return;
                    }
                    console.log('[enableDiceSection] FINAL RETRY SUCCESS: Found dice section.');
                    enableDiceSection(); // Retry the function
                }, 1000);
                return;
            }
            console.log('[enableDiceSection] RETRY SUCCESS: Found dice section on retry.');
            enableDiceSection(); // Retry the function
        }, 500);
        return;
    }
    
    if (diceSection) {
        console.log('[enableDiceSection] Dice section element found.');
        // Remove all pulse classes first to ensure a clean state
        removeAllDicePulseClasses(diceSection);
        console.log('[enableDiceSection] All pulse classes removed.');

        const currentPlayer = players[currentPlayerIndex];
        
        // Safety check: if players array is empty or currentPlayer is undefined, log error and return
        if (!players || players.length === 0) {
            console.log('[enableDiceSection] Players array is empty or undefined. Skipping dice section update.');
            diceSection.classList.add('dice-pulse-red'); // Default to red for uninitialized state
            diceSection.style.pointerEvents = 'none';
            return;
        }
        
        if (!currentPlayer) {
            console.error('[enableDiceSection] CRITICAL: currentPlayer is undefined. currentPlayerIndex:', currentPlayerIndex, 'players.length:', players?.length);
            console.error('[enableDiceSection] Players array:', players);
            diceSection.classList.add('dice-pulse-red'); // Default to red for error state
            diceSection.style.pointerEvents = 'none';
            return;
        }
        
        // Check if current player is bankrupt - if so, disable dice completely
        if (currentPlayer && currentPlayer.bankrupt) {
            console.log('[enableDiceSection] Current player is bankrupt. Disabling dice.');
            diceSection.classList.add('dice-pulse-red'); // Keep red for disabled state
            diceSection.style.pointerEvents = 'none';
            return;
        }

        if (isAITurn) { 
            // Check if panel is minimized - if so, keep dice accessible for human player
            const infoPanel = document.getElementById('info-panel');
            const isMinimized = infoPanel && infoPanel.classList.contains('minimized');
            
            if (isMinimized) {
                console.log('[enableDiceSection] Current turn is AI but panel is minimized. Keeping dice accessible for human player.');
                // Use the AI player's color for the pulse
                const aiPlayerPulseClass = getPlayerDicePulseClassByPlayer(currentPlayer);
                diceSection.classList.add(aiPlayerPulseClass);
                diceSection.style.pointerEvents = 'auto';
                console.log(`[enableDiceSection] Applied AI player color pulse: ${aiPlayerPulseClass}`);
            } else {
                console.log('[enableDiceSection] Current turn is AI. Setting player color pulse and pointerEvents to none.');
                // Use the AI player's color for the pulse instead of generic blue
                const aiPlayerPulseClass = getPlayerDicePulseClassByPlayer(currentPlayer);
                            diceSection.classList.add(aiPlayerPulseClass);
            diceSection.style.pointerEvents = 'none';
            console.log(`[enableDiceSection] Applied AI player color pulse: ${aiPlayerPulseClass}`);
            
            // Force dice colors as fallback if CSS doesn't work
            forceDiceColors(diceSection, currentPlayer);
        }
        } else if (isMultiplayerGame) {
            // In multiplayer, each player controls dice on their own turn
            let playerName = document.getElementById('player1-name').value.trim();
            
            // If player name is missing or still the default placeholder,
            // fall back to the stored local name and update the input field.
            if ((!playerName || playerName === 'Player1') && window.localPlayerName) {
                playerName = window.localPlayerName;
                document.getElementById('player1-name').value = playerName; // Update input field
            }
            
            // Additional fallback: try to get player name from URL parameters
            if (!playerName) {
                const urlParams = new URLSearchParams(window.location.search);
                const urlPlayerName = urlParams.get('player');
                if (urlPlayerName) {
                    playerName = urlPlayerName;
                    console.log(`[enableDiceSection] Using player name from URL: ${playerName}`);
                }
            }
            
            // Check if it's this player's turn
            let isMyTurn = false;
            if (currentPlayer && playerName) {
                isMyTurn = currentPlayer.name.toLowerCase() === playerName.toLowerCase();
                console.log(`[enableDiceSection] Multiplayer turn check: Current player "${currentPlayer.name}", Local player "${playerName}", Is my turn: ${isMyTurn}`);
                console.log(`[enableDiceSection] Current player index: ${currentPlayerIndex}, Total players: ${players.length}`);
            } else {
                console.log(`[enableDiceSection] Missing player info: currentPlayer=${!!currentPlayer}, playerName="${playerName}"`);
            }
            
            if (isMyTurn) {
                if (currentPlayer && !currentPlayer.bankrupt) {
                    console.log(`[enableDiceSection] Multiplayer: It's your turn (${playerName}). Enabling dice.`);
                    // Use the current player's color for the pulse
                    const playerPulseClass = getPlayerDicePulseClassByPlayer(currentPlayer);
                    diceSection.classList.add(playerPulseClass);    
                    diceSection.style.pointerEvents = 'auto';
                    console.log(`[enableDiceSection] Applied current player color pulse: ${playerPulseClass}`);
                    
                    // Force dice colors as fallback if CSS doesn't work
                    forceDiceColors(diceSection, currentPlayer);
                    
                    // Start auto-action timer for multiplayer turn (only for human players)
                    if (currentPlayer && !currentPlayer.isAI) {
                        startAutoActionTimer('roll');
                    }
                } else {
                    console.log(`[enableDiceSection] Multiplayer: It's your turn but you're bankrupt. Disabling dice.`);
                    diceSection.classList.add('dice-pulse-red'); // Keep red for disabled state
                    diceSection.style.pointerEvents = 'none';
                }
            } else {
                console.log(`[enableDiceSection] Multiplayer: Not your turn. Current player is ${currentPlayer?.name}. Setting player color pulse and disabling dice.`);
                // Use the current player's color instead of generic blue
                const currentPlayerPulseClass = getPlayerDicePulseClassByPlayer(currentPlayer);
                diceSection.classList.add(currentPlayerPulseClass);
                diceSection.style.pointerEvents = 'none';
                console.log(`[enableDiceSection] Applied current player color pulse: ${currentPlayerPulseClass}`);
                
                // Force dice colors as fallback if CSS doesn't work
                forceDiceColors(diceSection, currentPlayer);
            }
        } else {
            console.log('[enableDiceSection] Current turn is Human. Setting player color pulse and pointerEvents to auto.');
            // Use the current player's color for the pulse
            const playerPulseClass = getPlayerDicePulseClassByPlayer(currentPlayer);
            diceSection.classList.add(playerPulseClass);    
            diceSection.style.pointerEvents = 'auto';
                console.log(`[enableDiceSection] Applied current player color pulse: ${playerPulseClass}`);
    
    // Force dice colors as fallback if CSS doesn't work
    forceDiceColors(diceSection, currentPlayer);
    
    // Start auto-action timer for single player turn (only for human players)
    // Also check isAITurn flag to prevent race conditions
    if (currentPlayer && !currentPlayer.isAI && !isAITurn) {
        startAutoActionTimer('roll');
    }
            
            // Check if we're in minimized mode and need to attach minimized click handler
            const infoPanel = document.getElementById('info-panel');
            if (infoPanel && infoPanel.classList.contains('minimized')) {
                console.log('[enableDiceSection] In minimized mode - ensuring minimized dice click handler is attached');
                
                // Remove any existing handlers to prevent duplicates
                const existingHandlers = diceSection.cloneNode(true);
                diceSection.parentNode.replaceChild(existingHandlers, diceSection);
                diceSection = existingHandlers;
                
                // Add minimized dice click handler
                let lastClickTime = 0;
                const minimizedDiceClickHandler = async (e) => {
                    const now = Date.now();
                    
                    // Debounce clicks to prevent multiple rapid clicks
                    if (now - lastClickTime < 500) {
                        console.log('ðŸ“± Minimized dice click ignored (debounced)');
                        return;
                    }
                    lastClickTime = now;
                    
                    console.log('ðŸ“± MINIMIZED DICE CLICKED!', e.target.tagName, e.target.id, e.target.className);
                    console.log('ðŸ“± Click coordinates:', e.clientX, e.clientY);
                    console.log('ðŸ“± Target element bounds:', e.target.getBoundingClientRect());
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Use unified dice click handler
                    await handleDiceClick('minimized');
                };
                
                diceSection.addEventListener('click', minimizedDiceClickHandler, { capture: true });
                console.log('ðŸ“± Added minimized dice click handler to dice section:', diceSection.id);
            }
        }
        console.log('[enableDiceSection] Pulse class and pointerEvents set. Current classes:', diceSection.className, 'Current pointerEvents:', diceSection.style.pointerEvents);
    } else {
        console.error('[enableDiceSection] CRITICAL: Dice section element NOT FOUND.');
    }
    console.log('[enableDiceSection] Completed.');
}

// Debug function to fix Firebase array corruption manually
window.fixFirebaseArrays = async function() {
    console.log('=== FIXING FIREBASE ARRAYS ===');
    try {
        // Import and call the fix function
        const firebaseModule = await import('./firebase-init.js');
        await firebaseModule.fixPlayersArrayIntegrity();
        console.log('Firebase array fix completed successfully');
        showAdvisory('Firebase arrays fixed! Refresh to see changes.', 'success');
    } catch (error) {
        console.error('Failed to fix Firebase arrays:', error);
        showAdvisory('Failed to fix Firebase arrays: ' + error.message, 'error');
    }
    console.log('=== END FIX ===');
};

// Debug function to test property group highlighting
window.testPropertyGroupHighlight = function() {
    console.log('=== TESTING PROPERTY GROUP HIGHLIGHTING ===');
    
    if (!players || players.length === 0) {
        console.log('âŒ No players found. Start a game first.');
        return;
    }
    
    const currentPlayer = players[currentPlayerIndex];
    if (!currentPlayer) {
        console.log('âŒ No current player found.');
        return;
    }
    
    // Give the current player some blood properties for testing
    const bloodProperties = ['t5', 'b5', 'b6'];
    bloodProperties.forEach(prop => {
        propertyState[prop].owner = currentPlayer.name;
        propertyState[prop].ownerColor = currentPlayer.color || '#ff0000';
        if (!currentPlayer.properties.includes(prop)) {
            currentPlayer.properties.push(prop);
        }
    });
    
    console.log(`âœ… Gave ${currentPlayer.name} blood properties: ${bloodProperties.join(', ')}`);
    
    // Simulate landing on another blood property (l2)
    const testProperty = 'l2';
    const propertyInfo = {
        square: testProperty,
        group: 'blood',
        cost: 280,
        state: propertyState[testProperty]
    };
    
    console.log(`ðŸŽ¯ Simulating ${currentPlayer.name} landing on ${testProperty}...`);
    highlightPropertyGroup(currentPlayer, propertyInfo);
    
    console.log('=== TEST COMPLETE ===');
    console.log(`You should now see ${currentPlayer.colorName || 'player-colored'} pulsing glow on the blood properties owned by ${currentPlayer.name}!`);
};

// Debug function to diagnose dice click issues
window.debugDiceClick = function() {
    console.log('=== DICE CLICK DEBUG ===');
    
    const diceSection = document.getElementById('dice-section');
    const player1NameInput = document.getElementById('player1-name');
    const activePlayer = players[currentPlayerIndex];
    
    console.log('Dice Section State:', {
        exists: !!diceSection,
        pointerEvents: diceSection?.style.pointerEvents,
        className: diceSection?.className,
        disabled: diceSection?.disabled,
        hasClickListener: !!diceSection?.onclick
    });
    
    console.log('Game State:', {
        isDiceRollInProgress,
        isRecordingEyes,
        isAITurn,
        isMultiplayerGame,
        currentPlayerIndex,
        playersCount: players?.length,
        activePlayerName: activePlayer?.name
    });
    
    console.log('Player Name State:', {
        inputValue: player1NameInput?.value,
        localPlayerName: window.localPlayerName,
        isHost,
        allPlayers: Array.isArray(players) ? players.map(p => ({ name: p.name, isHost: p.isHost })) : 'invalid'
    });
    
    console.log('Turn Validation:', {
        isMyTurn: activePlayer && activePlayer.name === (player1NameInput?.value || window.localPlayerName),
        currentPlayerName: activePlayer?.name,
        myName: player1NameInput?.value || window.localPlayerName
    });
    
    console.log('=== END DEBUG ===');
    
    // Try to manually trigger a dice roll for testing
    if (diceSection) {
        console.log('ðŸŽ² Attempting manual dice click...');
        diceSection.click();
    }
};

// Debug function to manually start the game
window.forceStartGame = async function() {
    console.log('ðŸŽ® Force starting game...');
    try {
        const { getDoc, doc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
        const roomRef = doc(window.firebaseDb || db, 'gameRooms', currentRoomId);
        const roomSnap = await getDoc(roomRef);
        
        if (roomSnap.exists()) {
            const roomData = roomSnap.data();
            if (roomData.players && roomData.players.length > 0) {
                console.log('ðŸŽ® Force starting game with players:', roomData.players);
                await startMultiplayerGame(roomData.players);
            } else {
                console.error('No players found in room data');
            }
        } else {
            console.error('Room not found');
        }
    } catch (error) {
        console.error('Force start game failed:', error);
    }
};

// Debug function to check player name state
window.debugPlayerNames = function() {
    console.log('=== PLAYER NAME DEBUG ===');
    console.log('window.localPlayerName:', window.localPlayerName);
    console.log('player1-name input value:', document.getElementById('player1-name')?.value);
    
    // Check URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const urlPlayerName = urlParams.get('player');
    console.log('URL player parameter:', urlPlayerName);
    
    console.log('isHost:', isHost);
    console.log('currentPlayerIndex:', currentPlayerIndex);
    console.log('isMultiplayerGame:', isMultiplayerGame);
    console.log('players array:', players);
    console.log('current player:', players[currentPlayerIndex]);
    console.log('current player name:', players[currentPlayerIndex]?.name);
    
    if (players && players.length > 0) {
        console.log('All players:');
        players.forEach((p, i) => {
            console.log(`  Player ${i}: ${p.name} (host: ${p.isHost})`);
        });
    }
    
    // Try to auto-fix if there's a mismatch
    const inputField = document.getElementById('player1-name');
    if (inputField && !inputField.value.trim() && window.localPlayerName) {
        inputField.value = window.localPlayerName;
        console.log('Auto-fixed player name input field');
    }
    
    // Test enableDiceSection logic
    console.log('=== TESTING DICE ENABLEMENT ===');
    const currentPlayer = players[currentPlayerIndex];
    let playerName = document.getElementById('player1-name')?.value.trim();
    
    if (!playerName && window.localPlayerName) {
        playerName = window.localPlayerName;
    }
    
    if (!playerName && urlPlayerName) {
        playerName = urlPlayerName;
    }
    
    const isMyTurn = currentPlayer && playerName && currentPlayer.name.toLowerCase() === playerName.toLowerCase();
    console.log(`Current player: ${currentPlayer?.name}`);
    console.log(`Local player name: ${playerName}`);
    console.log(`Is my turn: ${isMyTurn}`);
    
    // Test case sensitivity fixes
    console.log('=== TESTING CASE SENSITIVITY FIXES ===');
    if (currentPlayer && playerName) {
        console.log(`Case-sensitive comparison: "${currentPlayer.name}" === "${playerName}" = ${currentPlayer.name === playerName}`);
        console.log(`Case-insensitive comparison: "${currentPlayer.name}".toLowerCase() === "${playerName}".toLowerCase() = ${currentPlayer.name.toLowerCase() === playerName.toLowerCase()}`);
    }
    
    console.log('=== END DEBUG ===');
};

// Debug function to force enable dice for testing
window.forceEnableDice = function() {
    console.log('=== FORCE ENABLE DICE ===');
    const diceSection = document.getElementById('dice-section');
    if (diceSection) {
        removeAllDicePulseClasses(diceSection);
        const currentPlayer = players[currentPlayerIndex];
        const playerPulseClass = getPlayerDicePulseClassByPlayer(currentPlayer);
        diceSection.classList.add(playerPulseClass);
        diceSection.style.pointerEvents = 'auto';
        console.log(`âœ… Dice forcefully enabled for testing with player color: ${playerPulseClass}`);
        console.log('Classes:', diceSection.className);
        console.log('Pointer events:', diceSection.style.pointerEvents);
    } else {
        console.log('âŒ Dice section not found');
    }
    console.log('=== END FORCE ENABLE ===');
};

// Debug function to test and fix dice enablement with case sensitivity
window.testAndFixDice = function() {
    console.log('=== TEST AND FIX DICE ===');
    
    // First, run the debug to see current state
    window.debugPlayerNames();
    
    // Then force enable dice section to test the logic
    enableDiceSection();
    
    // Check the result
    const diceSection = document.getElementById('dice-section');
    if (diceSection) {
        console.log('Final dice state:');
        console.log('- Classes:', diceSection.className);
        console.log('- Pointer events:', diceSection.style.pointerEvents);
        console.log('- Computed pointer events:', window.getComputedStyle(diceSection).pointerEvents);
    }
    
    console.log('=== END TEST AND FIX ===');
};

// Debug function to fix player identity issues
window.fixPlayerIdentityIssues = function() {
    console.log('=== FIXING PLAYER IDENTITY ISSUES ===');
    
    // Check current state
    console.log('Current state:');
    console.log('- currentPlayerIndex:', currentPlayerIndex);
    console.log('- players array:', players);
    console.log('- localPlayerName:', window.localPlayerName);
    console.log('- input field value:', document.getElementById('player1-name')?.value);
    
    // Try to match by host status if name matching fails
    const inputField = document.getElementById('player1-name');
    const playerName = inputField?.value?.trim() || window.localPlayerName;
    
    if (playerName) {
        // Try to find player by name (case-insensitive)
        const matchingPlayer = players.find(p => p.name.toLowerCase() === playerName.toLowerCase());
        
        if (matchingPlayer) {
            console.log(`âœ… Found matching player: ${matchingPlayer.name}`);
            // Update local references
            window.localPlayerName = matchingPlayer.name;
            if (inputField) inputField.value = matchingPlayer.name;
        } else {
            console.log(`âŒ No player found with name: ${playerName}`);
            console.log('Available players:', players.map(p => p.name));
            
            // Try to match by host status
            const hostPlayer = players.find(p => p.isHost === isHost);
            if (hostPlayer) {
                console.log(`âœ… Found matching player by host status: ${hostPlayer.name}`);
                window.localPlayerName = hostPlayer.name;
                if (inputField) inputField.value = hostPlayer.name;
            } else {
                console.log('âŒ Could not find matching player by host status either');
            }
        }
    }
    
    // Force update dice section
    enableDiceSection();
    
    console.log('=== END FIX ===');
};

// Debug function to fix current player index mismatch
window.fixCurrentPlayerIndex = function() {
    console.log('=== FIXING CURRENT PLAYER INDEX ===');
    
    console.log('Before fix:');
    console.log('- currentPlayerIndex:', currentPlayerIndex);
    console.log('- current player name:', players[currentPlayerIndex]?.name);
    console.log('- local player name:', window.localPlayerName);
    
    // Check if current player index matches the expected current player
    const currentPlayer = players[currentPlayerIndex];
    const localPlayerName = window.localPlayerName;
    
    if (currentPlayer && localPlayerName) {
        // If the current player is the local player, then the index is correct
        if (currentPlayer.name.toLowerCase() === localPlayerName.toLowerCase()) {
            console.log('âœ… Current player index is correct - it\'s your turn');
        } else {
            console.log('âŒ Current player index mismatch detected');
            console.log(`Current player (${currentPlayer.name}) is not the local player (${localPlayerName})`);
            
            // Find the correct current player index
            const correctIndex = players.findIndex(p => p.name.toLowerCase() === localPlayerName.toLowerCase());
            if (correctIndex !== -1) {
                console.log(`âœ… Found correct index: ${correctIndex} for player ${localPlayerName}`);
                console.log('This suggests the current player index should be updated');
                
                // Ask user if they want to fix this
                if (confirm(`Current player index mismatch detected. Current: ${currentPlayer.name} (index ${currentPlayerIndex}), Local: ${localPlayerName} (index ${correctIndex}). Fix this?`)) {
                    currentPlayerIndex = correctIndex;
                    console.log(`âœ… Updated currentPlayerIndex to ${correctIndex}`);
                    
                    // Update the game state
                    players.forEach((p, i) => p.isCurrentPlayer = (i === currentPlayerIndex));
                    enableDiceSection();
                    updateGameFrame();
                }
            } else {
                console.log('âŒ Could not find local player in players array');
            }
        }
    }
    
    console.log('=== END FIX ===');
};

// Debug function to auto-fix local player name
window.autoFixLocalPlayerName = function() {
    console.log('=== AUTO-FIXING LOCAL PLAYER NAME ===');
    
    const currentPlayer = players[currentPlayerIndex];
    const localPlayerName = window.localPlayerName;
    
    console.log('Current state:');
    console.log('- currentPlayerIndex:', currentPlayerIndex);
    console.log('- current player:', currentPlayer?.name);
    console.log('- local player name:', localPlayerName);
    
    if (currentPlayer && localPlayerName && currentPlayer.name.toLowerCase() !== localPlayerName.toLowerCase()) {
        console.log('âŒ Mismatch detected - fixing local player name');
        
        // Update local player name to match current player
        window.localPlayerName = currentPlayer.name;
        
        // Update input field if it exists
        const inputField = document.getElementById('player1-name');
        if (inputField) {
            inputField.value = currentPlayer.name;
        }
        
        console.log(`âœ… Updated local player name from "${localPlayerName}" to "${currentPlayer.name}"`);
        
        // Force update dice section
        enableDiceSection();
        
        console.log('âœ… Dice section should now be enabled for your turn');
    } else {
        console.log('âœ… No mismatch detected - local player name is correct');
    }
    
    console.log('=== END AUTO-FIX ===');
};

// Debug function to check game room connection
window.debugGameRoom = function() {
    console.log('=== GAME ROOM DEBUG ===');
    
    // Check URL for room ID
    const urlParams = new URLSearchParams(window.location.search);
    const roomIdFromUrl = urlParams.get('room');
    console.log('Room ID from URL:', roomIdFromUrl);
    
    // Check current room connection
    console.log('Current room ID:', currentRoomId);
    console.log('Is connected to Firebase:', !!gameStateUnsubscribe);
    
    // Check if we're in a multiplayer game
    console.log('Is multiplayer game:', isMultiplayerGame);
    console.log('Is host:', isHost);
    
    // Check players in current game
    console.log('Players in current game:');
    if (players && players.length > 0) {
        players.forEach((p, i) => {
            console.log(`  ${i}: ${p.name} (host: ${p.isHost}, AI: ${p.isAI})`);
        });
    } else {
        console.log('  No players found');
    }
    
    // Check local player info
    console.log('Local player info:');
    console.log('- localPlayerName:', window.localPlayerName);
    console.log('- input field value:', document.getElementById('player1-name')?.value);
    console.log('- currentPlayerIndex:', currentPlayerIndex);
    console.log('- current player:', players[currentPlayerIndex]?.name);
    
    // Check if there's a mismatch
    const currentPlayer = players[currentPlayerIndex];
    const localPlayerName = window.localPlayerName;
    
    if (currentPlayer && localPlayerName) {
        const isMatch = currentPlayer.name.toLowerCase() === localPlayerName.toLowerCase();
        console.log(`Player match check: "${currentPlayer.name}" vs "${localPlayerName}" = ${isMatch}`);
        
        if (!isMatch) {
            console.log('âŒ MISMATCH DETECTED - Players are in different games!');
            console.log('This suggests you might be connected to the wrong room or there\'s a sync issue.');
        }
    }
    
    console.log('=== END GAME ROOM DEBUG ===');
};

// Auto-fix function that runs automatically
window.autoFixPlayerNameOnSync = function() {
    // Only run if we have valid game state
    if (!players || players.length === 0 || !window.localPlayerName) {
        return;
    }
    
    const localPlayerName = window.localPlayerName;
    
    // Find the actual local player in the players array (not just current turn player)
    const localPlayer = players.find(p => p.userId === currentUserId || p.name.toLowerCase() === localPlayerName.toLowerCase());
    
    // Only auto-fix if we found the local player and their name differs
    if (localPlayer && localPlayer.name.toLowerCase() !== localPlayerName.toLowerCase()) {
        console.log(`[autoFixPlayerNameOnSync] Auto-fixing player name mismatch: "${localPlayerName}" -> "${localPlayer.name}"`);
        
        // Update local player name to match their actual player data
        window.localPlayerName = localPlayer.name;
        
        // Update input field if it exists
        const inputField = document.getElementById('player1-name');
        if (inputField) {
            inputField.value = localPlayer.name;
        }
        
        // Force update dice section
        enableDiceSection();
    }
};

// Debug function to fix player name mismatch
window.fixPlayerName = function() {
    console.log('=== FIX PLAYER NAME ===');
    
    // Get player name from URL
    const urlParams = new URLSearchParams(window.location.search);
    const urlPlayerName = urlParams.get('player');
    console.log('URL player name:', urlPlayerName);
    
    // Get current input value
    const nameInput = document.getElementById('player1-name');
    const currentValue = nameInput?.value;
    console.log('Current input value:', currentValue);
    
    // Set the correct player name
    if (urlPlayerName && nameInput) {
        nameInput.value = urlPlayerName;
        window.localPlayerName = urlPlayerName;
        console.log(`âœ… Fixed player name to: ${urlPlayerName}`);
        
        // Force update dice section
        enableDiceSection();
        console.log('âœ… Called enableDiceSection() after fixing player name');
    } else {
        console.log('âŒ Could not fix player name - missing URL parameter or input field');
    }
    
    console.log('=== END FIX ===');
};

// Debug function to check multiplayer state
window.debugMultiplayerState = function() {
    console.log('=== MULTIPLAYER STATE DEBUG ===');
    console.log('isMultiplayerGame:', isMultiplayerGame);
    console.log('isHost:', isHost);
    console.log('currentRoomId:', currentRoomId);
    console.log('currentUserId:', currentUserId);
    console.log('currentPlayerIndex:', currentPlayerIndex);
    console.log('gameStateUnsubscribe exists:', !!gameStateUnsubscribe);
    
    // Check DOM elements
    const gameContainer = document.getElementById('game-container');
    console.log('Game container display:', gameContainer?.style.display);
    console.log('Intro screen display:', document.getElementById('intro-screen')?.style.display);
    
    // Check players data
    console.log('Local players array:', players);
    console.log('Players is array:', Array.isArray(players));
    console.log('Players length:', players?.length);
    
    // Check Firebase connection
    console.log('Firebase gameStateUnsubscribe:', typeof gameStateUnsubscribe);
    
    console.log('=== END MULTIPLAYER DEBUG ===');
};

// Debug function to force next turn (for testing)
window.forceNextTurn = function() {
    console.log('=== FORCING NEXT TURN ===');
    console.log('Before nextTurn - currentPlayerIndex:', currentPlayerIndex);
    console.log('Players:', players?.map(p => p.name));
    nextTurn();
    console.log('After nextTurn - currentPlayerIndex:', currentPlayerIndex);
    console.log('=== END FORCE TURN ===');
};

window.fixPlayerIdentity = function() {
    console.log('=== FIXING PLAYER IDENTITY ===');
    
    console.log('Current state:');
    console.log('- currentPlayerIndex:', currentPlayerIndex);
    console.log('- currentPlayer:', players[currentPlayerIndex]?.name);
    console.log('- localPlayerName:', window.localPlayerName);
    console.log('- input field name:', document.getElementById('player1-name')?.value);
    console.log('- isHost:', isHost);
    
    if (players && Array.isArray(players)) {
        console.log('All players:');
        players.forEach((p, i) => {
            console.log(`  Player ${i}: ${p.name} (host: ${p.isHost})`);
        });
        
        // Try to match by host status
        const myPlayer = players.find(p => p.isHost === isHost);
        if (myPlayer) {
            console.log(`Matching by host status: You should be "${myPlayer.name}"`);
            
            // Update local identity
            window.localPlayerName = myPlayer.name;
            document.getElementById('player1-name').value = myPlayer.name;
            
            console.log(`Identity fixed: You are now "${myPlayer.name}" (host: ${isHost})`);
            
            // Check if it's now your turn
            const currentPlayer = players[currentPlayerIndex];
            if (currentPlayer && currentPlayer.name === myPlayer.name) {
                console.log('After identity fix, it IS your turn!');
                showAdvisory(`Identity fixed! It's your turn, ${myPlayer.name}`, 'success');
            } else {
                console.log(`After identity fix, it's ${currentPlayer?.name}'s turn, not yours`);
                showAdvisory(`Identity fixed! You are ${myPlayer.name}. Waiting for ${currentPlayer?.name}'s turn.`, 'info');
            }
            
            // Update UI
            enableDiceSection();
        } else {
            console.log('Could not find matching player by host status');
        }
    }
    
    console.log('=== END IDENTITY FIX ===');
};

window.checkTokenStatus = function() {
    console.log('=== CHECKING TOKEN STATUS ===');
    
    if (!players || !Array.isArray(players)) {
        console.log('No players array found');
        return;
    }
    
    console.log('Players:', players.length);
    players.forEach((p, i) => {
        console.log(`Player ${i} (${p.name}):`, {
            currentSquare: p.currentSquare,
            x: p.x,
            y: p.y,
            hasImage: !!p.image,
            tokenImage: p.tokenImage,
            imageWidth: p.image?.width,
            imageHeight: p.image?.height,
            isHost: p.isHost
        });
    });
    
    console.log('Canvas info:', {
        hasCanvas: !!canvas,
        canvasWidth: canvas?.width,
        canvasHeight: canvas?.height
    });
    
    console.log('PositionsMap info:', {
        hasPositionsMap: !!positionsMap,
        positionsCount: positionsMap?.size || 0,
        goPosition: positionsMap?.get('go')
    });
    
    console.log('=== END TOKEN STATUS ===');
};

window.forceTokenSync = function() {
    console.log('=== FORCING TOKEN SYNC ===');
    
    if (!players || !Array.isArray(players)) {
        console.log('No players array found');
        return;
    }
    
    console.log('Current players:', players.length);
    players.forEach((p, i) => {
        console.log(`Player ${i}:`, {
            name: p.name,
            position: p.currentSquare,
            x: p.x,
            y: p.y,
            hasImage: !!p.image,
            tokenImage: p.tokenImage
        });
    });
    
    // Force update all player positions based on their current square
    players.forEach(player => {
        const pos = positionsMap?.get(player.currentSquare);
        if (pos) {
            player.x = pos.x;
            player.y = pos.y;
            console.log(`Updated ${player.name} position to x:${player.x}, y:${player.y} for square:${player.currentSquare}`);
        }
    });
    
    // Force sync to Firebase with complete data
    if (isMultiplayerGame) {
        console.log('Syncing token positions to Firebase...');
        syncGameStateToFirebase();
    }
    
    // Force redraw the game board
    console.log('Forcing game frame update...');
    updateGameFrame();
    
    showAdvisory('Token positions synchronized!', 'success');
    console.log('=== TOKEN SYNC COMPLETE ===');
};

window.recoverMissingPlayer = function() {
    console.log('=== RECOVERING MISSING PLAYER ===');
    
    if (!players || !Array.isArray(players)) {
        console.log('No players array found');
        return;
    }
    
    console.log('Current players:', players.length);
    players.forEach((p, i) => {
        console.log(`Player ${i}:`, p.name, 'Host:', p.isHost);
    });
    
    // If we only have 1 player but this is a multiplayer game, add the missing player
    if (players.length === 1 && isMultiplayerGame) {
        const existingPlayer = players[0];
        const missingPlayerIsHost = !existingPlayer.isHost;
        
        // Determine names based on what we know
        let hostName = 'teers';
        let guestName = 'bowels';
        
        // If the existing player is the host, they should be 'teers'
        if (existingPlayer.isHost && existingPlayer.name !== hostName) {
            hostName = existingPlayer.name;
        }
        // If the existing player is the guest, they should be 'bowels'  
        if (!existingPlayer.isHost && existingPlayer.name !== guestName) {
            guestName = existingPlayer.name;
        }
        
        const missingPlayer = {
            name: missingPlayerIsHost ? hostName : guestName,
            userId: missingPlayerIsHost ? 'user_host_recovered' : 'user_guest_recovered',
            isHost: missingPlayerIsHost,
            position: 0,
            currentSquare: 'go',
            currentPathKey: 'gamePath',
            currentIndexOnPath: 0,
            isMovingReverse: false,
            x: 0,
            y: 0,
            size: 62,
            money: 16500,
            properties: [],
            isAI: false,
            bankrupt: false,
            tokenImage: missingPlayerIsHost ? 'assets/images/t1.png' : 'assets/images/t2.png',
            tokenIndex: missingPlayerIsHost ? 0 : 1,
            inJail: false,
            jailTurns: 0,
            consecutiveDoubles: 0
        };
        
        // Insert the missing player in the correct position
        if (missingPlayerIsHost) {
            // Host should be first
            players.unshift(missingPlayer);
        } else {
            // Guest should be second
            players.push(missingPlayer);
        }
        
        console.log('Added missing player:', missingPlayer.name, 'Host:', missingPlayer.isHost);
        console.log('Players after recovery:', players.map(p => ({ name: p.name, isHost: p.isHost })));
        
        // Sync to Firebase
        if (isMultiplayerGame) {
            syncGameStateToFirebase();
        }
        
        // Update UI
        updatePlayerList(players);
        updateGameFrame();
        enableDiceSection();
        
        showAdvisory(`Recovered missing player: ${missingPlayer.name}`, 'success');
    } else {
        console.log('No recovery needed. Players:', players.length);
    }
    
    console.log('=== END RECOVERY ===');
};

// New function to automatically fix Firebase data corruption
window.autoFixFirebaseData = function() {
    console.log('=== AUTO-FIXING FIREBASE DATA ===');
    
    if (!isMultiplayerGame) {
        console.log('Not in multiplayer mode');
        return;
    }
    
    // Import and call Firebase fix functions
    import('./firebase-init.js').then(firebaseModule => {
        console.log('Attempting to fix Firebase array integrity...');
        firebaseModule.fixPlayersArrayIntegrity()
            .then(() => {
                console.log('âœ… Firebase array integrity check completed');
                showAdvisory('Firebase data integrity check completed', 'success');
            })
            .catch(error => {
                console.error('âŒ Failed to fix Firebase data:', error);
                showAdvisory('Failed to fix Firebase data: ' + error.message, 'error');
            });
    }).catch(error => {
        console.error('Failed to import Firebase module:', error);
    });
    
    console.log('=== END AUTO-FIX ===');
};

// Debug function to check background image status
window.debugBackground = function() {
    console.log('=== BACKGROUND DEBUG ===');
    console.log('Background image object:', backgroundImage);
    console.log('Background image exists:', !!backgroundImage);
    if (backgroundImage) {
        console.log('Background image src:', backgroundImage.src);
        console.log('Background image complete:', backgroundImage.complete);
        console.log('Background image naturalWidth:', backgroundImage.naturalWidth);
        console.log('Background image naturalHeight:', backgroundImage.naturalHeight);
        console.log('Background image width:', backgroundImage.width);
        console.log('Background image height:', backgroundImage.height);
    }
    console.log('Board image object:', boardImage);
    console.log('Board image exists:', !!boardImage);
    if (boardImage) {
        console.log('Board image src:', boardImage.src);
        console.log('Board image complete:', boardImage.complete);
        console.log('Board image naturalWidth:', boardImage.naturalWidth);
        console.log('Board image naturalHeight:', boardImage.naturalHeight);
    }
    console.log('Canvas object:', canvas);
    if (canvas) {
        console.log('Canvas width:', canvas.width);
        console.log('Canvas height:', canvas.height);
    }
    console.log('=== BACKGROUND DEBUG COMPLETE ===');
    
    // Force a redraw to test
    console.log('Forcing redraw...');
    updateGameFrame();
};

// Global variable to store board transparency level
let boardTransparency = 0.9; // Default 90% opacity (background slightly less visible)

// Mobile touch and pan variables (moved to top of file)
// let isMobile = false; // Moved to top of file
let touchStartX = 0;
let touchStartY = 0;
let currentPanX = 0;
let currentPanY = 0;
let isPanning = false;
let panIndicatorTimeout = null;
let panzoomInstance = null;

// Function to adjust board transparency dynamically
window.setBoardTransparency = function(opacity) {
    if (opacity < 0 || opacity > 1) {
        console.error('Opacity must be between 0 and 1');
        return;
    }
    
    boardTransparency = opacity;
    console.log(`Board transparency set to ${opacity} (${Math.round(opacity * 100)}% opacity)`);
    
    // Force redraw to show the change
    updateGameFrame();
    
    showAdvisory(`Board transparency: ${Math.round(opacity * 100)}%`, 'info');
};

// Mobile detection and touch handling functions
function detectMobile() {
    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
    const screenWidth = window.innerWidth;
    
    isMobile = /android|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent) || screenWidth <= 768;
    
    if (isMobile) {
        console.log('Mobile device detected, enabling touch controls');
        initializeMobileControls();
    }
    
    return isMobile;
}

function initializeMobileControls() {
    const canvas = document.querySelector('canvas');
    const gameContainer = document.getElementById('game-container');
    const panIndicator = document.getElementById('pan-indicator');

    // Don't initialize mobile controls if elements are missing - this might be called too early
    if (!canvas || !gameContainer) {
        console.log('ðŸ“± Mobile controls initialization skipped - canvas or gameContainer not ready');
        
        // Retry after a short delay if elements aren't ready yet
        setTimeout(() => {
            if (document.querySelector('canvas') && document.getElementById('game-container')) {
                console.log('ðŸ“± Retrying mobile controls initialization...');
                initializeMobileControls();
            } else {
                console.log('ðŸ“± Mobile controls initialization failed - elements still not ready');
            }
        }, 1000);
        
        return;
    }
    
    console.log('ðŸ“± Initializing mobile controls for multiplayer compatibility');

    // Initialize panzoom for smoother pan and pinch zoom (mobile only)
    if (typeof Panzoom !== 'undefined') {
        if (panzoomInstance) {
            panzoomInstance.destroy();
        }
        panzoomInstance = Panzoom(canvas, {
            maxScale: 8,
            minScale: 0.5,
            contain: isMobile ? 'none' : 'outside' // Free panning on mobile, contained on desktop
        });
        canvas.parentElement.addEventListener('wheel', panzoomInstance.zoomWithWheel);

        canvas.addEventListener('panzoomstart', () => { isPanning = true; });
        canvas.addEventListener('panzoomend', () => { isPanning = false; });
    }

    // Show pan indicator briefly on mobile
    if (panIndicator) {
        panIndicator.style.display = 'block';
        setTimeout(() => {
            panIndicator.style.display = 'none';
        }, 3000);
    }

    // Touch event handlers for canvas
    canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
    canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
    
    // Also add touch handlers to dice section for better mobile UX
    const diceSection = document.getElementById('dice-section');
    if (diceSection) {
        // Remove any existing touch listeners first to avoid duplicates
        diceSection.removeEventListener('touchstart', handleDiceTouchStart);
        diceSection.removeEventListener('touchend', handleDiceTouchEnd);
        
        // Add new touch listeners
        diceSection.addEventListener('touchstart', handleDiceTouchStart, { passive: false });
        diceSection.addEventListener('touchend', handleDiceTouchEnd, { passive: false });
        
        console.log('Added touch event listeners to dice section');
    }
    
    // Add touch feedback to buttons
    const buttons = document.querySelectorAll('button');
    buttons.forEach(button => {
        button.addEventListener('touchstart', () => {
            button.classList.add('touch-feedback');
        });
        button.addEventListener('touchend', () => {
            setTimeout(() => {
                button.classList.remove('touch-feedback');
            }, 150);
        });
    });
}

// Helper function to get accurate touch coordinates for canvas
function getScaledTouchCoordinates(touch, canvas) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    return {
        x: (touch.clientX - rect.left) * scaleX,
        y: (touch.clientY - rect.top) * scaleY
    };
}

function handleTouchStart(e) {
    if (e.touches && e.touches.length > 1) {
        // Allow pinch gestures to pass through
        return;
    }
    e.preventDefault();
    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
    isPanning = false;
}


function handleTouchEnd(e) {
    if (e.changedTouches && e.changedTouches.length > 1) {
        // Ignore multi-touch end events
        isPanning = false;
        return;
    }
    e.preventDefault();

    if (!isPanning && e.changedTouches.length === 1) {
        // This was a tap, not a pan
        const touch = e.changedTouches[0];
        const canvas = document.querySelector('canvas');
        
        if (canvas) {
            // Use the helper function for accurate coordinate scaling
            const coords = getScaledTouchCoordinates(touch, canvas);
            const x = coords.x;
            const y = coords.y;
            
            // Check for double-tap (similar to double-click logic)
            const currentTime = Date.now();
            const timeSinceLastTap = currentTime - lastTapTime;
            const distanceFromLastTap = Math.sqrt(
                Math.pow(x - lastTapPosition.x, 2) + 
                Math.pow(y - lastTapPosition.y, 2)
            );
            
            // Enhanced double-tap detection with better mobile and tablet support
            const isTabletDevice = window.isTablet || (window.deviceInfo && window.deviceInfo.isTablet);
            const tabletThreshold = isTabletDevice ? 900 : DOUBLE_CLICK_THRESHOLD; // Increased to 900ms for tablets
            const isDoubleTap = timeSinceLastTap < tabletThreshold && distanceFromLastTap < CLICK_POSITION_THRESHOLD;
            
            console.log(`Touch event: timeSince=${timeSinceLastTap}ms, distance=${Math.round(distanceFromLastTap)}px, threshold=${CLICK_POSITION_THRESHOLD}px, isDoubleTap=${isDoubleTap}`);
            
            if (isDoubleTap) {
                // This is a double-tap - check for property stealing
                console.log(`âœ… Double-tap detected at coordinates: x=${Math.round(x)}, y=${Math.round(y)}`);
                
                // Show brief visual feedback for double-tap
                if (isMobile) {
                    showAdvisory(`ðŸŽ¯ Double-tap detected! Checking for stealable properties...`, 'info');
                }
                
                // Handle property stealing
                handlePropertySteal(x, y);
                
                // Prevent single tap from firing after double tap
                return;
            } else {
                // Single tap - check if it's for dice rolling (with a slightly larger delay to avoid conflicts on touch)
                console.log(`Single tap detected at coordinates: x=${Math.round(x)}, y=${Math.round(y)}`);
                setTimeout(() => {
                    handleCanvasTap(x, y);
                }, 120); // Give double-tap detection more priority on mobile/tablet
            }
            
            // Update last tap info
            lastTapTime = currentTime;
            lastTapPosition = { x: x, y: y };
        }
    }
    
    isPanning = false;
}

function handleCanvasTap(x, y) {
    // Check if tap is in a reasonable area for dice rolling
    const canvas = document.querySelector('canvas');
    if (!canvas) return;
    
    const canvasRect = canvas.getBoundingClientRect();
    const centerX = canvasRect.width / 2;
    const centerY = canvasRect.height / 2;
    
    // If tap is near center of board, trigger dice roll
    const distanceFromCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
    if (distanceFromCenter < 200) { // Within 200px of center
        console.log('Canvas tap detected in center area, calling handleDiceClick');
        handleDiceClick('canvas-tap');
    } else {
        console.log('Canvas tap outside dice roll area:', { x, y, centerX, centerY, distanceFromCenter });
    }
}

function handleDiceTouchStart(e) {
    e.preventDefault();
    const diceSection = e.currentTarget;
    diceSection.classList.add('touch-feedback');
}

function handleDiceTouchEnd(e) {
    e.preventDefault();
    e.stopPropagation();
    // Set suppression window to avoid duplicate click from synthetic mouse event on tablets
    suppressNextMouseClickUntil = Date.now() + DUPLICATE_CLICK_WINDOW_MS;
    const diceSection = e.currentTarget;
    
    setTimeout(() => {
        diceSection.classList.remove('touch-feedback');
    }, 150);
    
    // Use the proper dice click handler instead of direct trigger
    console.log('ðŸ“± Mobile dice touch end - calling handleDiceClick');
    handleDiceClick('mobile-touch');
}

async function triggerDiceRoll() {
    console.log('triggerDiceRoll called - Current state:', {
        isAITurn,
        isRecordingEyes,
        currentPlayerIndex,
        currentPlayer: players[currentPlayerIndex]?.name
    });

    if (isDiceRollInProgress) {
        console.log('Dice roll ignored - roll already in progress');
        return;
    }

    // Prevent clicking if recording eyes
    if (isRecordingEyes) {
        console.log('Cannot roll - recording eyes', { isRecordingEyes });
        return;
    }
    
    // In multiplayer, check if it's the current player's turn
    if (isMultiplayerGame) {
        if (isBoltTargetingMode) {
            showAdvisory('Exit bolt targeting (tap Fire Bolt again) before rolling.', 'info');
            return;
        }
        const currentPlayer = players[currentPlayerIndex];
        let playerName = document.getElementById('player1-name').value.trim();
        
        // If player name is empty, try to get it from the stored local player name
        if (!playerName && window.localPlayerName) {
            playerName = window.localPlayerName;
            document.getElementById('player1-name').value = playerName;
        }
        
        // Check if this browser belongs to the current player by comparing names (case-insensitive)
        const isMyTurn = currentPlayer && currentPlayer.name.toLowerCase() === playerName.toLowerCase();
        
        if (!isMyTurn) {
            console.log('Cannot roll - not your turn in multiplayer', { 
                currentPlayer: currentPlayer ? currentPlayer.name : 'Unknown', 
                yourName: playerName,
                currentPlayerIndex: currentPlayerIndex,
                isMyTurn: isMyTurn
            });
            
            // Show clearer turn information
            const turnMessage = currentPlayer ? 
                `Waiting for ${currentPlayer.name}'s turn (You are ${playerName})` : 
                'Waiting for another player\'s turn';
            showAdvisory(turnMessage, 'info');
            return;
        }
    }
    
    // Prevent clicking if it's AI's turn (only for AI vs Human games)
    if (!isMultiplayerGame && isAITurn) {
        console.log('Cannot roll - AI turn', { isAITurn });
        return;
    }
    
    // Check if player is on an unpurchased property or can develop a property they own
    const currentPlayer = players[currentPlayerIndex];
    const propertyInfo = getPropertyInfo(currentPlayer.currentSquare);
    const hasUnpurchasedProperty = propertyInfo && !propertyInfo.state.owner && !currentPlayer.isAI;
    const canDevelop = propertyInfo && propertyInfo.state.owner === currentPlayer.name && !currentPlayer.isAI && canDevelopProperty(currentPlayer, propertyInfo.square);
    const hasDevelopmentOption = canDevelop && getDevelopmentCost(propertyInfo.square) && currentPlayer.money >= getDevelopmentCost(propertyInfo.square).cost;
    
    if (hasUnpurchasedProperty) {
        console.log('Cannot take turn - player needs to make purchase decision');
        showAdvisory('Please make a purchase decision first - either buy or decline the property', 'info');
        updateInfoPanel();
        return;
    }
    
    if (hasDevelopmentOption) {
        console.log('Player has development option but clicked dice - treating as "skip development"');
        showAdvisory('Skipping development and rolling dice...', 'info');
        updateInfoPanel();
    }

    clearAutoRollTimer(); // Clear any existing timer
    
    isDiceRollInProgress = true;
    const diceSection = document.getElementById("dice-section");
    if (diceSection) diceSection.style.pointerEvents = "none";

    if (isInitialRoll && !isMultiplayerGame) {
        // Handle initial roll to determine first player (only for AI games)
        const message = await determineFirstPlayer();
        showAdvisory(message, 'turn');
        isInitialRoll = false; // Set to false after initial roll
        updateDicePulsing(); // Update dice visual state
        if (isAITurn) {
            // If AI goes first, start their turn
            setTimeout(async () => {
                await handleAITurn();
            }, 1500);
        }
    } else if (isInitialRoll && isMultiplayerGame) {
        // For multiplayer, skip initial roll determination (already handled in startMultiplayerGame)
        console.log('triggerDiceRoll: Skipping first player determination - already handled in multiplayer initialization');
        isInitialRoll = false;
        updateDicePulsing();
        await takeTurn();
    } else {
        // Handle regular turn (or multiplayer first turn)
        await takeTurn();
    }
    isDiceRollInProgress = false;
}

// Reset canvas pan position
function resetCanvasPan() {
    const canvas = document.querySelector('canvas');
    if (panzoomInstance) {
        panzoomInstance.reset();
    } else if (canvas) {
        canvas.style.transform = 'translate(0px, 0px)';
    }
    currentPanX = 0;
    currentPanY = 0;
}

// Steal card system functions
function startGojailGlowSystem() {
    // Schedule the first glow event
    scheduleNextGojailGlow();
    console.log('Gojail glow system started');
}

function scheduleNextGojailGlow() {
    // Clear any existing timeout
    if (gojailGlowTimeout) {
        clearTimeout(gojailGlowTimeout);
    }
    
    // Random time between 2-3 minutes (120000-180000 ms)
    const minTime = 2 * 60 * 1000; // 2 minutes
    const maxTime = 3 * 60 * 1000; // 3 minutes
    const randomTime = Math.random() * (maxTime - minTime) + minTime;
    
    nextGojailGlowTime = Date.now() + randomTime;
    
    gojailGlowTimeout = setTimeout(() => {
        activateGojailGlow();
    }, randomTime);
    
    console.log(`Next gojail glow scheduled in ${Math.round(randomTime / 1000)} seconds`);
}

function activateGojailGlow() {
    gojailGlowActive = true;
    gojailGlowPlayersReceived.clear(); // Reset tracking for new glow event
    console.log('Gojail is now glowing green!');
    showAdvisory('The Witches Grave is glowing green! Land on it to get a steal card!', 'info');
    
    // Play witchlaugh sound when the graveyard glows green
    playWitchlaughSound();
    
    // Glow lasts for 50 seconds
    setTimeout(() => {
        deactivateGojailGlow();
    }, 50000);
    
    // Update the game frame to show the glow
    updateGameFrame();
}

function deactivateGojailGlow() {
    gojailGlowActive = false;
    console.log('Gojail glow deactivated');
    
    // Schedule the next glow
    scheduleNextGojailGlow();
    
    // Update the game frame to remove the glow
    updateGameFrame();
}

async function checkGojailLanding(player) {
    if (player.currentSquare === 'gojail') {
        // Player landed on gojail - always send to jail and play sound
        console.log(`${player.name} landed on gojail - sending to jail`);
        
        // Play jail sound
        await playJailSound();
        
        // Show flashing "Dungeon" text in middle of screen
        showDungeonFlash();
        
        // Check if gojail is glowing for steal card bonus
        let receivedStealCard = false;
        if (gojailGlowActive && !gojailGlowPlayersReceived.has(player.name)) {
            // Player landed on gojail while it's glowing and hasn't received a card yet - give them a steal card!
            player.stealCards++;
            gojailGlowPlayersReceived.add(player.name); // Mark player as having received a card
            deactivateGojailGlow(); // Stop the glow immediately
            receivedStealCard = true;
            
            // Play steal award sound
            playStealAwardSound();
            
            console.log(`${player.name} received a steal card! Total steal cards: ${player.stealCards}`);
        }
        
        // Send player to jail with Â£100 charge
        // Note: sendPlayerToJail will show its own message, but we'll override it if there's a steal card
        await sendPlayerToJail(player, 100);
        
        // Show enhanced message if steal card was received
        if (receivedStealCard) {
            showAdvisory(`${player.name} landed on The Witches Grave, received a STEAL CARD, sent to Jail, and charged Â£100! Double-click any property to steal it!`, 'turn');
        }
        
        // Update info panel to show the steal card if received
        updateInfoPanel();
        
        // End the turn immediately - gojail always ends the turn
        consecutiveDoublesCount = 0;
        lastRollWasDoubles = false;
        console.log(`${player.name} sent to jail from gojail. Turn ends, calling nextTurn().`);
        nextTurn();
        
        return true; // Indicates gojail landing was processed
    }
    return false;
}

function handlePropertySteal(clickX, clickY, isRetry = false) {
    // IMPORTANT: Steal cards should work during ANY game state, including:
    // - Purchase decisions pending
    // - Development decisions pending  
    // - Any other turn state
    // This is independent of dice rolling or other game mechanics
    
    // Enhanced tablet coordinate handling
    const isTabletDevice = window.isTablet || (window.deviceInfo && window.deviceInfo.isTablet);
    if (isTabletDevice) {
        console.log(`ðŸŽ¯ TABLET STEAL CARD: Processing steal at coordinates (${Math.round(clickX)}, ${Math.round(clickY)})`);
        
        // Add small vibration feedback if supported
        if (navigator.vibrate) {
            navigator.vibrate(50);
        }
    }
    
    // Find the current human player
    const currentPlayer = players[currentPlayerIndex];
    if (!currentPlayer) {
        console.log('Property steal attempted but current player not found');
        showAdvisory('Error: Current player not found. Please refresh the game.', 'error');
        return;
    }
    
    // Debug logging
    console.log(`Steal attempt at x=${Math.round(clickX)}, y=${Math.round(clickY)}`);
    console.log(`Current player: ${currentPlayer.name}, Is AI: ${currentPlayer.isAI}, Has steal cards: ${currentPlayer.stealCards}`);
    
    // Check if player has pending purchase decision
    const playerPropertyInfo = getPropertyInfo(currentPlayer.currentSquare);
    const hasPendingPurchase = playerPropertyInfo && !playerPropertyInfo.state.owner && !currentPlayer.isAI;
    if (hasPendingPurchase) {
        console.log('ðŸŽ¯ Steal card usage during purchase decision - this is allowed!');
    }
    
    // SIMPLIFIED: Allow AI players to use steal cards too (for consistency)
    // Only block if it's an AI turn but a human is trying to steal
    if (currentPlayer.isAI && !isAITurn) {
        console.log('Property steal attempted but current player is AI and not AI turn');
        showAdvisory("It's not your turn! Wait for the AI to finish their turn.", 'error');
        return;
    }
    
    // SIMPLIFIED: In multiplayer mode, use more robust turn validation
    if (isMultiplayerGame) {
        const inputPlayerName = document.getElementById('player1-name')?.value?.trim() || '';
        const localPlayerName = window.localPlayerName || '';
        const currentPlayerName = currentPlayer.name || '';
        
        console.log('ðŸŽ¯ MULTIPLAYER STEAL VALIDATION:', {
            currentPlayer: currentPlayerName,
            inputPlayerName: inputPlayerName,
            localPlayerName: localPlayerName,
            isHost: isHost,
            currentPlayerIsHost: currentPlayer.isHost
        });
        
        // Try multiple matching strategies
        let isMyTurn = false;
        let matchReason = '';
        
        // Strategy 1: Direct name match with input field
        if (currentPlayerName.toLowerCase() === inputPlayerName.toLowerCase() && inputPlayerName) {
            isMyTurn = true;
            matchReason = 'input field match';
        }
        // Strategy 2: Direct name match with local player name
        else if (currentPlayerName.toLowerCase() === localPlayerName.toLowerCase() && localPlayerName) {
            isMyTurn = true;
            matchReason = 'local player name match';
        }
        // Strategy 3: Host status match (fallback)
        else if (currentPlayer.isHost === isHost && (inputPlayerName || localPlayerName)) {
            isMyTurn = true;
            matchReason = 'host status match';
        }
        
        console.log(`ðŸŽ¯ Turn validation result: ${isMyTurn} (${matchReason})`);
        
        if (!isMyTurn) {
            console.log(`âŒ Property steal BLOCKED - not your turn. Current: "${currentPlayerName}", You: "${inputPlayerName}" / "${localPlayerName}"`);
            showAdvisory(`It's ${currentPlayer.name}'s turn, not yours! You can only steal during your turn.`, 'error');
            
            // Additional debugging info
            console.log('ðŸ”§ STEAL CARD DEBUG INFO:');
            console.log('   - Make sure your player name matches exactly');
            console.log('   - Try refreshing the page if names are out of sync');
            console.log('   - Check that you are the current player in the game');
            return;
        } else {
            console.log(`âœ… Multiplayer turn validation passed (${matchReason})`);
        }
    }
    
    // CORE REQUIREMENT: Must have steal cards
    if (currentPlayer.stealCards <= 0) {
        console.log('Property steal attempted but player has no steal cards');
        showAdvisory('You need a steal card to steal properties! Pass GO 4 times or land on The Witches Grave to get steal cards.', 'error');
        return;
    }
    
    // Find which property was clicked
    let targetProperty = null;
    let targetSquare = null;
    let closestDistance = Infinity;
    let closestProperty = null;
    
    // Use an even larger detection radius for mobile devices and tablets
    const isTabletForRadius = window.isTablet || (window.deviceInfo && window.deviceInfo.isTablet);
    const detectionRadius = isTabletForRadius ? 220 : (isMobile ? 180 : 40); // Even larger for tablets: 220px
    
    // Enhanced visual feedback for tablets with better visibility
    const ctx = canvas.getContext('2d');
    ctx.save();
    
    // Clear any previous feedback
    updateGameFrame();
    
    // Draw click position with enhanced visibility for tablets
    ctx.fillStyle = isTabletDevice ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 255, 0, 0.3)';
    ctx.beginPath();
    ctx.arc(clickX, clickY, isTabletDevice ? 8 : 5, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw detection radius with better visibility for tablets
    ctx.strokeStyle = isTabletDevice ? 'rgba(0, 255, 0, 0.4)' : 'rgba(255, 255, 0, 0.2)';
    ctx.lineWidth = isTabletDevice ? 3 : 1;
    ctx.beginPath();
    ctx.arc(clickX, clickY, detectionRadius, 0, Math.PI * 2);
    ctx.stroke();
    
    // Add tablet-specific debugging info
    if (isTabletDevice) {
        console.log(`ðŸŽ¯ TABLET STEAL ATTEMPT: coords(${Math.round(clickX)}, ${Math.round(clickY)}), radius: ${detectionRadius}px`);
    }
    
    // Clear feedback after a short delay
    setTimeout(() => {
        updateGameFrame();
    }, isTabletDevice ? 800 : 500); // Longer feedback for tablets
    
    ctx.restore();
    
    // First pass: find all properties within detection radius
    const nearbyProperties = [];
    
    // Debug logging for property positions
    console.log('Checking properties within radius:', detectionRadius);
    
    // SIMPLIFIED: Check if positionsMap is available - if not, attempt to reload once
    if (!positionsMap || positionsMap.size === 0) {
        console.warn('positionsMap not available for steal card system!');
        
        if (isRetry) {
            showAdvisory('Error: Game positions not loaded. Please refresh the page and try again.', 'error');
            return;
        }
        
        showAdvisory('Loading game positions... Please wait.', 'info');
        
        // Attempt to reload positions
        loadPositions().then(() => {
            console.log('Positions reloaded successfully, retrying steal operation');
            setPositionsMap(positionsMap);
            // Retry the steal operation (with isRetry=true to prevent infinite loop)
            handlePropertySteal(clickX, clickY, true);
        }).catch(error => {
            console.error('Failed to reload positions:', error);
            showAdvisory('Error: Could not load game positions. Please refresh the page and try again.', 'error');
        });
        return;
    }
    
    console.log('positionsMap has', positionsMap.size, 'entries');
    
    for (const [square, position] of positionsMap.entries()) {
        const distance = Math.sqrt(
            Math.pow(clickX - position.x, 2) + 
            Math.pow(clickY - position.y, 2)
        );
        
        // Debug log each property check
        console.log(`Property ${square} at (${position.x}, ${position.y}), distance: ${Math.round(distance)}`);
        
        // Keep track of the closest property and all nearby properties
        if (distance < detectionRadius) {
            const propertyInfo = getPropertyInfo(square);
            if (propertyInfo) {
                console.log(`Found property in range: ${square}`);
                console.log(`Owner: ${propertyInfo.state.owner}`);
                console.log(`Is stealable: ${propertyInfo.state.owner && propertyInfo.state.owner !== currentPlayer.name}`);
                
                if (propertyInfo.state.owner && propertyInfo.state.owner !== currentPlayer.name) {
                    nearbyProperties.push({
                        square,
                        propertyInfo,
                        distance,
                        position
                    });
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestProperty = {
                            square,
                            propertyInfo,
                            position
                        };
                    }
                }
            }
        }
    }
    
    // Debug log nearby properties
    console.log('Nearby properties:', nearbyProperties.map(p => ({
        square: p.square,
        distance: Math.round(p.distance),
        owner: p.propertyInfo.state.owner
    })));
    
    // If we found nearby properties, use the closest one
    if (closestProperty) {
        targetProperty = closestProperty.propertyInfo;
        targetSquare = closestProperty.square;
        
        // Show temporary highlight for selected property
        ctx.save();
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(closestProperty.position.x, closestProperty.position.y, 20, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
        
        // Clear highlight after a short delay
        setTimeout(() => {
            updateGameFrame();
        }, 500);
    }
    
    if (!targetProperty) {
        if (isMobile) {
            // Show more helpful message with nearby properties
            let message;
            if (nearbyProperties.length > 0) {
                message = `No stealable properties found in this area. Make sure to double-tap on a property star that's owned by another player.`;
            } else {
                // Show available stealable properties
                const stealableProperties = [];
                for (const [square, position] of positionsMap.entries()) {
                    const propertyInfo = getPropertyInfo(square);
                    if (propertyInfo && propertyInfo.state.owner && propertyInfo.state.owner !== currentPlayer.name) {
                        stealableProperties.push(getPropertyDisplayNameWithoutNumber(propertyInfo));
                    }
                }
                
                if (stealableProperties.length > 0) {
                    message = `No properties found at tap location (${Math.round(clickX)}, ${Math.round(clickY)}). Try double-tapping on: ${stealableProperties.slice(0, 3).join(', ')}${stealableProperties.length > 3 ? '...' : ''}`;
                } else {
                    message = `No stealable properties available. Other players need to own properties first!`;
                }
            }
            showAdvisory(message, 'info');
        } else {
            showAdvisory('No owned property found at that location. Double-click directly on a property star to steal it!', 'info');
        }
        return;
    }
    
    // Execute the steal
    const previousOwner = players.find(p => p.name.toLowerCase() === (targetProperty.state.owner || '').toLowerCase());
    if (previousOwner) {
        // Remove property from previous owner
        previousOwner.properties = previousOwner.properties.filter(prop => prop !== targetSquare);
        
        // Add property to current player
        currentPlayer.properties.push(targetSquare);
        
        // Update property state
        targetProperty.state.owner = currentPlayer.name;
        targetProperty.state.ownerColor = currentPlayer.color || getPlayerColor(currentPlayer.name);
        
        // Use a steal card
        currentPlayer.stealCards--;
        
        // Show steal message
        const propertyDisplayName = getPropertyDisplayNameWithoutNumber(targetProperty);
        showAdvisory(`${currentPlayer.name} used a STEAL CARD to steal ${propertyDisplayName} from ${previousOwner.name}!`, 'turn');
        
        // Play appropriate sound effect for the steal
        if (targetProperty.state.hasCrypt) {
            playStealCryptSound();
        } else {
            playZapSound();
        }
        
        console.log(`${currentPlayer.name} stole ${targetSquare} from ${previousOwner.name} using a steal card`);
        
        // Update the game display
        updateInfoPanel();
        updateGameFrame();
        
        // Check if the player now has development options available after stealing
        checkForDevelopmentOptionsAfterSteal(currentPlayer, targetSquare);
        
        // Sync to Firebase if multiplayer
        if (isMultiplayerGame) {
            // Update both players' data
            const currentPlayerIndex = players.findIndex(p => p.name.toLowerCase() === currentPlayer.name.toLowerCase());
            const previousOwnerIndex = players.findIndex(p => p.name.toLowerCase() === previousOwner.name.toLowerCase());
            
            if (currentPlayerIndex !== -1) {
                updatePlayerData(currentPlayerIndex, {
                    properties: currentPlayer.properties,
                    stealCards: currentPlayer.stealCards
                }).catch(error => console.error('Error updating current player steal data:', error));
            }
            
            if (previousOwnerIndex !== -1) {
                updatePlayerData(previousOwnerIndex, {
                    properties: previousOwner.properties
                }).catch(error => console.error('Error updating previous owner data:', error));
            }
            
            // Update property state
            updatePropertyState(targetSquare, targetProperty.state).catch(error => 
                console.error('Error updating property state:', error));
        }
    }
}

// Check for development options after stealing a property
function checkForDevelopmentOptionsAfterSteal(player, stolenProperty) {
    console.log(`[checkForDevelopmentOptionsAfterSteal] Checking development options for ${player.name} after stealing ${stolenProperty}`);
    
    const stolenPropertyInfo = getPropertyInfo(stolenProperty);
    if (!stolenPropertyInfo) {
        console.log(`[checkForDevelopmentOptionsAfterSteal] No property info found for ${stolenProperty}`);
        return;
    }
    
    // Check if the player can now develop the stolen property
    if (canDevelopProperty(player, stolenProperty)) {
        const devInfo = getDevelopmentCost(stolenProperty);
        if (devInfo && player.money >= devInfo.cost) {
            console.log(`ðŸ—ï¸ [checkForDevelopmentOptionsAfterSteal] ${player.name} can now develop ${stolenProperty}! Showing development options.`);
            
            // Show development options for the stolen property
            showDevelopmentOptionsForProperty(player, stolenProperty, stolenPropertyInfo);
            return;
        }
    }
    
    // If the stolen property can't be developed, check if stealing it completed a group
    // and now allows development of other properties in the same group
    const group = stolenPropertyInfo.group;
    const groupPositions = propertyGroups[group]?.positions || [];
    
    for (const propertySquare of groupPositions) {
        const propState = propertyState[propertySquare];
        if (propState && propState.owner === player.name && propertySquare !== stolenProperty) {
            if (canDevelopProperty(player, propertySquare)) {
                const devInfo = getDevelopmentCost(propertySquare);
                if (devInfo && player.money >= devInfo.cost) {
                    console.log(`ðŸ—ï¸ [checkForDevelopmentOptionsAfterSteal] ${player.name} can now develop ${propertySquare} in the ${group} group! Showing development options.`);
                    
                    const propertyInfo = getPropertyInfo(propertySquare);
                    showDevelopmentOptionsForProperty(player, propertySquare, propertyInfo);
                    return;
                }
            }
        }
    }
    
    console.log(`[checkForDevelopmentOptionsAfterSteal] No development options available for ${player.name} after stealing ${stolenProperty}`);
}

// Show development options for a specific property
function showDevelopmentOptionsForProperty(player, propertySquare, propertyInfo) {
    console.log(`[showDevelopmentOptionsForProperty] Showing development options for ${player.name} on property ${propertySquare}`);
    
    // Check if player has already declined development for this property
    const hasDeclinedDevelopment = playerDeclinedProperties.has(player.name) && 
                                 playerDeclinedProperties.get(player.name).has(`dev_${propertySquare}`);
    
    if (hasDeclinedDevelopment) {
        console.log(`[showDevelopmentOptionsForProperty] Player ${player.name} has already declined development for ${propertySquare}`);
        return;
    }
    
    const devInfo = getDevelopmentCost(propertySquare);
    if (!devInfo || player.money < devInfo.cost) {
        console.log(`[showDevelopmentOptionsForProperty] Cannot afford development: devInfo=${!!devInfo}, cost=${devInfo?.cost}, money=${player.money}`);
        return;
    }
    
    // Update the info panel to show the property with development options
    const propertyInfoContent = document.getElementById('property-info-content');
    if (!propertyInfoContent) {
        console.error('[showDevelopmentOptionsForProperty] property-info-content element not found');
        return;
    }
    
    // Create development buttons
    const developButton = `
        <button onclick="handlePropertyDevelopment('${propertySquare}', ${players.indexOf(player)})" 
                ontouchstart="this.style.transform='scale(0.95)'" 
                ontouchend="this.style.transform='scale(1)'"
                style="margin-top: 10px; background-color: #9C27B0; color: white; border: 1px solid #bb33cc; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-family: 'Courier New', 'Lucida Console', 'Monaco', 'Consolas', monospace; font-weight: bold; text-shadow: 0 0 4px #ff00ff; box-shadow: 0 0 8px rgba(156, 39, 176, 0.5); min-height: 36px; min-width: 36px; touch-action: manipulation;">
            Build ${devInfo.type} for Â£${devInfo.cost}
        </button>
        <button onclick="handleDeclineDevelopment('${propertySquare}', ${players.indexOf(player)})" 
                ontouchstart="this.style.transform='scale(0.95)'" 
                ontouchend="this.style.transform='scale(1)'"
                style="margin-top: 10px; margin-left: 10px; background-color: #666; color: white; border: 1px solid #888; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-family: 'Courier New', 'Lucida Console', 'Monaco', 'Consolas', monospace; font-weight: bold; text-shadow: 0 0 4px #ccc; box-shadow: 0 0 8px rgba(102, 102, 102, 0.5); min-height: 36px; min-width: 36px; touch-action: manipulation;">
            Develop Later
        </button>`;
    
    // Calculate rent info for display
    const rentInfo = calculateRent(propertyInfo);
    let rentDisplay = `Rent: Â£${rentInfo.amount}`;
    if (rentInfo.breakdown && rentInfo.breakdown.length > 0) {
        rentDisplay += `<br><small style="color: #ccc;">${rentInfo.breakdown.join('<br>')}</small>`;
    }
    if (rentInfo.multiplier > 1) {
        rentDisplay += `<br><small style="color: #ffaa00;">Total multiplier: ${rentInfo.multiplier}x</small>`;
    }
    
    // Show the property info with development options
    propertyInfoContent.innerHTML = `
        <div style="background: rgba(255, 255, 255, 0.1); padding: 10px; border-radius: 4px; margin-top: 10px; text-align: center;">
            <div style="font-weight: bold; color: ${propertyInfo.color}; font-family: 'Courier New', 'Lucida Console', 'Monaco', 'Consolas', monospace; font-size: 14px; text-shadow: 0 0 8px ${propertyInfo.color}; letter-spacing: 1px;">
                ${getPropertyDisplayNameWithoutNumber(propertyInfo)}
            </div>
            <div style="font-size: 12px; margin-top: 8px; font-family: 'Courier New', 'Lucida Console', 'Monaco', 'Consolas', monospace; text-align: center; line-height: 1.4;">
                Cost: Â£${propertyInfo.cost}<br>
                Owner: ${player.name}<br>
                ${rentDisplay}<br>
                Graveyards: ${propertyInfo.state.graveyards}/4<br>
                ${propertyInfo.state.hasCrypt ? 'Has Crypt' : 'No Crypt'}
            </div>
            <div style="color: #40e0d0; font-weight: bold; margin-top: 8px; font-family: 'Courier New', 'Lucida Console', 'Monaco', 'Consolas', monospace;">
                ðŸ—ï¸ Development Available!
            </div>
            ${developButton}
        </div>`;
    
    // Show advisory message
    showAdvisory(`You can now develop ${getPropertyDisplayNameWithoutNumber(propertyInfo)}! Check the property panel for development options.`, 'info');
}

// Determine the best property for the AI to steal
function findBestStealTarget(ai) {
    console.log(`[findBestStealTarget] Checking steal targets for ${ai.name}`);
    let bestSquare = null;
    let bestScore = -Infinity;

    players.forEach(p => {
        if (p.name === ai.name || p.bankrupt) return;
        console.log(`[findBestStealTarget] Checking player ${p.name}, properties:`, p.properties);
        (p.properties || []).forEach(square => {
            const info = getPropertyInfo(square);
            if (!info) {
                console.log(`[findBestStealTarget] No info found for square ${square}`);
                return;
            }

            const group = info.group;
            const groupPositions = propertyGroups[group]?.positions || [];
            const aiOwnedInGroup = ai.properties.filter(prop => {
                const inf = getPropertyInfo(prop);
                return inf && inf.group === group;
            }).length;

            const groupSize = groupPositions.length || 0;
            let score = info.cost || 0;

            if (aiOwnedInGroup === groupSize - 1) score += 1000; // Completing a set
            score += aiOwnedInGroup * 100; // Preference for groups we own

            if (info.state.hasCrypt) score += 400;
            if (info.state.graveyards) score += info.state.graveyards * 100;

            console.log(`[findBestStealTarget] Property ${square}: score=${score}, cost=${info.cost}, aiOwnedInGroup=${aiOwnedInGroup}/${groupSize}`);

            if (score > bestScore) {
                bestScore = score;
                bestSquare = square;
                console.log(`[findBestStealTarget] New best target: ${square} with score ${score}`);
            }
        });
    });

    console.log(`[findBestStealTarget] Final result: ${bestSquare} with score ${bestScore}`);
    return bestSquare;
}

// AI uses a steal card on the most valuable target
async function aiUseStealCard(ai) {
    console.log(`[aiUseStealCard] Called for ${ai.name}, steal cards: ${ai.stealCards}`);
    
    if (ai.stealCards <= 0) {
        console.log(`[aiUseStealCard] ${ai.name} has no steal cards`);
        return false;
    }

    const targetSquare = findBestStealTarget(ai);
    if (!targetSquare) {
        console.log(`[aiUseStealCard] No suitable steal target found for ${ai.name}`);
        return false;
    }

    const propertyInfo = getPropertyInfo(targetSquare);
    if (!propertyInfo || !propertyInfo.state.owner) {
        console.log(`[aiUseStealCard] Property info or owner missing for ${targetSquare}`);
        return false;
    }

    const previousOwner = players.find(p => p.name.toLowerCase() === (propertyInfo.state.owner || '').toLowerCase());
    if (!previousOwner) {
        console.log(`[aiUseStealCard] Previous owner not found: ${propertyInfo.state.owner}`);
        return false;
    }

    console.log(`[aiUseStealCard] ${ai.name} stealing ${targetSquare} from ${previousOwner.name}`);

    // Execute the steal
    previousOwner.properties = previousOwner.properties.filter(p => p !== targetSquare);
    ai.properties.push(targetSquare);

    propertyInfo.state.owner = ai.name;
    propertyInfo.state.ownerColor = ai.color || getPlayerColor(ai.name);

    ai.stealCards--;

    const propertyDisplayName = getPropertyDisplayNameWithoutNumber(propertyInfo);
    showAdvisory(`${ai.name} used a STEAL CARD to steal ${propertyDisplayName} from ${previousOwner.name}!`, 'turn');
    
    // Play appropriate sound effect for the steal
    if (propertyInfo.state.hasCrypt) {
        await playStealCryptSound();
    } else {
        await playStealSound();
    }

    updateInfoPanel();
    startStolenPropertyPulse(targetSquare);
    updateGameFrame();
    
    // Check if AI can now develop properties after stealing (for logging purposes)
    checkAIDevelopmentOptionsAfterSteal(ai, targetSquare);

    if (isMultiplayerGame) {
        const aiIndex = players.findIndex(p => p.name.toLowerCase() === ai.name.toLowerCase());
        const prevIndex = players.findIndex(p => p.name.toLowerCase() === previousOwner.name.toLowerCase());

        if (aiIndex !== -1) {
            updatePlayerData(aiIndex, {
                properties: ai.properties,
                stealCards: ai.stealCards
            }).catch(error => console.error('Error updating AI steal data:', error));
        }

        if (prevIndex !== -1) {
            updatePlayerData(prevIndex, {
                properties: previousOwner.properties
            }).catch(error => console.error('Error updating stolen player data:', error));
        }

        updatePropertyState(targetSquare, propertyInfo.state).catch(error =>
            console.error('Error updating property state:', error));
    }

    console.log(`[aiUseStealCard] Successfully stole ${targetSquare} for ${ai.name}`);
    return true;
}

// Check if AI can develop properties after stealing (for logging and future AI development logic)
function checkAIDevelopmentOptionsAfterSteal(ai, stolenProperty) {
    console.log(`[checkAIDevelopmentOptionsAfterSteal] Checking development options for AI ${ai.name} after stealing ${stolenProperty}`);
    
    const stolenPropertyInfo = getPropertyInfo(stolenProperty);
    if (!stolenPropertyInfo) {
        console.log(`[checkAIDevelopmentOptionsAfterSteal] No property info found for ${stolenProperty}`);
        return;
    }
    
    // Check if the AI can now develop the stolen property
    if (canDevelopProperty(ai, stolenProperty)) {
        const devInfo = getDevelopmentCost(stolenProperty);
        if (devInfo && ai.money >= devInfo.cost) {
            console.log(`ðŸ—ï¸ [checkAIDevelopmentOptionsAfterSteal] AI ${ai.name} can now develop ${stolenProperty}! (${devInfo.type} for Â£${devInfo.cost})`);
        }
    }
    
    // Check if stealing completed a group and allows development of other properties
    const group = stolenPropertyInfo.group;
    const groupPositions = propertyGroups[group]?.positions || [];
    
    for (const propertySquare of groupPositions) {
        const propState = propertyState[propertySquare];
        if (propState && propState.owner === ai.name && propertySquare !== stolenProperty) {
            if (canDevelopProperty(ai, propertySquare)) {
                const devInfo = getDevelopmentCost(propertySquare);
                if (devInfo && ai.money >= devInfo.cost) {
                    console.log(`ðŸ—ï¸ [checkAIDevelopmentOptionsAfterSteal] AI ${ai.name} can now develop ${propertySquare} in the ${group} group! (${devInfo.type} for Â£${devInfo.cost})`);
                }
            }
        }
    }
}

// Test function to debug AI steal card usage
function testAIStealCards() {
    console.log('=== TESTING AI STEAL CARD SYSTEM ===');
    
    if (!players || players.length === 0) {
        console.error('No players found. Start a game first.');
        return;
    }
    
    // Find an AI player
    const aiPlayer = players.find(p => p.isAI);
    if (!aiPlayer) {
        console.error('No AI player found');
        return;
    }
    
    console.log(`Testing with AI: ${aiPlayer.name}`);
    console.log(`AI current steal cards: ${aiPlayer.stealCards || 0}`);
    console.log(`AI current properties:`, aiPlayer.properties);
    
    // Give AI some steal cards for testing
    aiPlayer.stealCards = (aiPlayer.stealCards || 0) + 2;
    console.log(`Gave AI 2 steal cards, total: ${aiPlayer.stealCards}`);
    
    // Show all players' properties for context
    players.forEach((p, i) => {
        console.log(`Player ${i}: ${p.name} (AI: ${p.isAI}) - Properties:`, p.properties);
    });
    
    // Test the steal target finding
    console.log('\n--- Testing findBestStealTarget ---');
    const bestTarget = findBestStealTarget(aiPlayer);
    console.log(`Best steal target for ${aiPlayer.name}: ${bestTarget}`);
    
    // Test the actual steal
    if (bestTarget) {
        console.log('\n--- Testing aiUseStealCard ---');
        aiUseStealCard(aiPlayer).then(result => {
            console.log(`Steal card usage result: ${result}`);
            console.log(`AI steal cards after use: ${aiPlayer.stealCards}`);
            console.log(`AI properties after steal:`, aiPlayer.properties);
            updateInfoPanel();
            updateGameFrame();
        });
    } else {
        console.log('No target found, cannot test steal execution');
    }
    
    console.log('\n=== AI STEAL CARD TEST COMPLETED ===');
}

// Make test function available globally
window.testAIStealCards = testAIStealCards;

// Debug function to test double-tap detection
function testDoubleTapDetection() {
    console.log('=== DOUBLE-TAP DETECTION TEST ===');
    console.log(`isMobile: ${isMobile}`);
    console.log(`DOUBLE_CLICK_THRESHOLD: ${DOUBLE_CLICK_THRESHOLD}ms`);
    console.log(`CLICK_POSITION_THRESHOLD: ${CLICK_POSITION_THRESHOLD}px`);
    
    const canvas = document.querySelector('canvas');
    if (canvas) {
        const rect = canvas.getBoundingClientRect();
        console.log(`Canvas size: ${canvas.width}x${canvas.height}`);
        console.log(`Canvas display size: ${rect.width}x${rect.height}`);
        console.log(`Device pixel ratio: ${window.devicePixelRatio || 1}`);
        console.log(`Scale factors: X=${canvas.width / rect.width}, Y=${canvas.height / rect.height}`);
    }
    
    // Check current player steal cards
    const currentPlayer = players[currentPlayerIndex];
    if (currentPlayer) {
        console.log(`Current player: ${currentPlayer.name}`);
        console.log(`Steal cards: ${currentPlayer.stealCards}`);
        console.log(`Is AI: ${currentPlayer.isAI}`);
    }
    
    // Show available stealable properties
    const stealableProperties = [];
    if (positionsMap && positionsMap.size > 0) {
        for (const [square, position] of positionsMap.entries()) {
            const propertyInfo = getPropertyInfo(square);
            if (propertyInfo && propertyInfo.state.owner && propertyInfo.state.owner !== currentPlayer?.name) {
                stealableProperties.push({
                    square,
                    name: getPropertyDisplayNameWithoutNumber(propertyInfo),
                    owner: propertyInfo.state.owner,
                    position: `(${Math.round(position.x)}, ${Math.round(position.y)})`
                });
            }
        }
        console.log(`Stealable properties (${stealableProperties.length}):`, stealableProperties);
    } else {
        console.log('âš ï¸ positionsMap not available');
    }
    
    showAdvisory('Double-tap detection test completed. Check console for details.', 'info');
    console.log('=== END TEST ===');
}

// Make debug function available globally
window.testDoubleTapDetection = testDoubleTapDetection;

// Yingyang Quote System
const yingyangQuotes = [
    // Positive quotes
    "The only way to do great work is to love what you do. - Steve Jobs",
    "Believe you can and you're halfway there. - Theodore Roosevelt",
    "Success is not final, failure is not fatal: it is the courage to continue that counts. - Winston Churchill",
    "The future belongs to those who believe in the beauty of their dreams. - Eleanor Roosevelt",
    "It is during our darkest moments that we must focus to see the light. - Aristotle",
    "The only impossible journey is the one you never begin. - Tony Robbins",
    "In the middle of difficulty lies opportunity. - Albert Einstein",
    "Life is what happens to you while you're busy making other plans. - John Lennon",
    "The way to get started is to quit talking and begin doing. - Walt Disney",
    "Don't let yesterday take up too much of today. - Will Rogers",
    "You learn more from failure than from success. Don't let it stop you. Failure builds character. - Unknown",
    "If you are working on something that you really care about, you don't have to be pushed. The vision pulls you. - Steve Jobs",
    "Experience is a hard teacher because she gives the test first, the lesson afterward. - Vernon Law",
    "To live is the rarest thing in the world. Most people just exist. - Oscar Wilde",
    "Innovation distinguishes between a leader and a follower. - Steve Jobs",
    
    // Negative quotes
    "The road to hell is paved with good intentions. - Unknown",
    "Hell is other people. - Jean-Paul Sartre",
    "Man is condemned to be free; because once thrown into the world, he is responsible for everything he does. - Jean-Paul Sartre",
    "The only thing we have to fear is fear itself. - Franklin D. Roosevelt",
    "I have not failed. I've just found 10,000 ways that won't work. - Thomas Edison",
    "The greatest enemy of knowledge is not ignorance, it is the illusion of knowledge. - Stephen Hawking",
    "We are all in the gutter, but some of us are looking at the stars. - Oscar Wilde",
    "The truth will set you free, but first it will piss you off. - Gloria Steinem",
    "Reality is that which, when you stop believing in it, doesn't go away. - Philip K. Dick",
    "The most terrifying fact about the universe is not that it is hostile but that it is indifferent. - Stanley Kubrick",
    "We live in a world where we have to hide to make love, while violence is practiced in broad daylight. - John Lennon",
    "The only true wisdom is in knowing you know nothing. - Socrates",
    "Life is a tragedy when seen in close-up, but a comedy in long-shot. - Charlie Chaplin",
    "Everyone you meet is fighting a battle you know nothing about. Be kind. Always. - Unknown",
    "The problem with the world is that the intelligent people are full of doubts, while the stupid ones are full of confidence. - Charles Bukowski"
];

// Function to analyze if a quote is positive or negative
function analyzeQuotePositivity(quote) {
    const positiveWords = [
        'love', 'believe', 'success', 'great', 'beautiful', 'light', 'opportunity', 'dreams', 'courage', 
        'hope', 'joy', 'happiness', 'wonderful', 'amazing', 'brilliant', 'excellent', 'fantastic', 
        'good', 'better', 'best', 'perfect', 'awesome', 'inspire', 'motivation', 'achieve', 'win',
        'victory', 'triumph', 'blessed', 'grateful', 'lucky', 'fortune', 'prosperity', 'wealth',
        'peace', 'harmony', 'balance', 'wisdom', 'knowledge', 'learn', 'grow', 'progress'
    ];
    
    const negativeWords = [
        'hell', 'fear', 'failure', 'failed', 'enemy', 'ignorance', 'gutter', 'piss', 'terrifying', 
        'hostile', 'tragedy', 'battle', 'problem', 'stupid', 'doubt', 'dark', 'death', 'pain',
        'suffering', 'hate', 'anger', 'sad', 'depression', 'anxiety', 'worry', 'stress', 'difficult',
        'hard', 'impossible', 'never', 'nothing', 'nobody', 'alone', 'lost', 'broken', 'destroy',
        'ruin', 'disaster', 'terrible', 'awful', 'horrible', 'worst', 'bad', 'evil', 'wrong'
    ];
    
    const quoteLower = quote.toLowerCase();
    let positiveScore = 0;
    let negativeScore = 0;
    
    positiveWords.forEach(word => {
        if (quoteLower.includes(word)) {
            positiveScore++;
        }
    });
    
    negativeWords.forEach(word => {
        if (quoteLower.includes(word)) {
            negativeScore++;
        }
    });
    
    // If scores are equal or both zero, check quote structure and common patterns
    if (positiveScore === negativeScore) {
        // Additional heuristics for ambiguous cases
        if (quoteLower.includes('not ') || quoteLower.includes("don't") || quoteLower.includes("can't")) {
            negativeScore += 0.5;
        }
        if (quoteLower.includes('will ') || quoteLower.includes('can ') || quoteLower.includes('believe')) {
            positiveScore += 0.5;
        }
    }
    
    return positiveScore > negativeScore;
}

// Function to handle yingyang landing
async function handleYingyangLanding(player) {
    console.log(`[handleYingyangLanding] *** STARTING *** ${player.name} landed on yingyang square`);
    
    // Show "YANG!" flash message
    showYangFlash();
    
    // Get random quote
    const randomIndex = Math.floor(Math.random() * yingyangQuotes.length);
    const selectedQuote = yingyangQuotes[randomIndex];
    
    // Analyze if quote is positive or negative
    const isPositive = analyzeQuotePositivity(selectedQuote);
    
    // Generate random amount between 1 and 900
    const amount = Math.floor(Math.random() * 900) + 1; // 1-900 range
    
    // Award or deduct money
    if (isPositive) {
        player.money += amount;
        console.log(`[handleYingyangLanding] ${player.name} received Â£${amount} for positive quote`);
    } else {
        player.money -= amount;
        if (player.money < 0) {
            player.money = 0;
            player.bankrupt = true;
        }
        console.log(`[handleYingyangLanding] ${player.name} lost Â£${amount} for negative quote`);
    }
    
    // Check bankruptcy after money change
    checkBankruptcy(player);
    
    // Check for steal card (1 in 7 chance, approximately 14.3%)
    const stealCardChance = Math.random();
    let stealCardMessage = '';
    const stealCardThreshold = 1/7; // 1 in 7 chance (approximately 0.143)
    if (stealCardChance < stealCardThreshold) {
        player.stealCards = (player.stealCards || 0) + 1;
        
        // Play steal award sound
        playStealAwardSound();
        
        console.log(`[handleYingyangLanding] ${player.name} earned a steal card from yingyang! (${stealCardChance.toFixed(3)} < ${stealCardThreshold.toFixed(3)})`);
        stealCardMessage = `
            <div style="background: rgba(255, 215, 0, 0.2); padding: 10px; border-radius: 6px; border: 2px solid #ffd700; margin: 5px 0;">
                <div style="font-family: 'Courier New', monospace; font-size: 14px; font-weight: bold; color: #ffd700; text-align: center;">
                    âœ¨ BONUS: Steal Card Earned! âœ¨
                </div>
                <div style="font-size: 12px; color: #cccccc; text-align: center; margin-top: 5px;">
                    Total steal cards: ${player.stealCards}
                </div>
            </div>
        `;
    } else {
        console.log(`[handleYingyangLanding] ${player.name} did not earn a steal card from yingyang (${stealCardChance.toFixed(3)} >= ${stealCardThreshold.toFixed(3)})`);
    }
    
    // Create quote display message
    const quoteType = isPositive ? 'POSITIVE' : 'NEGATIVE';
    const moneyChange = isPositive ? `+Â£${amount}` : `-Â£${amount}`;
    const quoteColor = isPositive ? '#00ff00' : '#ff0000';
    const bgColor = isPositive ? 'rgba(0, 255, 0, 0.1)' : 'rgba(255, 0, 0, 0.1)';
    
    const quoteMessage = `
        <div style="background: ${bgColor}; padding: 15px; border-radius: 8px; border: 2px solid ${quoteColor}; margin: 10px 0;">
            <div style="font-family: 'Courier New', 'Lucida Console', 'Monaco', 'Consolas', monospace; font-size: 16px; font-weight: bold; color: ${quoteColor}; text-align: center; margin-bottom: 10px;">
                ðŸ”® YINGYANG WISDOM ðŸ”®
            </div>
            <div style="font-family: 'Times New Roman', serif; font-size: 14px; font-style: italic; text-align: center; margin: 15px 0; line-height: 1.4; color: #ffffff;">
                "${selectedQuote}"
            </div>
            <div style="font-family: 'Courier New', 'Lucida Console', 'Monaco', 'Consolas', monospace; font-size: 14px; font-weight: bold; color: ${quoteColor}; text-align: center; margin-top: 15px;">
                ${quoteType} QUOTE: ${moneyChange}
            </div>
            <div style="font-size: 12px; color: #cccccc; text-align: center; margin-top: 8px;">
                ${player.name}'s new balance: Â£${player.money}
            </div>
            ${stealCardMessage}
        </div>
    `;
    
    // Show the quote for 10 seconds
    showAdvisory(quoteMessage, 'yingyang');
    
    // Play appropriate sound
    if (isPositive) {
        await playBellSound();
    } else {
        await playPigSound();
    }
    
    // Update game display
    await updateGameFrame();
    updateInfoPanel();
    
    // Sync to Firebase if in multiplayer mode
    if (isMultiplayerGame) {
        await syncGameStateToFirebase();
    }
    
    console.log(`[handleYingyangLanding] Showing quote message in advisory panel`);
    console.log(`[handleYingyangLanding] Quote: "${selectedQuote}"`);
    console.log(`[handleYingyangLanding] Analysis: ${quoteType}, Amount: ${moneyChange}`);
    console.log(`[handleYingyangLanding] Quote displayed for ${player.name}: "${selectedQuote}" (${quoteType}, ${moneyChange})`);
}

// Test function to manually trigger yingyang quote (for debugging)
function testYingyangQuote() {
    console.log('Testing yingyang quote system...');
    const currentPlayer = players[currentPlayerIndex];
    if (currentPlayer) {
        console.log(`Testing quote for player: ${currentPlayer.name}`);
        handleYingyangLanding(currentPlayer);
    } else {
        console.error('No current player found for testing');
    }
}

// Make test function available globally for console testing
window.testYingyangQuote = testYingyangQuote;

// Test function to move current player to yingyang square (for debugging)
function moveToYingyang() {
    console.log('Moving current player to yingyang square...');
    const currentPlayer = players[currentPlayerIndex];
    if (currentPlayer) {
        const yingyangPos = positionsMap.get('yingyang');
        const yingyangIndex = gamePath.indexOf('yingyang');
        
        if (yingyangPos && yingyangIndex !== -1) {
            currentPlayer.currentSquare = 'yingyang';
            currentPlayer.currentPathKey = 'gamePath';
            currentPlayer.currentIndexOnPath = yingyangIndex;
            currentPlayer.x = yingyangPos.x;
            currentPlayer.y = yingyangPos.y;
            
            console.log(`Moved ${currentPlayer.name} to yingyang at position (${yingyangPos.x}, ${yingyangPos.y})`);
            updateGameFrame();
            
            // Trigger the yingyang quote
            handleYingyangLanding(currentPlayer);
        } else {
            console.error('Yingyang position not found!', { yingyangPos, yingyangIndex });
        }
    } else {
        console.error('No current player found');
    }
}

// Test function to trigger hand effect from GO position (for debugging)
function testHandFromGo() {
    console.log('Testing hand effect from GO position...');
    
    // Get the GO position
    const goPos = positionsMap.get('go');
    if (!goPos) {
        console.error('GO position not found!');
        return;
    }
    
    console.log(`GO position found at (${goPos.x}, ${goPos.y})`);
    
    // Move current player to GO position first
    const currentPlayer = players[currentPlayerIndex];
    if (currentPlayer) {
        const goIndex = gamePath.indexOf('go');
        if (goIndex !== -1) {
            currentPlayer.currentSquare = 'go';
            currentPlayer.currentPathKey = 'gamePath';
            currentPlayer.currentIndexOnPath = goIndex;
            currentPlayer.x = goPos.x;
            currentPlayer.y = goPos.y;
            
            console.log(`Moved ${currentPlayer.name} to GO at position (${goPos.x}, ${goPos.y})`);
            updateGameFrame();
            
            // Wait a moment then trigger the hand effect
            setTimeout(() => {
                console.log('Triggering hand effect...');
                showHandEffect();
            }, 500);
        } else {
            console.error('GO position not found in game path');
        }
    } else {
        console.error('No current player found');
    }
}

// Test function to just trigger hand effect without moving player
function testHandEffectOnly() {
    console.log('Testing hand effect only (without moving player)...');
    showHandEffect();
}

// Test function to simulate AI landing on yingyang (for debugging)
function testAIYingyang() {
    console.log('Testing AI yingyang landing...');
    const currentPlayer = players[currentPlayerIndex];
    if (currentPlayer && currentPlayer.isAI) {
        console.log(`Moving AI ${currentPlayer.name} to yingyang and triggering landing...`);
        
        const yingyangPos = positionsMap.get('yingyang');
        const yingyangIndex = gamePath.indexOf('yingyang');
        
        if (yingyangPos && yingyangIndex !== -1) {
            currentPlayer.currentSquare = 'yingyang';
            currentPlayer.currentPathKey = 'gamePath';
            currentPlayer.currentIndexOnPath = yingyangIndex;
            currentPlayer.x = yingyangPos.x;
            currentPlayer.y = yingyangPos.y;
            
            console.log(`Moved AI ${currentPlayer.name} to yingyang at position (${yingyangPos.x}, ${yingyangPos.y})`);
            updateGameFrame();
            
            // Simulate the AI turn logic for yingyang
            console.log(`DEBUG: AI currentSquare is now: ${currentPlayer.currentSquare}`);
            console.log(`DEBUG: Checking if ${currentPlayer.currentSquare} === 'yingyang': ${currentPlayer.currentSquare === 'yingyang'}`);
            
            if (currentPlayer.currentSquare === 'yingyang') {
                console.log(`*** AI YINGYANG TEST *** Triggering handleYingyangLanding for AI ${currentPlayer.name}`);
                handleYingyangLanding(currentPlayer);
            } else {
                console.error('AI not properly positioned on yingyang square!');
            }
        } else {
            console.error('Yingyang position not found!', { yingyangPos, yingyangIndex });
        }
    } else {
        console.error('Current player is not an AI or no current player found');
        console.log('Available players:', players.map(p => ({ name: p.name, isAI: p.isAI })));
        console.log('Current player index:', currentPlayerIndex);
    }
}

// Test function for gojail glow
function testGojailGlow() {
    console.log('Testing gojail glow effect and witchlaugh sound...');
    
    if (gojailGlowActive) {
        console.log('Glow is currently active - deactivating...');
        deactivateGojailGlow();
    } else {
        console.log('Activating glow for 10 seconds (will play witchlaugh.mp3)...');
        activateGojailGlow();
        
        // Auto-deactivate after 10 seconds for testing
        setTimeout(() => {
            console.log('Test completed - deactivating glow');
            deactivateGojailGlow();
        }, 10000);
    }
}

// Test function to toggle glow on/off repeatedly
function testGojailGlowPulse() {
    console.log('Starting glow pulse test (will pulse 5 times)...');
    let pulseCount = 0;
    
    const pulseInterval = setInterval(() => {
        if (pulseCount >= 10) { // 5 on/off cycles = 10 pulses
            clearInterval(pulseInterval);
            deactivateGojailGlow();
            console.log('Glow pulse test completed');
            return;
        }
        
        if (gojailGlowActive) {
            deactivateGojailGlow();
            console.log(`Pulse ${Math.floor(pulseCount/2) + 1} - OFF`);
        } else {
            activateGojailGlow();
            console.log(`Pulse ${Math.floor(pulseCount/2) + 1} - ON`);
        }
        pulseCount++;
    }, 1500); // 1.5 second intervals
}

// Debug function to diagnose and fix stuck game states
function debugStuckState() {
    console.log('ðŸ” DEBUGGING STUCK GAME STATE:');
    
    const currentPlayer = players[currentPlayerIndex];
    const propertyInfo = getPropertyInfo(currentPlayer?.currentSquare);
    
    console.log('Current Player:', currentPlayer?.name);
    console.log('Current Square:', currentPlayer?.currentSquare);
    console.log('Property Info:', propertyInfo);
    console.log('Property Owner:', propertyInfo?.state?.owner);
    console.log('Is AI Turn:', isAITurn);
    console.log('Is Player Moving:', isPlayerMoving);
    console.log('Is Dice Roll In Progress:', isDiceRollInProgress);
    console.log('Is Dice Click Handler Running:', isDiceClickHandlerRunning);
    console.log('Last Roll Was Doubles:', lastRollWasDoubles);
    
    // Check declined properties
    if (playerDeclinedProperties.has(currentPlayer?.name)) {
        const declined = Array.from(playerDeclinedProperties.get(currentPlayer.name));
        const manual = declined.filter(p => !p.startsWith('auto_'));
        const auto = declined.filter(p => p.startsWith('auto_'));
        console.log('Manually Declined Properties:', manual);
        console.log('Auto-Declined Properties:', auto);
    } else {
        console.log('No Declined Properties for Current Player');
    }
    
    // Check for property decision buttons
    const purchaseButtons = document.querySelectorAll('.purchase-button, button[onclick*="handlePropertyPurchase"], button[onclick*="handleMinimizedPropertyPurchase"]');
    const declineButtons = document.querySelectorAll('.decline-button, button[onclick*="handleDeclinePurchase"], button[onclick*="handleMinimizedDeclinePurchase"]');
    const developButtons = document.querySelectorAll('.develop-button, button[onclick*="handlePropertyDevelopment"]');
    
    console.log('Purchase Buttons Found:', purchaseButtons.length);
    console.log('Decline Buttons Found:', declineButtons.length);
    console.log('Develop Buttons Found:', developButtons.length);
    
    // Check dice state
    const diceSection = document.getElementById('dice-section');
    console.log('Dice Section Exists:', !!diceSection);
    console.log('Dice Pointer Events:', diceSection?.style.pointerEvents);
    console.log('Dice Classes:', diceSection ? Array.from(diceSection.classList) : 'N/A');
    
    // Check if we're in a stuck state and try to recover
    const isStuck = !currentPlayer?.isAI && 
                   !isPlayerMoving && 
                   !isDiceRollInProgress && 
                   !isDiceClickHandlerRunning &&
                   purchaseButtons.length === 0 && 
                   declineButtons.length === 0 && 
                   developButtons.length === 0 &&
                   (!diceSection || diceSection.style.pointerEvents === 'none');
    
    if (isStuck) {
        console.log('ðŸš¨ STUCK STATE DETECTED - Attempting recovery...');
        
        // Reset all flags
        isPlayerMoving = false;
        isDiceRollInProgress = false;
        isDiceClickHandlerRunning = false;
        
        // If on unowned property, force property decision
        if (propertyInfo && !propertyInfo.state.owner && !propertyInfo.special) {
            console.log('ðŸ”§ Forcing property decision update...');
            updateInfoPanel(null, null, propertyInfo);
        } else {
            // Enable dice and continue turn
            console.log('ðŸ”§ Enabling dice section...');
            enableDiceSection();
        }
        
        console.log('âœ… Recovery attempt completed');
    } else {
        console.log('âœ… Game state appears normal');
    }
}

// Make test functions available globally for console testing
window.moveToYingyang = moveToYingyang;
window.testHandFromGo = testHandFromGo;
window.testHandEffectOnly = testHandEffectOnly;
window.testAIYingyang = testAIYingyang;
window.testGojailGlow = testGojailGlow;
window.testGojailGlowPulse = testGojailGlowPulse;
window.debugStuckState = debugStuckState;

// Shaking Graves System Functions
function startGojailGravesShakingSystem() {
    scheduleNextGojailGravesShake();
    console.log('Gojail graves shaking system started');
}

function scheduleNextGojailGravesShake() {
    // Clear any existing timeout
    if (gojailGravesShakeTimeout) {
        clearTimeout(gojailGravesShakeTimeout);
    }
    
    // Random time between 15-45 seconds for graves to shake
    const randomTime = Math.random() * 30000 + 15000; // 15-45 seconds
    nextGojailGravesShakeTime = Date.now() + randomTime;
    
    gojailGravesShakeTimeout = setTimeout(() => {
        activateGojailGravesShake();
    }, randomTime);
    
    console.log(`Next gojail graves shake scheduled in ${Math.round(randomTime / 1000)} seconds`);
}

function activateGojailGravesShake() {
    gojailGravesShaking = true;
    console.log('Graves at Go to Jail are now shaking!');
    
    // Shake for 3-5 seconds
    const shakeDuration = Math.random() * 2000 + 3000; // 3-5 seconds
    
    setTimeout(() => {
        deactivateGojailGravesShake();
    }, shakeDuration);
}

function deactivateGojailGravesShake() {
    gojailGravesShaking = false;
    console.log('Gojail graves shake deactivated');

    // Schedule the next shake
    scheduleNextGojailGravesShake();
}

// Lightning System Functions
function startLightningSystem() {
    scheduleLightningStrike();
    console.log('Lightning system started - strikes every 70 seconds');
}

function stopLightningSystem() {
    if (lightningTimer) {
        clearTimeout(lightningTimer);
        lightningTimer = null;
    }
    lightningActive = false;
    console.log('Lightning system stopped');
}

function resetLightningSystem() {
    // Stop any existing lightning system
    stopLightningSystem();
    
    // Reset all lightning variables to initial state
    lightningTimer = null;
    lightningActive = false;
    lightningInterval = 70000; // 70 seconds in milliseconds
    
    // Clear all existing scorch marks
    clearAllScorchMarks();
    
    console.log('Lightning system reset - ready to start fresh');
}



// Function to create a persistent scorch mark on a property
function createScorchMark(property) {
    const propertyPos = positionsMap?.get(property);
    if (!propertyPos) {
        console.error('Could not find position for scorch mark:', property);
        return;
    }
    
    // Remove any existing scorch mark for this property
    const existingScorch = document.getElementById(`scorch-mark-${property}`);
    if (existingScorch) {
        existingScorch.remove();
    }
    
    // Create scorch mark element
    const scorchMark = document.createElement('div');
    scorchMark.id = `scorch-mark-${property}`;
    scorchMark.className = 'scorch-mark';
    scorchMark.style.cssText = `
        position: absolute;
        left: ${propertyPos.x - 15}px;
        top: ${propertyPos.y - 15}px;
        width: 30px;
        height: 30px;
        background: radial-gradient(circle, rgba(0, 0, 0, 0.8) 0%, rgba(50, 50, 50, 0.6) 40%, rgba(100, 100, 100, 0.3) 70%, transparent 100%);
        border-radius: 50%;
        z-index: 500;
        pointer-events: none;
        opacity: 0;
        animation: scorchMarkAppear 0.5s ease-out forwards;
    `;
    
    // Add CSS animation for scorch mark if not already added
    if (!document.getElementById('scorch-mark-styles')) {
        const style = document.createElement('style');
        style.id = 'scorch-mark-styles';
        style.textContent = `
            @keyframes scorchMarkAppear {
                0% { 
                    opacity: 0; 
                    transform: scale(0.5);
                }
                50% { 
                    opacity: 0.9; 
                    transform: scale(1.2);
                }
                100% { 
                    opacity: 0.7; 
                    transform: scale(1);
                }
            }
            
            .scorch-mark {
                box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.5);
            }
        `;
        document.head.appendChild(style);
    }
    
    // Add scorch mark to game container
    const gameContainer = document.getElementById('game-container');
    if (gameContainer) {
        gameContainer.appendChild(scorchMark);
        console.log(`ðŸ”¥ Scorch mark created on ${property} at position (${propertyPos.x}, ${propertyPos.y})`);
    }
}

// Function to remove all scorch marks (for game reset)
function clearAllScorchMarks() {
    const scorchMarks = document.querySelectorAll('.scorch-mark');
    scorchMarks.forEach(mark => mark.remove());
    console.log('ðŸ”¥ All scorch marks cleared');
}

function scheduleLightningStrike() {
    // Clear any existing timeout
    if (lightningTimer) {
        clearTimeout(lightningTimer);
    }
    
    lightningTimer = setTimeout(() => {
        triggerLightningStrike();
    }, lightningInterval);
    
    console.log(`Next lightning strike scheduled in ${lightningInterval / 1000} seconds`);
}

async function triggerLightningStrike() {
    if (lightningActive || !isGameInitialized || isGameOver) {
        // Skip if lightning already active, game not started, or game over
        scheduleLightningStrike(); // Reschedule for next strike
        return;
    }
    // Multiplayer host gating: only the host selects and broadcasts the strike
    if (isMultiplayerGame) {
        try {
            const hostName = getLightningHostName();
            const localName = (window.localPlayerName || document.getElementById('player1-name')?.value || '').trim();
            const isHostClient = !!(hostName && localName && hostName.toLowerCase() === localName.toLowerCase());
            if (!isHostClient) {
                console.log('âš¡ Lightning strike selection delegated to host. Waiting for broadcast...');
                scheduleLightningStrike();
                return;
            }
        } catch (e) {
            console.warn('âš¡ Host gating check failed; deferring to next schedule on this client:', e?.message || e);
            scheduleLightningStrike();
            return;
        }
    }
    
    // CRITICAL: Validate game state before lightning strike in multiplayer
    if (isMultiplayerGame) {
        // Check for corrupted player data
        if (!Array.isArray(players) || players.length === 0) {
            console.error('âš¡ Lightning strike aborted: Invalid players array:', players);
            scheduleLightningStrike();
            return;
        }
        
        // Check for corrupted property state
        if (!propertyState || typeof propertyState !== 'object') {
            console.error('âš¡ Lightning strike aborted: Invalid property state:', propertyState);
            scheduleLightningStrike();
            return;
        }
        
        // Validate players have proper structure
        const hasValidPlayers = players.some(p => p && p.name && p.name !== 'undefined');
        if (!hasValidPlayers) {
            console.error('âš¡ Lightning strike aborted: No valid players found');
            scheduleLightningStrike();
            return;
        }
    }
    
    lightningActive = true;
    console.log('âš¡ Lightning strike triggered!');
    
    // Get all property positions that can be struck
    const propertyPositions = [];
    for (const group of Object.values(propertyGroups)) {
        propertyPositions.push(...group.positions);
    }
    
    // Select random property position
    const randomProperty = propertyPositions[Math.floor(Math.random() * propertyPositions.length)];
    const propertyPos = positionsMap?.get(randomProperty);
    
    if (!propertyPos) {
        console.error('Could not find position for lightning strike property:', randomProperty);
        lightningActive = false;
        scheduleLightningStrike();
        return;
    }
    
    console.log(`âš¡ Lightning strikes ${randomProperty} at position (${propertyPos.x}, ${propertyPos.y})`);
    // Broadcast strike to all clients immediately in multiplayer
    if (isMultiplayerGame) {
        try {
            const broadcast = {
                lightning: {
                    currentProperty: randomProperty,
                    strikeTimestamp: Date.now(),
                    seed: Math.floor(Math.random() * 1e9) // not used now, reserved
                },
                lastUpdated: new Date().toISOString()
            };
            await updateGameState(broadcast);
        } catch (e) {
            console.warn('âš¡ Lightning broadcast failed (continuing locally):', e?.message || e);
        }
    }
    
    // Create lightning visual effect
    createLightningEffect(propertyPos.x, propertyPos.y);
    
    // Create persistent scorch mark on the property
    createScorchMark(randomProperty);
    
    // If property is owned at the moment of strike, add a red glow pulse for 2s
    try {
        const propertyDataAtStrike = propertyState[randomProperty];
        if (propertyDataAtStrike && propertyDataAtStrike.owner) {
            createOwnedPropertyRedGlow(randomProperty);
        }
    } catch (e) {
        console.warn('Failed to apply owned-property red glow:', e);
    }

    // Play lightning sound (strike sound)
    playStrikeSound();
    
    // Check if any players are on this property
    const playersOnProperty = players.filter(player => 
        !player.bankrupt && player.currentSquare === randomProperty
    );
    
    if (playersOnProperty.length > 0) {
        console.log(`âš¡ ${playersOnProperty.length} player(s) struck by lightning on ${randomProperty}!`);
        
        // Apply penalty to each player on the property
        for (const player of playersOnProperty) {
            await applyLightningPenalty(player, randomProperty);
        }
    } else {
        console.log(`âš¡ Lightning strikes ${randomProperty} but no players are there`);
        
        // Get proper property display name
        const propertyInfo = getPropertyInfo(randomProperty);
        const displayName = propertyInfo ? getPropertyDisplayNameWithoutNumber(propertyInfo) : 'Unknown Location';
        
        // Still apply property effects even if no players are on the property
        const propertyEffectMessage = await applyLightningPropertyEffects(randomProperty);
        
        // Check if property is unowned
        const propertyData = propertyState[randomProperty];
        const isUnowned = !propertyData || !propertyData.owner;
        
        let message;
        if (isUnowned) {
            // Simple message for unowned properties
            message = `Lightning Strikes ${displayName}`;
            showAdvisory(message, 'warning');
        } else {
            // More detailed message for owned properties
            message = `âš¡ Lightning strikes ${displayName}! Luckily no players were there.`;
            if (propertyEffectMessage) {
                message += ` However, ${propertyEffectMessage}`;
            }
            // Use dedicated lightning advisory with 10s duration
            showAdvisory(message, 'lightning');
        }
        
        // Pause longer for lightning strikes on owned properties to let players read property damage info
        const pauseDuration = isUnowned ? 1500 : 3000; // Keep engine pacing; advisory itself stays 10s
        await new Promise(resolve => setTimeout(resolve, pauseDuration));
    }
    
    // Schedule next lightning strike
    setTimeout(() => {
        lightningActive = false;
        scheduleLightningStrike();
    }, 3000); // 3 second delay before next strike can be scheduled
}

function createLightningEffect(x, y) {
    // Create screen flicker effect first
    createScreenFlicker();
    
    // Create large lightning bolt element
    const lightning = document.createElement('div');
    lightning.className = 'lightning-bolt';
    lightning.style.cssText = `
        position: absolute;
        left: ${x - 25}px;
        top: ${y - 100}px;
        width: 50px;
        height: 100px;
        background: linear-gradient(45deg, #ffffff, #87ceeb, #ffffff, #ffff00);
        box-shadow: 0 0 30px #87ceeb, 0 0 60px #ffffff, 0 0 90px #ffff00, inset 0 0 20px #ffffff;
        clip-path: polygon(20% 0%, 40% 20%, 30% 35%, 60% 35%, 35% 60%, 45% 80%, 25% 65%, 50% 65%, 30% 100%, 10% 80%, 25% 60%, 0% 60%, 20% 40%, 10% 25%, 20% 0%);
        z-index: 2000;
        animation: lightning-flash 1s ease-in-out;
        pointer-events: none;
        border: 3px solid #ffffff;
        border-radius: 5px;
    `;
    
    // Create property highlight circle
    const highlight = document.createElement('div');
    highlight.className = 'property-highlight';
    highlight.style.cssText = `
        position: absolute;
        left: ${x - 40}px;
        top: ${y - 40}px;
        width: 80px;
        height: 80px;
        background: radial-gradient(circle, rgba(255,255,0,0.8), rgba(135,206,235,0.6), transparent);
        border: 4px solid #ffff00;
        border-radius: 50%;
        z-index: 1999;
        animation: property-pulse 1s ease-in-out;
        pointer-events: none;
        box-shadow: 0 0 40px #ffff00, inset 0 0 20px rgba(255,255,255,0.5);
    `;
    
    // Add CSS animations if not already present
    if (!document.getElementById('lightning-styles')) {
        const style = document.createElement('style');
        style.id = 'lightning-styles';
        style.textContent = `
            @keyframes lightning-flash {
                0% { opacity: 0; transform: scale(0.3) rotate(-5deg); }
                15% { opacity: 1; transform: scale(1.3) rotate(2deg); }
                30% { opacity: 0.7; transform: scale(1.1) rotate(-1deg); }
                45% { opacity: 1; transform: scale(1.2) rotate(1deg); }
                60% { opacity: 0.8; transform: scale(1) rotate(0deg); }
                75% { opacity: 1; transform: scale(1.1) rotate(-1deg); }
                90% { opacity: 0.6; transform: scale(0.9) rotate(1deg); }
                100% { opacity: 0; transform: scale(0.5) rotate(0deg); }
            }
            
            @keyframes property-pulse {
                0% { opacity: 0; transform: scale(0.5); }
                20% { opacity: 1; transform: scale(1.2); }
                40% { opacity: 0.8; transform: scale(1); }
                60% { opacity: 1; transform: scale(1.1); }
                80% { opacity: 0.6; transform: scale(0.95); }
                100% { opacity: 0; transform: scale(0.8); }
            }
            
            @keyframes screen-flicker {
                0% { opacity: 0; }
                10% { opacity: 0.8; }
                20% { opacity: 0; }
                30% { opacity: 1; }
                40% { opacity: 0; }
                50% { opacity: 0.9; }
                100% { opacity: 0; }
            }
            
            .lightning-bolt {
                filter: brightness(3) contrast(2) saturate(1.5);
                text-shadow: 0 0 10px #ffffff;
            }
            
            .screen-flicker {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(255, 255, 255, 0.9);
                z-index: 10000;
                animation: screen-flicker 0.5s ease-in-out;
                pointer-events: none;
            }
        `;
        document.head.appendChild(style);
    }
    
    // Add to game container
    const gameContainer = document.getElementById('game-container') || document.body;
    gameContainer.appendChild(highlight);
    gameContainer.appendChild(lightning);
    
    // Remove lightning effect after animation
    setTimeout(() => {
        if (lightning.parentNode) {
            lightning.parentNode.removeChild(lightning);
        }
        if (highlight.parentNode) {
            highlight.parentNode.removeChild(highlight);
        }
    }, 1000);
    
    // Create flash effect on the property with larger text
    showFlashMessage('âš¡ LIGHTNING STRIKE! âš¡', '#ffff00', 'lightningFlash');
}

// Create a red glow pulse on a struck property if it's owned (2 seconds)
function createOwnedPropertyRedGlow(property) {
    const propertyData = propertyState[property];
    if (!propertyData || !propertyData.owner) {
        return;
    }
    const propertyPos = positionsMap?.get(property);
    if (!propertyPos) {
        return;
    }

    // Inject styles for the red glow pulse if not present
    if (!document.getElementById('property-red-glow-styles')) {
        const style = document.createElement('style');
        style.id = 'property-red-glow-styles';
        style.textContent = `
            @keyframes owned-property-red-pulse {
                0% { transform: scale(0.9); opacity: 0.5; box-shadow: 0 0 10px rgba(255,0,0,0.4), inset 0 0 10px rgba(255,0,0,0.3); }
                50% { transform: scale(1.1); opacity: 1; box-shadow: 0 0 40px rgba(255,0,0,0.8), inset 0 0 20px rgba(255,0,0,0.6); }
                100% { transform: scale(0.95); opacity: 0.4; box-shadow: 0 0 5px rgba(255,0,0,0.3), inset 0 0 5px rgba(255,0,0,0.2); }
            }
        `;
        document.head.appendChild(style);
    }

    const glow = document.createElement('div');
    glow.className = 'owned-property-red-glow';
    glow.style.cssText = `
        position: absolute;
        left: ${propertyPos.x - 45}px;
        top: ${propertyPos.y - 45}px;
        width: 90px;
        height: 90px;
        border-radius: 50%;
        pointer-events: none;
        z-index: 1998;
        background: radial-gradient(circle, rgba(255,0,0,0.35) 0%, rgba(255,0,0,0.25) 45%, rgba(255,0,0,0) 70%);
        box-shadow: 0 0 30px rgba(255,0,0,0.6), inset 0 0 20px rgba(255,0,0,0.4);
        /* 7 seconds total: 1s pulse, 7 iterations (continuous pulse look) */
        animation: owned-property-red-pulse 1s ease-in-out 7;
    `;

    const gameContainer = document.getElementById('game-container') || document.body;
    gameContainer.appendChild(glow);

    setTimeout(() => {
        if (glow.parentNode) {
            glow.parentNode.removeChild(glow);
        }
    }, 7000);
}

function createScreenFlicker() {
    // Create screen flicker overlay
    const flicker = document.createElement('div');
    flicker.className = 'screen-flicker';
    
    // Add to body (covers entire screen)
    document.body.appendChild(flicker);
    
    // Remove flicker after animation
    setTimeout(() => {
        if (flicker.parentNode) {
            flicker.parentNode.removeChild(flicker);
        }
    }, 500);
}

async function applyLightningPenalty(player, property) {
    console.log(`âš¡ Applying lightning penalty to ${player.name} on ${property}`);
    
    // Get proper property display name
    const propertyInfo = getPropertyInfo(property);
    const displayName = propertyInfo ? getPropertyDisplayName(propertyInfo) : 'Unknown Location';
    
    // Deduct 1000 money
    const penaltyAmount = 1000;
    player.money -= penaltyAmount;
    
    // Ensure money doesn't go below 0
    if (player.money < 0) {
        player.money = 0;
    }
    
    // Set jail status
    player.inJail = true;
    player.jailTurns = 0;
    
    // Send player to jail (using existing function)
    await sendPlayerToJail(player);
    
    // Apply property effects from lightning strike
    const propertyEffectMessage = await applyLightningPropertyEffects(property);
    
    // Show penalty message including property effects
    let message = `âš¡ ${player.name} struck by lightning on ${displayName}! Lost Â£${penaltyAmount} and sent to jail!`;
    if (propertyEffectMessage) {
        message += ` ${propertyEffectMessage}`;
    }
    // Use dedicated lightning advisory: keep visible for 10 seconds
    showAdvisory(message, 'lightning');
    
    // Pause longer for lightning strikes on owned properties to let players read property damage info
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    // Play jail sound
    playJailSound();
    
    // Check for bankruptcy after penalty
    checkBankruptcy(player);
    
    // Update Firebase state for multiplayer games
    if (isMultiplayerGame && currentRoomId) {
        updatePlayerData(player.name, {
            money: player.money,
            inJail: player.inJail,
            jailTurns: player.jailTurns,
            currentSquare: player.currentSquare,
            x: player.x,
            y: player.y,
            position: player.position,
            currentIndexOnPath: player.currentIndexOnPath
        });
    }
    
    console.log(`âš¡ ${player.name} penalized: -Â£${penaltyAmount}, sent to jail. New balance: Â£${player.money}`);
}

// Helper function to find which group a property belongs to
function findPropertyGroup(property) {
    for (const [groupName, groupInfo] of Object.entries(propertyGroups)) {
        if (groupInfo.positions.includes(property)) {
            return groupName;
        }
    }
    return 'unknown'; // Fallback if property not found in any group
}

// Apply lightning strike effects to property development and ownership
async function applyLightningPropertyEffects(property) {
    // CRITICAL: Validate and recover corrupted property data
    let propertyData = propertyState[property];
    
    if (!propertyData) {
        console.log(`âš¡ Property ${property} not found in propertyState`);
        return null;
    }
    
    // Recovery mechanism for corrupted property data
    if (typeof propertyData !== 'object' || propertyData === null) {
        console.error(`âš¡ Corrupted property data detected for ${property}, attempting recovery...`);
        
        // Try to recover from a basic property structure
        propertyData = {
            owner: null,
            ownerColor: null,
            graveyards: 0,
            hasCrypt: false,
            group: findPropertyGroup(property),
            declined: false,
            lastLightningStrike: null
        };
        
        propertyState[property] = propertyData;
        console.log(`âš¡ Property data recovered for ${property}:`, propertyData);
        showAdvisory(`Property data for ${property} was corrupted and has been reset.`, 'warning');
    }
    
    // Validate and sanitize property data structure
    if (typeof propertyData.graveyards !== 'number' || propertyData.graveyards < 0 || propertyData.graveyards > 4) {
        console.warn(`âš¡ Invalid graveyards count for ${property}: ${propertyData.graveyards}, resetting to 0`);
        propertyData.graveyards = 0;
    }
    
    if (typeof propertyData.hasCrypt !== 'boolean') {
        console.warn(`âš¡ Invalid crypt status for ${property}: ${propertyData.hasCrypt}, resetting to false`);
        propertyData.hasCrypt = false;
    }
    
    // If property is not owned, no effect
    if (!propertyData.owner) {
        console.log(`âš¡ Property ${property} is unowned - no property effects applied`);
        return null;
    }
    
    let effectMessage = '';
    let propertyChanged = false;
    
    // Find the owner player object
    const ownerPlayer = players.find(p => p.name === propertyData.owner);
    if (!ownerPlayer) {
        console.log(`âš¡ Owner ${propertyData.owner} not found - no property effects applied`);
        return null;
    }
    
    // Get property display name for messages
    const propertyInfo = getPropertyInfo(property);
    const displayName = propertyInfo ? getPropertyDisplayName(propertyInfo) : 'Unknown Location';
    
    console.log(`âš¡ Applying property effects to ${displayName} owned by ${propertyData.owner}`);
    console.log(`âš¡ Current state: graveyards: ${propertyData.graveyards}, hasCrypt: ${propertyData.hasCrypt}`);
    
    // Lightning strike logic as specified:
    // 1. If crypt present: remove crypt and replace with 4 graveyards
    if (propertyData.hasCrypt) {
        propertyData.hasCrypt = false;
        propertyData.graveyards = 4; // Replace crypt with 4 graveyards
        effectMessage = `The crypt on ${displayName} was destroyed by lightning and replaced with 4 graveyards!`;
        propertyChanged = true;
        console.log(`âš¡ Removed crypt from ${displayName} and added 4 graveyards`);
    }
    // 2. If graveyards present: remove 1 graveyard
    else if (propertyData.graveyards > 0) {
        propertyData.graveyards--;
        const remaining = propertyData.graveyards;
        if (remaining > 0) {
            effectMessage = `A graveyard on ${displayName} was destroyed by lightning! ${remaining} graveyard${remaining > 1 ? 's' : ''} remaining.`;
        } else {
            effectMessage = `The last graveyard on ${displayName} was destroyed by lightning! Property now has no developments.`;
        }
        propertyChanged = true;
        console.log(`âš¡ Removed 1 graveyard from ${displayName}, remaining: ${propertyData.graveyards}`);
    }
    // 3. If no developments: remove ownership
    else {
        // Remove property from owner's property list
        const propertyIndex = ownerPlayer.properties.indexOf(property);
        if (propertyIndex !== -1) {
            ownerPlayer.properties.splice(propertyIndex, 1);
        }
        
        // Clear ownership
        propertyData.owner = null;
        propertyData.ownerColor = null;
        propertyData.declined = false; // Reset declined status
        
        effectMessage = `${ownerPlayer.name} lost ownership of ${displayName} due to lightning strike!`;
        propertyChanged = true;
        console.log(`âš¡ Removed ownership of ${displayName} from ${ownerPlayer.name}`);
        
        // Track this lightning strike to prevent property sync from overriding it
        if (!window.recentLightningStrikes) {
            window.recentLightningStrikes = new Map();
        }
        window.recentLightningStrikes.set(property, Date.now());
        console.log(`âš¡ Tracked lightning strike on ${property} to prevent sync override`);
    }
    
    if (propertyChanged) {
        // Record lightning strike timestamp
        propertyData.lastLightningStrike = Date.now();

        // Update game display
        updateGameFrame();
        updateInfoPanel();
        
        // Sync to Firebase if in multiplayer mode with enhanced validation
        if (isMultiplayerGame && currentRoomId) {
            try {
                console.log(`âš¡ Syncing lightning effects to Firebase for ${property}...`);
                
                // CRITICAL: Validate property data before syncing
                if (!propertyData || typeof propertyData !== 'object') {
                    console.error('âš¡ Invalid property data, aborting Firebase sync:', propertyData);
                    showAdvisory('Lightning effect applied locally, but sync failed due to invalid data.', 'warning');
                    return effectMessage;
                }
                
                // Validate property state structure
                const validatedPropertyData = {
                    owner: propertyData.owner || null,
                    ownerColor: propertyData.ownerColor || null,
                    graveyards: Math.max(0, Math.min(4, propertyData.graveyards || 0)), // Clamp to 0-4
                    hasCrypt: Boolean(propertyData.hasCrypt),
                    group: propertyData.group,
                    declined: Boolean(propertyData.declined),
                    lastLightningStrike: propertyData.lastLightningStrike || Date.now()
                };
                
                // Update property state with validated data
                await updatePropertyState(property, validatedPropertyData);
                
                // CRITICAL: Rebuild player property arrays to maintain consistency
                rebuildPlayerPropertyArrays();
                
                // Update owner's properties if ownership was removed
                if (!validatedPropertyData.owner && ownerPlayer) {
                    // Validate player data before syncing
                    if (ownerPlayer.name && Array.isArray(ownerPlayer.properties)) {
                        await updatePlayerData(ownerPlayer.name, {
                            properties: ownerPlayer.properties
                        });
                    } else {
                        console.error('âš¡ Invalid owner player data, skipping player update:', ownerPlayer);
                    }
                }
                
                // Force a complete game state sync to ensure consistency
                setTimeout(() => {
                    if (isMultiplayerGame && currentRoomId) {
                        console.log('âš¡ Performing delayed complete sync after lightning strike...');
                        syncGameStateToFirebase();
                    }
                }, 1000); // 1 second delay to allow all updates to complete
                
                console.log(`âš¡ Firebase sync completed successfully for ${property}`);
            } catch (error) {
                console.error('âš¡ Error syncing lightning property effects to Firebase:', error);
                showAdvisory('Lightning effect applied locally, but sync failed. Other players may not see the change immediately.', 'warning');
            }
        }
        
        console.log(`âš¡ Property effect applied: ${effectMessage}`);
        return effectMessage;
    }
    
    return null;
}

// Check for steal card bonus on additional positions when gojail is glowing
async function checkStealCardBonusPositions(player) {
    // Only give steal cards if gojail is glowing green and player hasn't received one yet
    if (!gojailGlowActive || gojailGlowPlayersReceived.has(player.name)) {
        return;
    }
    
    // Check if player is on one of the bonus positions: b1, l1
    const bonusPositions = ['b1', 'l1'];
    
    if (bonusPositions.includes(player.currentSquare)) {
        // Player landed on a bonus position while gojail is glowing and hasn't received a card yet - give them a steal card!
        player.stealCards++;
        gojailGlowPlayersReceived.add(player.name); // Mark player as having received a card
        
        // Play steal award sound
        playStealAwardSound();
        
        console.log(`${player.name} landed on ${player.currentSquare} while gojail glows green - received a steal card! Total steal cards: ${player.stealCards}`);
        
        // Show advisory message
        showAdvisory(`${player.name} landed on ${player.currentSquare.toUpperCase()} while The Witches Grave glows green and received a STEAL CARD!`, 'turn');
        
        // Update info panel to show the steal card
        updateInfoPanel();
        
        // Note: Not deactivating glow so multiple players can benefit during the 50-second window
    }
}

function startStolenPropertyPulse(square) {
    stolenPropertyPulse = square;
    if (stolenPulseInterval) {
        clearInterval(stolenPulseInterval);
    }
    stolenPulseInterval = setInterval(updateGameFrame, 100);
    setTimeout(() => {
        clearInterval(stolenPulseInterval);
        stolenPulseInterval = null;
        stolenPropertyPulse = null;
        updateGameFrame();
    }, 4000);
}

// Test function to test movement button flashing fix
function testMovementButtonFlashing() {
    console.log('=== MOVEMENT BUTTON FLASHING TEST ===');
    
    if (players.length === 0) {
        console.log('No players found. Creating test player...');
        players.push({
            name: 'TestPlayer',
            money: 16500,
            currentSquare: 'go',
            currentPathKey: 'gamePath',
            currentIndexOnPath: 0,
            x: 0,
            y: 0,
            properties: [],
            isAI: false,
            bankrupt: false
        });
        currentPlayerIndex = 0;
    }
    
    const player = players[currentPlayerIndex];
    console.log(`Testing movement with ${player.name}...`);
    
    // Set up some properties for the player to potentially land on
    if (propertyState['l1']) {
        propertyState['l1'].owner = null; // Make it unowned to trigger purchase buttons
    }
    if (propertyState['l2']) {
        propertyState['l2'].owner = null; // Make it unowned to trigger purchase buttons
    }
    
    console.log('Movement flag before movement:', isPlayerMoving);
    console.log('Starting 6-space movement...');
    console.log('Watch the info panel - purchase buttons should NOT flash during movement');
    
    // Start movement and monitor the flag
    const originalUpdateInfoPanel = updateInfoPanel;
    let infoPanelCallCount = 0;
    
    // Temporarily override updateInfoPanel to track calls during movement
    updateInfoPanel = function(...args) {
        infoPanelCallCount++;
        console.log(`updateInfoPanel call #${infoPanelCallCount} - isPlayerMoving: ${isPlayerMoving}`);
        if (isPlayerMoving) {
            console.log('âš ï¸ updateInfoPanel called while player is moving - this could cause button flashing');
        } else {
            console.log('âœ… updateInfoPanel called while player is NOT moving - safe');
        }
        return originalUpdateInfoPanel.apply(this, args);
    };
    
    // Start the movement test
    moveToken(player, 6).then(() => {
        console.log('Movement completed');
        console.log('Movement flag after movement:', isPlayerMoving);
        console.log(`Total updateInfoPanel calls during test: ${infoPanelCallCount}`);
        
        // Restore original function
        updateInfoPanel = originalUpdateInfoPanel;
        
        console.log('=== MOVEMENT BUTTON FLASHING TEST COMPLETE ===');
    });
}

// Test function to test crypt and graveyard rent calculations
function testCryptAndGraveyardRent() {
    console.log('=== CRYPT AND GRAVEYARD RENT TEST ===');
    
    if (players.length < 2) {
        console.log('Need at least 2 players for rent test. Creating test players...');
        players = [
            {
                name: 'PropertyOwner',
                money: 10000,
                properties: ['l1', 'l2'],
                currentSquare: 'go',
                currentPathKey: 'gamePath',
                currentIndexOnPath: 0,
                x: 0,
                y: 0,
                isAI: false,
                bankrupt: false
            },
            {
                name: 'RentPayer',
                money: 16500,
                properties: [],
                currentSquare: 'go',
                currentPathKey: 'gamePath',
                currentIndexOnPath: 0,
                x: 0,
                y: 0,
                isAI: false,
                bankrupt: false
            }
        ];
        
        currentPlayerIndex = 1; // RentPayer's turn
    }
    
    const rentPayer = players[1]; // Player2
    const rentReceiver = players[0]; // Player1
    
    // Test 1: Crypt Rent (5x property cost)
    console.log('\\n--- TEST 1: CRYPT RENT ---');
    if (propertyState['l1']) {
        propertyState['l1'].owner = 'PropertyOwner';
        propertyState['l1'].graveyards = 4;
        propertyState['l1'].hasCrypt = true;
        console.log('L1 property set up with crypt');
    }
    
    const cryptPropertyInfo = getPropertyInfo('l1');
    if (cryptPropertyInfo) {
        console.log(`Property: ${getPropertyDisplayName(cryptPropertyInfo)}`);
        console.log(`Base cost: Â£${cryptPropertyInfo.cost}`);
        console.log(`Has crypt: ${cryptPropertyInfo.state.hasCrypt}`);
        
        const cryptRentInfo = calculateRent(cryptPropertyInfo);
        console.log(`Calculated rent: Â£${cryptRentInfo.amount}`);
        console.log(`Expected rent (5x cost): Â£${cryptPropertyInfo.cost * 5}`);
        console.log(`Breakdown:`, cryptRentInfo.breakdown);
        
        if (cryptRentInfo.amount === cryptPropertyInfo.cost * 5) {
            console.log('âœ… CRYPT RENT CALCULATION IS CORRECT!');
        } else {
            console.log('âŒ CRYPT RENT CALCULATION IS INCORRECT!');
        }
    }
    
    // Test 2: Graveyard Rent (1.5x property cost per graveyard)
    console.log('\\n--- TEST 2: GRAVEYARD RENT (NEW SYSTEM) ---');
    if (propertyState['l2']) {
        propertyState['l2'].owner = 'PropertyOwner';
        propertyState['l2'].graveyards = 3; // 3 graveyards
        propertyState['l2'].hasCrypt = false;
        console.log('L2 property set up with 3 graveyards');
    }
    
    const graveyardPropertyInfo = getPropertyInfo('l2');
    if (graveyardPropertyInfo) {
        console.log(`Property: ${getPropertyDisplayName(graveyardPropertyInfo)}`);
        console.log(`Base cost: Â£${graveyardPropertyInfo.cost}`);
        console.log(`Graveyards: ${graveyardPropertyInfo.state.graveyards}`);
        
        const graveyardRentInfo = calculateRent(graveyardPropertyInfo);
        const expectedGraveyardRent = graveyardPropertyInfo.cost * 1.5 * 3; // 3 Ã— 1.5x = 4.5x
        console.log(`Calculated rent: Â£${graveyardRentInfo.amount}`);
        console.log(`Expected rent (3 Ã— 1.5 Ã— cost = 4.5x): Â£${expectedGraveyardRent}`);
        console.log(`Breakdown:`, graveyardRentInfo.breakdown);
        
        if (graveyardRentInfo.amount === expectedGraveyardRent) {
            console.log('âœ… GRAVEYARD RENT CALCULATION IS CORRECT!');
        } else {
            console.log('âŒ GRAVEYARD RENT CALCULATION IS INCORRECT!');
        }
    }
    
    // Test 3: Base rent (no developments) - NEW: 1.5x property cost
    console.log('\\n--- TEST 3: BASE RENT (NO DEVELOPMENTS - NEW SYSTEM) ---');
    if (propertyState['l3']) {
        propertyState['l3'].owner = 'PropertyOwner';
        propertyState['l3'].graveyards = 0;
        propertyState['l3'].hasCrypt = false;
        console.log('L3 property set up with no developments');
        
        const basePropertyInfo = getPropertyInfo('l3');
        if (basePropertyInfo) {
            console.log(`Property: ${getPropertyDisplayName(basePropertyInfo)}`);
            console.log(`Base cost: Â£${basePropertyInfo.cost}`);
            
            const baseRentInfo = calculateRent(basePropertyInfo);
            const expectedBaseRent = basePropertyInfo.cost * 1.5; // NEW: 1.5x property cost
            console.log(`Calculated rent: Â£${baseRentInfo.amount}`);
            console.log(`Expected rent (1.5 Ã— cost): Â£${expectedBaseRent}`);
            console.log(`Breakdown:`, baseRentInfo.breakdown);
            
            if (baseRentInfo.amount === expectedBaseRent) {
                console.log('âœ… BASE RENT CALCULATION IS CORRECT!');
            } else {
                console.log('âŒ BASE RENT CALCULATION IS INCORRECT!');
            }
        }
    }
    
    // Test 4: Multiple Graveyard Scenarios
    console.log('\\n--- TEST 4: MULTIPLE GRAVEYARD SCENARIOS ---');
    const testScenarios = [
        { graveyards: 1, expected: 1.5 },
        { graveyards: 2, expected: 3.0 },
        { graveyards: 3, expected: 4.5 },
        { graveyards: 4, expected: 6.0 }
    ];
    
    testScenarios.forEach(scenario => {
        if (propertyState['l2']) {
            propertyState['l2'].graveyards = scenario.graveyards;
            propertyState['l2'].hasCrypt = false;
            
            const testPropertyInfo = getPropertyInfo('l2');
            if (testPropertyInfo) {
                const rentInfo = calculateRent(testPropertyInfo);
                const expectedRent = testPropertyInfo.cost * scenario.expected;
                console.log(`${scenario.graveyards} graveyard${scenario.graveyards > 1 ? 's' : ''}: Expected ${scenario.expected}x = Â£${expectedRent}, Actual: Â£${rentInfo.amount}`);
                
                if (rentInfo.amount === expectedRent) {
                    console.log(`âœ… ${scenario.graveyards} graveyard test PASSED`);
                } else {
                    console.log(`âŒ ${scenario.graveyards} graveyard test FAILED`);
                }
            }
        }
    });
    
    console.log('\\n=== RENT CALCULATION TEST COMPLETE ===');
}

// Test function to test rent message timing
function testRentMessageTiming() {
    console.log('=== RENT MESSAGE TIMING TEST ===');
    
    if (players.length < 2) {
        console.log('Need at least 2 players for rent test. Creating test players...');
        players = [
            {
                name: 'Player1',
                money: 16500,
                properties: ['l1'],
                currentSquare: 'go',
                currentPathKey: 'gamePath',
                currentIndexOnPath: 0,
                x: 0,
                y: 0,
                isAI: false,
                bankrupt: false
            },
            {
                name: 'Player2',
                money: 3000,
                properties: [],
                currentSquare: 'go',
                currentPathKey: 'gamePath',
                currentIndexOnPath: 0,
                x: 0,
                y: 0,
                isAI: false,
                bankrupt: false
            }
        ];
        
        // Set property ownership
        if (propertyState['l1']) {
            propertyState['l1'].owner = 'Player1';
        }
        
        currentPlayerIndex = 1; // Player2's turn
    }
    
    const rentPayer = players[1]; // Player2
    const rentReceiver = players[0]; // Player1
    
    console.log('Test setup:');
    console.log(`${rentReceiver.name} owns L1`);
    console.log(`${rentPayer.name} will land on L1 and pay rent`);
    console.log(`Before: ${rentPayer.name} has Â£${rentPayer.money}, ${rentReceiver.name} has Â£${rentReceiver.money}`);
    
    // Move Player2 to L1
    const l1Index = gamePath.indexOf('l1');
    const l1Pos = positionsMap.get('l1');
    
    if (l1Index !== -1 && l1Pos) {
        rentPayer.currentSquare = 'l1';
        rentPayer.currentPathKey = 'gamePath';
        rentPayer.currentIndexOnPath = l1Index;
        rentPayer.x = l1Pos.x;
        rentPayer.y = l1Pos.y;
        
        console.log(`${rentPayer.name} moved to L1. Testing rent payment...`);
        updateGameFrame();
        
        // Test the rent payment (should show rent message for 2+ seconds before "Next turn")
        const propertyInfo = getPropertyInfo('l1');
        if (propertyInfo) {
            handlePropertyLanding(rentPayer, propertyInfo).then(() => {
                console.log(`After rent: ${rentPayer.name} has Â£${rentPayer.money}, ${rentReceiver.name} has Â£${rentReceiver.money}`);
                console.log('Rent message should be visible now. Next turn message will appear in 2 seconds...');
                
                // Simulate turn advancement after rent payment
                setTimeout(() => {
                    nextTurn();
                }, 500);
            });
        }
    } else {
        console.error('Could not find L1 position');
    }
}

// Test function to test Hell's Portal teleportation zap sound
function testT8ZapSound() {
    console.log('=== HELL\'S PORTAL ZAP SOUND TEST (Hell\'s Portal â†’ Sanctuary) ===');
    
    if (players.length === 0) {
        console.log('No players found. Creating test player...');
        players.push({
            name: 'TestPlayer',
            money: 16500,
            currentSquare: 'go',
            currentPathKey: 'gamePath',
            currentIndexOnPath: 0,
            x: 0,
            y: 0,
            properties: [],
            isAI: false,
            bankrupt: false
        });
        currentPlayerIndex = 0;
    }
    
    const player = players[currentPlayerIndex];
    console.log(`Moving ${player.name} to t8...`);
    
    // Move player to t8
    const t8Index = gamePath.indexOf('t8');
    const t8Pos = positionsMap.get('t8');
    
    if (t8Index !== -1 && t8Pos) {
        player.currentSquare = 't8';
        player.currentPathKey = 'gamePath';
        player.currentIndexOnPath = t8Index;
        player.x = t8Pos.x;
        player.y = t8Pos.y;
        
        console.log(`${player.name} moved to Hell's Portal (t8). Testing teleportation to Sanctuary (t2) with zap sound...`);
        updateGameFrame();
        
        // Test the teleportation logic (which should play zap sound and teleport to t2)
        setTimeout(() => {
            checkForTeleportation(player);
        }, 1000);
    } else {
        console.error('Could not find t8 position');
    }
}

// Test function to test R5 to B5 teleportation
function testR5TeleportSound() {
    console.log('=== R5 ZAP SOUND TEST (R5 â†’ B5) ===');
    
    if (players.length === 0) {
        console.log('No players found. Creating test player...');
        players.push({
            name: 'TestPlayer',
            money: 16500,
            currentSquare: 'go',
            currentPathKey: 'gamePath',
            currentIndexOnPath: 0,
            x: 0,
            y: 0,
            properties: [],
            isAI: false,
            bankrupt: false
        });
        currentPlayerIndex = 0;
    }
    
    const player = players[currentPlayerIndex];
    console.log(`Moving ${player.name} to r5...`);
    
    // Move player to r5
    const r5Index = gamePath.indexOf('r5');
    const r5Pos = positionsMap.get('r5');
    
    if (r5Index !== -1 && r5Pos) {
        player.currentSquare = 'r5';
        player.currentPathKey = 'gamePath';
        player.currentIndexOnPath = r5Index;
        player.x = r5Pos.x;
        player.y = r5Pos.y;
        
        console.log(`${player.name} moved to r5. Testing teleportation to b5 with zap sound...`);
        updateGameFrame();
        
        // Test the teleportation logic (which should play zap sound and teleport to b5)
        setTimeout(() => {
            checkForTeleportation(player);
        }, 1000);
    } else {
        console.error('Could not find r5 position');
    }
}

// Test function to test yingyang quote protection
function testYingyangProtection() {
    console.log('=== YINGYANG QUOTE PROTECTION TEST ===');
    
    console.log('1. Displaying yingyang quote...');
    showAdvisory('Test yingyang quote message', 'yingyang');
    
    console.log('2. Protection flag should be set:', isYingyangDisplaying);
    
    console.log('3. Attempting to show turn message (should be blocked)...');
    showAdvisory('Next turn: TestPlayer', 'turn');
    
    console.log('4. Attempting to show payment message (should be blocked)...');
    showAdvisory('TestPlayer paid rent', 'payment');
    
    console.log('5. Waiting 4 seconds for protection to clear...');
    setTimeout(() => {
        console.log('6. Protection flag after 4 seconds:', isYingyangDisplaying);
        console.log('7. Attempting to show turn message again (should work now)...');
        showAdvisory('Next turn: TestPlayer (after protection)', 'turn');
        console.log('=== END PROTECTION TEST ===');
    }, 4000);
}

// Test function to debug doubles logic
function testDoublesLogic() {
    console.log('=== DOUBLES LOGIC DEBUG TEST ===');
    
    console.log('Current doubles state:');
    console.log('- lastRollWasDoubles:', lastRollWasDoubles);
    console.log('- consecutiveDoublesCount:', consecutiveDoublesCount);
    console.log('- currentPlayerIndex:', currentPlayerIndex);
    console.log('- currentPlayer:', players[currentPlayerIndex]?.name);
    console.log('- isMultiplayerGame:', isMultiplayerGame);
    console.log('- isAITurn:', isAITurn);
    
    // Simulate a doubles roll
    console.log('\nSimulating doubles roll...');
    const testDie1 = 3;
    const testDie2 = 3;
    console.log(`Test roll: ${testDie1} + ${testDie2} = ${testDie1 + testDie2} (doubles: ${testDie1 === testDie2})`);
    
    if (testDie1 === testDie2) {
        console.log('This would be handled as doubles');
        console.log('Expected behavior:');
        if (isMultiplayerGame) {
            console.log('- Multiplayer: Show "Doubles! Click dice to roll again" and wait for manual click');
        } else {
            console.log('- Single-player: Show "Doubles! Auto-rolling again..." and auto-roll after 1.5s');
        }
    } else {
        console.log('This would be handled as non-doubles');
        console.log('Expected behavior: Call nextTurn() to advance to next player');
    }
    
    console.log('=== END DOUBLES TEST ===');
}

// Test function to simulate rolling doubles
function simulateDoubles() {
    console.log('=== SIMULATING DOUBLES ROLL ===');
    
    if (!players || players.length === 0) {
        console.log('ERROR: No players found');
        return;
    }
    
    const currentPlayer = players[currentPlayerIndex];
    if (!currentPlayer) {
        console.log('ERROR: No current player');
        return;
    }
    
    console.log(`Simulating doubles for ${currentPlayer.name}`);
    console.log('Before roll:', {
        lastRollWasDoubles: lastRollWasDoubles,
        consecutiveDoublesCount: consecutiveDoublesCount
    });
    
    // Simulate the doubles logic
    lastRollWasDoubles = true;
    consecutiveDoublesCount++;
    
    console.log('After roll:', {
        lastRollWasDoubles: lastRollWasDoubles,
        consecutiveDoublesCount: consecutiveDoublesCount
    });
    
    if (consecutiveDoublesCount === 3) {
        console.log('Would send to jail (3 consecutive doubles)');
    } else if (isMultiplayerGame) {
        console.log('Multiplayer: Would show "Click dice to roll again" message');
    } else {
        console.log('Single-player: Would auto-roll after delay');
    }
    
    console.log('=== END SIMULATION ===');
}

// Test function to debug dice pulsing behavior
function testDicePulsing() {
    console.log('=== DICE PULSING DEBUG TEST ===');
    
    const diceSection = document.getElementById('dice-section');
    if (!diceSection) {
        console.log('ERROR: Dice section not found');
        return;
    }
    
    console.log('Current dice state:');
    console.log('- Classes:', diceSection.className);
    console.log('- Pointer events:', diceSection.style.pointerEvents);
    console.log('- isMultiplayerGame:', isMultiplayerGame);
    console.log('- currentPlayerIndex:', currentPlayerIndex);
    console.log('- currentPlayer:', players[currentPlayerIndex]?.name);
    console.log('- isAITurn:', isAITurn);
    console.log('- isPlayerMoving:', isPlayerMoving);
    
    if (isMultiplayerGame) {
        const playerName = document.getElementById('player1-name').value.trim();
        const localPlayerName = window.localPlayerName;
        const currentPlayer = players[currentPlayerIndex];
        
        console.log('Multiplayer state:');
        console.log('- Input player name:', playerName);
        console.log('- Local player name:', localPlayerName);
        console.log('- Current player name:', currentPlayer?.name);
        console.log('- Current player is host:', currentPlayer?.isHost);
        console.log('- Local is host:', isHost);
        
        const isMyTurn = currentPlayer && (
            currentPlayer.name.toLowerCase() === (playerName || '').toLowerCase() ||
            currentPlayer.name.toLowerCase() === (localPlayerName || '').toLowerCase() ||
            (currentPlayer.isHost === isHost && (playerName || localPlayerName))
        );
        
        console.log('- Is my turn:', isMyTurn);
        console.log('- Current player bankrupt:', currentPlayer?.bankrupt);
    }
    
    console.log('Expected behavior:');
    console.log('- Green pulse (dice-pulse): Your turn, can roll');
    console.log('- Blue pulse (dice-pulse-blue): AI turn');
    console.log('- Red pulse (dice-pulse-red): Your turn but waiting for decision (purchase/develop)');
    console.log('- No pulse: Not your turn in multiplayer');
    
    console.log('=== END DICE PULSING TEST ===');
}

// Test function to debug rent collection in multiplayer
function testRentCollection() {
    console.log('=== RENT COLLECTION DEBUG TEST ===');
    
    if (!isMultiplayerGame) {
        console.log('Not in multiplayer mode. Starting multiplayer test...');
        // Set up a basic multiplayer test scenario
        isMultiplayerGame = true;
        currentRoomId = 'test-room';
    }
    
    // Create test scenario: Player 1 owns a property, Player 2 lands on it
    if (players.length < 2) {
        console.log('Need at least 2 players for rent test. Creating test players...');
        players = [
            {
                name: 'TestPlayer1',
                money: 16500,
                properties: ['l1'],
                currentSquare: 'go',
                currentPathKey: 'gamePath',
                currentIndexOnPath: 0,
                isMovingReverse: false,
                x: 100,
                y: 100,
                size: 62,
                isAI: false,
                bankrupt: false,
                isHost: true,
                tokenIndex: 0
            },
            {
                name: 'TestPlayer2', 
                money: 3000,
                properties: [],
                currentSquare: 'go',
                currentPathKey: 'gamePath',
                currentIndexOnPath: 0,
                isMovingReverse: false,
                x: 120,
                y: 100,
                size: 62,
                isAI: false,
                bankrupt: false,
                isHost: false,
                tokenIndex: 1
            }
        ];
        
        // Set property ownership
        if (propertyState && propertyState.l1) {
            propertyState.l1.owner = 'TestPlayer1';
        }
    }
    
    // Set Player 2 as current player and move them to Player 1's property
    currentPlayerIndex = 1;
    const rentPayer = players[1];
    const rentReceiver = players[0];
    
    console.log('Before rent payment:');
    console.log(`${rentPayer.name} money: Â£${rentPayer.money}`);
    console.log(`${rentReceiver.name} money: Â£${rentReceiver.money}`);
    
    // Move Player 2 to L1 (owned by Player 1)
    rentPayer.currentSquare = 'l1';
    
    // Get property info and calculate rent
    const propertyInfo = getPropertyInfo('l1');
    if (propertyInfo) {
        console.log(`Property: ${getPropertyDisplayName(propertyInfo)}`);
        console.log(`Owner: ${propertyInfo.state.owner}`);
        
        const rentInfo = calculateRent(propertyInfo);
        console.log(`Calculated rent: Â£${rentInfo.amount}`);
        console.log('Rent breakdown:', rentInfo.breakdown);
        
        // Test the actual rent collection
        console.log('Testing rent collection...');
        handlePropertyLanding(rentPayer, propertyInfo).then(() => {
            console.log('After rent payment:');
            console.log(`${rentPayer.name} money: Â£${rentPayer.money}`);
            console.log(`${rentReceiver.name} money: Â£${rentReceiver.money}`);
            
            // Check if Firebase sync would be called
            if (isMultiplayerGame) {
                console.log('Multiplayer mode: Firebase sync should be triggered');
                console.log('Current game state that would be synced:');
                console.log('Players:', players.map(p => ({
                    name: p.name,
                    money: p.money,
                    properties: p.properties
                })));
            }
            
            console.log('=== RENT COLLECTION TEST COMPLETE ===');
        });
    } else {
        console.error('Property L1 not found!');
    }
}

// Test function to verify rent deduction logic
function testRentDeduction() {
    console.log('=== RENT DEDUCTION VERIFICATION TEST ===');
    
    // Create test players
    const testPlayer1 = {
        name: 'TestOwner',
        money: 3000,
        properties: ['l1'],
        currentSquare: 'go',
        currentPathKey: 'gamePath',
        currentIndexOnPath: 0,
        x: 0,
        y: 0,
        isAI: false,
        bankrupt: false
    };
    
    const testPlayer2 = {
        name: 'TestRenter',
        money: 2000,
        properties: [],
        currentSquare: 'go',
        currentPathKey: 'gamePath',
        currentIndexOnPath: 0,
        x: 0,
        y: 0,
        isAI: false,
        bankrupt: false
    };
    
    // Backup original players
    const originalPlayers = [...players];
    const originalPropertyState = JSON.parse(JSON.stringify(propertyState));
    
    // Set test players
    players = [testPlayer1, testPlayer2];
    
    // Set property ownership
    if (propertyState['l1']) {
        propertyState['l1'].owner = 'TestOwner';
        console.log('Set L1 owner to TestOwner');
    } else {
        console.error('L1 property not found in propertyState');
        return;
    }
    
    console.log('=== BEFORE RENT PAYMENT ===');
    console.log(`${testPlayer1.name} (owner) money: Â£${testPlayer1.money}`);
    console.log(`${testPlayer2.name} (renter) money: Â£${testPlayer2.money}`);
    
    // Get property info
    const propertyInfo = getPropertyInfo('l1');
    if (!propertyInfo) {
        console.error('Could not get property info for L1');
        return;
    }
    
    console.log(`Property: ${getPropertyDisplayName(propertyInfo)}`);
    console.log(`Property owner: ${propertyInfo.state.owner}`);
    
    // Calculate expected rent
    const rentInfo = calculateRent(propertyInfo);
    console.log(`Expected rent: Â£${rentInfo.amount}`);
    console.log('Rent breakdown:', rentInfo.breakdown);
    
    // Test the rent payment
    console.log('=== TESTING RENT PAYMENT ===');
    handlePropertyLanding(testPlayer2, propertyInfo).then(() => {
        console.log('=== AFTER RENT PAYMENT ===');
        console.log(`${testPlayer1.name} (owner) money: Â£${testPlayer1.money}`);
        console.log(`${testPlayer2.name} (renter) money: Â£${testPlayer2.money}`);
        
        // Calculate expected amounts
        const expectedOwnerMoney = 3000 + rentInfo.amount;
        const expectedRenterMoney = 2000 - rentInfo.amount;
        
        console.log('=== VERIFICATION ===');
        console.log(`Expected owner money: Â£${expectedOwnerMoney}, Actual: Â£${testPlayer1.money}`);
        console.log(`Expected renter money: Â£${expectedRenterMoney}, Actual: Â£${testPlayer2.money}`);
        
        if (testPlayer1.money === expectedOwnerMoney && testPlayer2.money === expectedRenterMoney) {
            console.log('âœ… RENT DEDUCTION WORKING CORRECTLY');
        } else {
            console.log('âŒ RENT DEDUCTION NOT WORKING');
            console.log('Money was not properly transferred');
        }
        
        // Restore original state
        players = originalPlayers;
        propertyState = originalPropertyState;
        
        console.log('=== TEST COMPLETE ===');
    }).catch(error => {
        console.error('Error during rent payment test:', error);
        // Restore original state on error
        players = originalPlayers;
        propertyState = originalPropertyState;
    });
}

// Simple test function to verify the new rent calculation system
function testNewRentSystem() {
    console.log('=== NEW RENT SYSTEM VERIFICATION ===');
    
    // Test property with Â£1000 cost
    const testProperty = {
        square: 'test',
        cost: 1000,
        group: 'test',
        color: '#ffffff',
        state: {
            owner: 'TestPlayer',
            graveyards: 0,
            hasCrypt: false
        }
    };
    
    console.log('Testing property with Â£1000 cost:');
    
    // Test base property (no developments)
    console.log('\n1. Base property (no developments):');
    testProperty.state.graveyards = 0;
    testProperty.state.hasCrypt = false;
    let rentInfo = calculateRent(testProperty);
    console.log(`   Expected: Â£1500 (1.5 Ã— Â£1000)`);
    console.log(`   Actual: Â£${rentInfo.amount}`);
    console.log(`   âœ… ${rentInfo.amount === 1500 ? 'CORRECT' : 'INCORRECT'}`);
    
    // Test 1 graveyard
    console.log('\n2. 1 graveyard:');
    testProperty.state.graveyards = 1;
    testProperty.state.hasCrypt = false;
    rentInfo = calculateRent(testProperty);
    console.log(`   Expected: Â£1500 (1 Ã— 1.5 Ã— Â£1000)`);
    console.log(`   Actual: Â£${rentInfo.amount}`);
    console.log(`   âœ… ${rentInfo.amount === 1500 ? 'CORRECT' : 'INCORRECT'}`);
    
    // Test 2 graveyards
    console.log('\n3. 2 graveyards:');
    testProperty.state.graveyards = 2;
    testProperty.state.hasCrypt = false;
    rentInfo = calculateRent(testProperty);
    console.log(`   Expected: Â£3000 (2 Ã— 1.5 Ã— Â£1000 = 3x)`);
    console.log(`   Actual: Â£${rentInfo.amount}`);
    console.log(`   âœ… ${rentInfo.amount === 3000 ? 'CORRECT' : 'INCORRECT'}`);
    
    // Test 3 graveyards
    console.log('\n4. 3 graveyards:');
    testProperty.state.graveyards = 3;
    testProperty.state.hasCrypt = false;
    rentInfo = calculateRent(testProperty);
    console.log(`   Expected: Â£4500 (3 Ã— 1.5 Ã— Â£1000 = 4.5x)`);
    console.log(`   Actual: Â£${rentInfo.amount}`);
    console.log(`   âœ… ${rentInfo.amount === 4500 ? 'CORRECT' : 'INCORRECT'}`);
    
    // Test 4 graveyards
    console.log('\n5. 4 graveyards:');
    testProperty.state.graveyards = 4;
    testProperty.state.hasCrypt = false;
    rentInfo = calculateRent(testProperty);
    console.log(`   Expected: Â£6000 (4 Ã— 1.5 Ã— Â£1000 = 6x)`);
    console.log(`   Actual: Â£${rentInfo.amount}`);
    console.log(`   âœ… ${rentInfo.amount === 6000 ? 'CORRECT' : 'INCORRECT'}`);
    
    // Test crypt
    console.log('\n6. Crypt:');
    testProperty.state.graveyards = 0;
    testProperty.state.hasCrypt = true;
    rentInfo = calculateRent(testProperty);
    console.log(`   Expected: Â£5000 (5 Ã— Â£1000)`);
    console.log(`   Actual: Â£${rentInfo.amount}`);
    console.log(`   âœ… ${rentInfo.amount === 5000 ? 'CORRECT' : 'INCORRECT'}`);
    
    console.log('\n=== RENT SYSTEM SUMMARY ===');
    console.log('âœ… Base property: 1.5x property cost');
    console.log('âœ… Each graveyard: 1.5x property cost (cumulative)');
    console.log('âœ… Crypt: 5x property cost');
    console.log('\n=== TEST COMPLETE ===');
}

// Test function to verify jail sound plays when landing on gojail
function testGojailJailSound() {
    console.log('=== GOJAIL JAIL SOUND TEST ===');
    
    if (players.length === 0) {
        console.log('Creating test player...');
        players = [{
            name: 'TestPlayer',
            money: 3000,
            properties: [],
            currentSquare: 'go',
            currentPathKey: 'gamePath',
            currentIndexOnPath: 0,
            x: 0,
            y: 0,
            isAI: false,
            bankrupt: false
        }];
        currentPlayerIndex = 0;
    }
    
    const testPlayer = players[0];
    
    console.log(`Moving ${testPlayer.name} to gojail square...`);
    
    // Find gojail position
    const gojailIndex = gamePath.indexOf('gojail');
    const gojailPos = positionsMap.get('gojail');
    
    if (gojailIndex !== -1 && gojailPos) {
        // Move player to gojail
        testPlayer.currentSquare = 'gojail';
        testPlayer.currentPathKey = 'gamePath';
        testPlayer.currentIndexOnPath = gojailIndex;
        testPlayer.x = gojailPos.x;
        testPlayer.y = gojailPos.y;
        
        console.log(`${testPlayer.name} is now on gojail. Testing jail sound...`);
        console.log('Before jail - Player money:', testPlayer.money);
        
        // Test the jail sound by simulating the gojail landing
        playJailSound().then(() => {
            console.log('âœ… Jail sound played successfully!');
        }).catch(error => {
            console.error('âŒ Failed to play jail sound:', error);
        });
        
        // Also test the full sendPlayerToJail function
        sendPlayerToJail(testPlayer, 100).then(() => {
            console.log('After jail - Player money:', testPlayer.money);
            console.log('Player current square:', testPlayer.currentSquare);
            console.log('âœ… Player successfully sent to jail with sound!');
        });
        
        updateGameFrame();
    } else {
        console.error('Could not find gojail position');
    }
    
    console.log('=== TEST COMPLETE ===');
}

// Make test function globally available
window.testMovementButtonFlashing = testMovementButtonFlashing;
window.testCryptAndGraveyardRent = testCryptAndGraveyardRent;

// Test function for lightning system
async function testLightningStrike() {
    console.log('=== LIGHTNING SYSTEM TEST ===');
    
    if (players.length === 0) {
        console.log('No players found. Creating test player...');
        players.push({
            name: 'TestPlayer',
            money: 2000,
            currentSquare: 't1',
            currentPathKey: 'gamePath',
            currentIndexOnPath: 1,
            x: 211,
            y: 90,
            properties: [],
            isAI: false,
            bankrupt: false,
            inJail: false,
            jailTurns: 0
        });
        currentPlayerIndex = 0;
    }
    
    // Force trigger lightning on player's current position
    const player = players[currentPlayerIndex];
    console.log(`Testing lightning strike on ${player.name} at ${player.currentSquare}`);
    
    // Manually trigger lightning at player's position
    const propertyPos = positionsMap?.get(player.currentSquare);
    if (propertyPos) {
        console.log(`Creating enhanced lightning effect at (${propertyPos.x}, ${propertyPos.y})`);
        createLightningEffect(propertyPos.x, propertyPos.y);
        await applyLightningPenalty(player, player.currentSquare);
    }
}

window.testLightningStrike = testLightningStrike;





// Test function for tablet steal card responsiveness
window.testTabletStealCard = function() {
    console.log('=== TABLET STEAL CARD TEST ===');
    
    // Check tablet detection
    const isTabletDevice = window.isTablet || (window.deviceInfo && window.deviceInfo.isTablet);
    console.log('Tablet detected:', isTabletDevice);
    console.log('Device info:', window.deviceInfo);
    
    // Check if steal cards are available
    if (!players || players.length === 0) {
        console.log('âŒ No players found - start a game first');
        return;
    }
    
    const currentPlayer = players[currentPlayerIndex];
    console.log('Current player:', currentPlayer?.name, 'Steal cards:', currentPlayer?.stealCards);
    
    if (!currentPlayer || currentPlayer.stealCards <= 0) {
        console.log('âŒ Current player has no steal cards');
        // Give player a steal card for testing
        if (currentPlayer) {
            currentPlayer.stealCards = 1;
            console.log('âœ… Added test steal card');
            updateInfoPanel();
        }
    }
    
    // Test coordinates - simulate tap in center of canvas
    const canvas = document.querySelector('canvas');
    if (canvas) {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        console.log(`Testing steal card at canvas center: (${centerX}, ${centerY})`);
        console.log('Detection radius for tablets:', isTabletDevice ? 220 : 'not tablet');
        
        // Test the steal function
        setTimeout(() => {
            console.log('ðŸŽ¯ Triggering test steal...');
            if (typeof handlePropertySteal === 'function') {
                handlePropertySteal(centerX, centerY, true);
            } else {
                console.log('âŒ handlePropertySteal function not found');
            }
        }, 1000);
    }
    
    console.log('âœ… Tablet steal card test initiated');
};

// Function to refresh tablet touch handling for steal cards
window.refreshTabletStealCardTouch = function() {
    console.log('ðŸŽ¯ Refreshing tablet steal card touch handling...');
    
    // Check if tablet touch manager exists
    if (typeof initTabletTouchManager === 'function') {
        console.log('ðŸŽ¯ Reinitializing tablet touch manager...');
        initTabletTouchManager();
    } else {
        console.log('âš ï¸ Tablet touch manager not found, trying alternative initialization...');
    }
    
    // Ensure tablet detection is working
    const isTabletDevice = window.isTablet || (window.deviceInfo && window.deviceInfo.isTablet);
    console.log('Tablet device detected:', isTabletDevice);
    
    if (isTabletDevice) {
        // Force re-detection of device capabilities
        if (window.deviceInfo) {
            console.log('Current device info:', window.deviceInfo);
        }
        
        // Check if canvas has proper touch event listeners
        const canvas = document.querySelector('canvas');
        if (canvas) {
            console.log('Canvas found, checking touch event listeners...');
            
            // Add enhanced tablet-specific touch handling if not present
            if (!canvas.hasTabletTouchHandlers) {
                console.log('ðŸŽ¯ Adding enhanced tablet touch handlers...');
                
                let lastTabletTapTime = 0;
                let lastTabletTapPos = { x: 0, y: 0 };
                
                const tabletTouchEnd = (e) => {
                    e.preventDefault();
                    
                    const currentTime = Date.now();
                    const rect = canvas.getBoundingClientRect();
                    const touch = e.changedTouches[0];
                    
                    // Enhanced coordinate calculation for tablets
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const pixelRatio = window.devicePixelRatio || 1;
                    
                    const tapX = ((touch.clientX - rect.left) * scaleX) / pixelRatio;
                    const tapY = ((touch.clientY - rect.top) * scaleY) / pixelRatio;
                    
                    console.log(`ðŸŽ¯ TABLET TOUCH: (${Math.round(tapX)}, ${Math.round(tapY)})`);
                    
                    // Check for double tap with tablet-friendly thresholds
                    const timeSinceLastTap = currentTime - lastTabletTapTime;
                    const distanceFromLastTap = Math.sqrt(
                        Math.pow(tapX - lastTabletTapPos.x, 2) + 
                        Math.pow(tapY - lastTabletTapPos.y, 2)
                    );
                    
                    const TABLET_DOUBLE_TAP_THRESHOLD = 900; // 900ms for tablets
                    const TABLET_POSITION_THRESHOLD = 100;   // 100px for tablets
                    
                    if (timeSinceLastTap < TABLET_DOUBLE_TAP_THRESHOLD && 
                        distanceFromLastTap < TABLET_POSITION_THRESHOLD) {
                        console.log('ðŸŽ¯ TABLET DOUBLE-TAP DETECTED - TRIGGERING STEAL');
                        
                        // Trigger steal card functionality
                        if (typeof handlePropertySteal === 'function') {
                            handlePropertySteal(tapX, tapY, false);
                        }
                    }
                    
                    // Update last tap info
                    lastTabletTapTime = currentTime;
                    lastTabletTapPos = { x: tapX, y: tapY };
                };
                
                canvas.addEventListener('touchend', tabletTouchEnd, { passive: false });
                canvas.hasTabletTouchHandlers = true;
                
                console.log('âœ… Enhanced tablet touch handlers added');
            } else {
                console.log('âœ… Tablet touch handlers already present');
            }
        } else {
            console.log('âŒ Canvas not found');
        }
    } else {
        console.log('â„¹ï¸ Not a tablet device, skipping tablet-specific touch handling');
    }
    
    console.log('âœ… Tablet steal card touch refresh completed');
};

// Test function for multiplayer bottom display
window.testMultiplayerBottomDisplay = function() {
    console.log('=== MULTIPLAYER BOTTOM DISPLAY TEST ===');
    
    // Create test players with properties if none exist
    if (!players || players.length === 0) {
        console.log('Creating test players for multiplayer display...');
        players = [
            {
                name: 'Alice',
                money: 1500,
                currentSquare: 't1',
                properties: ['t1', 'r2', 'b3'],
                color: '#ff6b6b',
                stealCards: 2,
                image: { src: 'assets/images/t1.png' },
                bankrupt: false
            },
            {
                name: 'Bob',
                money: 800,
                currentSquare: 'r5',
                properties: ['l1', 'l2'],
                color: '#4ecdc4',
                stealCards: 0,
                image: { src: 'assets/images/t2.png' },
                bankrupt: false
            },
            {
                name: 'Charlie',
                money: 0,
                currentSquare: 'jail',
                properties: [],
                color: '#45b7d1',
                stealCards: 1,
                image: { src: 'assets/images/t3.png' },
                bankrupt: true
            }
        ];
        currentPlayerIndex = 0;
    }
    
    // Force update the bottom display
    updateBottomPlayerDisplay();
    
    console.log('âœ… Multiplayer bottom display updated!');
    console.log('ðŸ“± Each player should show on one line with:');
    console.log('   - Star (colored) + Token image');
    console.log('   - Player name');  
    console.log('   - Money amount (or BANKRUPT)');
    console.log('   - Owned properties with color dots');
    console.log('   - Steal cards (if any)');
    console.log('ðŸ“± Current player should be highlighted');
    
    showAdvisory('Multiplayer bottom display test completed! Check the bottom of the screen.', 'turn');
};

// Scorch mark utility functions for testing
window.createTestScorchMark = function(property) {
    if (!property) {
        console.log('Usage: createTestScorchMark("property_name")');
        console.log('Example: createTestScorchMark("t1")');
        return;
    }
    createScorchMark(property);
    console.log(`ðŸ”¥ Test scorch mark created on ${property}`);
};

window.clearScorchMarks = function() {
    clearAllScorchMarks();
    console.log('ðŸ”¥ All scorch marks cleared');
};

window.showScorchMarks = function() {
    const scorchMarks = document.querySelectorAll('.scorch-mark');
    console.log(`ðŸ”¥ Found ${scorchMarks.length} scorch marks:`);
    scorchMarks.forEach(mark => {
        const property = mark.id.replace('scorch-mark-', '');
        console.log(`  - ${property}`);
    });
};

// Teleport flash utility function for testing
window.testTeleportFlash = function() {
    createTeleportScreenFlash();
    console.log('âœ¨ Test teleport white screen flash triggered');
};

// Double touch sensitivity test function
window.testDoubleTouchSensitivity = function() {
    console.log('=== DOUBLE TOUCH SENSITIVITY TEST ===');
    console.log(`ðŸ“± Mobile device detected: ${isMobile}`);
    console.log(`â±ï¸ Double click/tap threshold: ${DOUBLE_CLICK_THRESHOLD}ms`);
    console.log(`ðŸ“ Position threshold: ${CLICK_POSITION_THRESHOLD}px`);
    console.log(`ðŸ–±ï¸ Last tap time: ${lastTapTime}`);
    console.log(`ðŸ“ Last tap position:`, lastTapPosition);
    
    // Show visual feedback
    showAdvisory(`Double touch test: ${DOUBLE_CLICK_THRESHOLD}ms window, ${CLICK_POSITION_THRESHOLD}px tolerance`, 'info');
    
    // Simulate a test double touch detection
    const currentTime = Date.now();
    const testX = 400, testY = 300;
    
    // First tap
    lastTapTime = currentTime;
    lastTapPosition = { x: testX, y: testY };
    console.log(`ðŸŽ¯ Simulated first tap at (${testX}, ${testY})`);
    
    // Second tap after 300ms (should be detected as double tap)
    setTimeout(() => {
        const secondTapTime = Date.now();
        const timeDiff = secondTapTime - lastTapTime;
        const distance = Math.sqrt(Math.pow(testX - lastTapPosition.x, 2) + Math.pow(testY - lastTapPosition.y, 2));
        
        console.log(`ðŸŽ¯ Simulated second tap - Time diff: ${timeDiff}ms, Distance: ${distance}px`);
        
        if (timeDiff < DOUBLE_CLICK_THRESHOLD && distance < CLICK_POSITION_THRESHOLD) {
            console.log('âœ… Double touch sensitivity test PASSED');
            showAdvisory('âœ… Double touch sensitivity test PASSED', 'success');
        } else {
            console.log('âŒ Double touch sensitivity test FAILED');
            showAdvisory('âŒ Double touch sensitivity test FAILED', 'error');
        }
    }, 300);
};

// Snake path money pulsing test function
window.testMoneyPulsing = function() {
    console.log('=== SNAKE PATH MONEY PULSING TEST ===');
    
    // Clear existing money and create test money
    snakePathMoney = {};
    
    // Add test money at all allowed positions
    const testPositions = ['s8', 'TT18', 'u6'];
    testPositions.forEach((pos, index) => {
        const amount = (index + 1) * 500; // Â£500, Â£1000, Â£1500
        snakePathMoney[pos] = {
            amount: amount,
            collected: false,
            pulsePhase: 0
        };
        console.log(`ðŸ’° Added test money: ${pos} = Â£${amount}`);
    });
    
    // Update display to show pulsing money
    updateGameFrame();
    showAdvisory(`ðŸ’° Test money added with pulsing animation! Check positions: ${testPositions.join(', ')}`, 'success');
    
    console.log('âœ… Money pulsing test completed - money should be pulsing on the board');
};

// Comprehensive snake path money collection test
window.testSnakePathMoneyCollection = function() {
    console.log('=== SNAKE PATH MONEY COLLECTION TEST ===');
    
    if (!players || players.length === 0) {
        console.log('âŒ No players found - start a game first');
        showAdvisory('âŒ No players found - start a game first', 'error');
        return;
    }
    
    const testPlayer = players[0];
    const originalMoney = testPlayer.money;
    
    // Clear existing money and add test money at all positions
    snakePathMoney = {};
    const testPositions = ['s8', 'TT18', 'u6'];
    const testAmounts = [500, 1000, 1500];
    
    testPositions.forEach((pos, index) => {
        snakePathMoney[pos] = {
            amount: testAmounts[index],
            collected: false,
            pulsePhase: 0
        };
        console.log(`ðŸ’° Added test money: ${pos} = Â£${testAmounts[index]}`);
    });
    
    updateGameFrame();
    
    // Test 1: Simulate player landing on s8 (snakePath1)
    console.log('\n--- Test 1: Player landing on s8 (snakePath1) ---');
    testPlayer.currentSquare = 's8';
    testPlayer.currentPathKey = 'snakePath1';
    testPlayer.currentIndexOnPath = 7; // s8 is index 7 in snakePath1 (s1=0, s2=1, ..., s8=7)
    
    // Check if money collection logic would trigger
    if (snakePathMoney['s8'] && !snakePathMoney['s8'].collected) {
        console.log(`âœ… Money collection should trigger for ${testPlayer.name} on s8`);
        console.log(`  - Money available: Â£${snakePathMoney['s8'].amount}`);
        console.log(`  - Player money before: Â£${testPlayer.money}`);
        
        // Simulate collection
        testPlayer.money += snakePathMoney['s8'].amount;
        snakePathMoney['s8'].collected = true;
        console.log(`  - Player money after: Â£${testPlayer.money}`);
        console.log(`âœ… s8 money collection test PASSED`);
    } else {
        console.log(`âŒ s8 money collection test FAILED`);
    }
    
    // Test 2: Simulate player landing on TT18 (snakePath2)
    console.log('\n--- Test 2: Player landing on TT18 (snakePath2) ---');
    testPlayer.currentSquare = 'TT18';
    testPlayer.currentPathKey = 'snakePath2';
    testPlayer.currentIndexOnPath = 17; // TT18 is index 17 in snakePath2 (TT1=0, TT2=1, ..., TT18=17)
    
    if (snakePathMoney['TT18'] && !snakePathMoney['TT18'].collected) {
        console.log(`âœ… Money collection should trigger for ${testPlayer.name} on TT18`);
        console.log(`  - Money available: Â£${snakePathMoney['TT18'].amount}`);
        console.log(`  - Player money before: Â£${testPlayer.money}`);
        
        // Simulate collection
        testPlayer.money += snakePathMoney['TT18'].amount;
        snakePathMoney['TT18'].collected = true;
        console.log(`  - Player money after: Â£${testPlayer.money}`);
        console.log(`âœ… TT18 money collection test PASSED`);
    } else {
        console.log(`âŒ TT18 money collection test FAILED`);
    }
    
    // Test 3: Simulate player landing on u6 (uPath)
    console.log('\n--- Test 3: Player landing on u6 (uPath) ---');
    testPlayer.currentSquare = 'u6';
    testPlayer.currentPathKey = 'uPath';
    testPlayer.currentIndexOnPath = 5; // u6 is index 5 in uPath (u1=0, u2=1, ..., u6=5)
    
    if (snakePathMoney['u6'] && !snakePathMoney['u6'].collected) {
        console.log(`âœ… Money collection should trigger for ${testPlayer.name} on u6`);
        console.log(`  - Money available: Â£${snakePathMoney['u6'].amount}`);
        console.log(`  - Player money before: Â£${testPlayer.money}`);
        
        // Simulate collection
        testPlayer.money += snakePathMoney['u6'].amount;
        snakePathMoney['u6'].collected = true;
        console.log(`  - Player money after: Â£${testPlayer.money}`);
        console.log(`âœ… u6 money collection test PASSED`);
    } else {
        console.log(`âŒ u6 money collection test FAILED`);
    }
    
    // Summary
    const totalCollected = testPlayer.money - originalMoney;
    console.log(`\n=== TEST SUMMARY ===`);
    console.log(`ðŸ’° Original money: Â£${originalMoney}`);
    console.log(`ðŸ’° Final money: Â£${testPlayer.money}`);
    console.log(`ðŸ’° Total collected: Â£${totalCollected}`);
    console.log(`ðŸ’° Expected total: Â£${testAmounts.reduce((sum, amt) => sum + amt, 0)}`);
    
    if (totalCollected === testAmounts.reduce((sum, amt) => sum + amt, 0)) {
        console.log(`âœ… ALL MONEY COLLECTION TESTS PASSED`);
        showAdvisory(`âœ… Snake path money collection test PASSED! Collected Â£${totalCollected}`, 'success');
    } else {
        console.log(`âŒ SOME MONEY COLLECTION TESTS FAILED`);
        showAdvisory(`âŒ Snake path money collection test FAILED! Only collected Â£${totalCollected}`, 'error');
    }
    
    updateGameFrame();
};



// Test function for gojail glow steal card bonus on b1 and l1
function testStealCardBonus() {
    console.log('=== STEAL CARD BONUS TEST (b1, l1 while gojail glows) ===');
    
    // Ensure we have players (both human and AI)
    if (players.length === 0) {
        console.log('No players found. Creating test players (human + AI)...');
        players.push({
            name: 'HumanPlayer',
            money: 16500,
            currentSquare: 'go',
            currentPathKey: 'gamePath',
            currentIndexOnPath: 0,
            x: 0,
            y: 0,
            size: 62,
            properties: [],
            isAI: false,
            bankrupt: false,
            tokenImage: 'assets/images/t1.png',
            tokenIndex: 0,
            inJail: false,
            jailTurns: 0,
            consecutiveDoubles: 0,
            stealCards: 0
        });
        
        players.push({
            name: 'AIPlayer',
            money: 16500,
            currentSquare: 'go',
            currentPathKey: 'gamePath',
            currentIndexOnPath: 0,
            x: 0,
            y: 0,
            size: 62,
            properties: [],
            isAI: true,
            bankrupt: false,
            tokenImage: 'assets/images/t2.png',
            tokenIndex: 1,
            inJail: false,
            jailTurns: 0,
            consecutiveDoubles: 0,
            stealCards: 0
        });
    }
    
    // Activate gojail glow
    console.log('ðŸŸ¢ Activating gojail glow...');
    activateGojailGlow();
    
    // Test human player on b1
    const humanPlayer = players.find(p => !p.isAI) || players[0];
    humanPlayer.currentSquare = 'b1';
    console.log(`ðŸ§‘ Testing human player ${humanPlayer.name} on b1...`);
    console.log(`Before: ${humanPlayer.name} has ${humanPlayer.stealCards} steal cards`);
    
    checkStealCardBonusPositions(humanPlayer).then(() => {
        console.log(`After: ${humanPlayer.name} has ${humanPlayer.stealCards} steal cards`);
        
        // Test AI player on l1
        const aiPlayer = players.find(p => p.isAI) || players[1] || players[0];
        aiPlayer.currentSquare = 'l1';
        console.log(`ðŸ¤– Testing AI player ${aiPlayer.name} on l1...`);
        console.log(`Before: ${aiPlayer.name} has ${aiPlayer.stealCards} steal cards`);
        
        return checkStealCardBonusPositions(aiPlayer);
    }).then(() => {
        const aiPlayer = players.find(p => p.isAI) || players[1] || players[0];
        console.log(`After: ${aiPlayer.name} has ${aiPlayer.stealCards} steal cards`);
        
        console.log('âœ… Test completed! Both human and AI players should have received steal cards.');
        console.log('Check the advisory messages and console logs above.');
    });
}

window.testStealCardBonus = testStealCardBonus;
window.testRentMessageTiming = testRentMessageTiming;
window.testT8ZapSound = testT8ZapSound;
window.testR5TeleportSound = testR5TeleportSound;
window.testYingyangProtection = testYingyangProtection;
window.testDoublesLogic = testDoublesLogic;
window.simulateDoubles = simulateDoubles;
window.testDicePulsing = testDicePulsing;
window.testRentCollection = testRentCollection;
window.testRentDeduction = testRentDeduction;
window.testNewRentSystem = testNewRentSystem;
window.testGojailJailSound = testGojailJailSound;

// Diagnostic function to help debug rent issues
function debugRentIssue() {
    console.log('=== RENT DEBUGGING DIAGNOSTIC ===');
    
    if (players.length === 0) {
        console.log('âŒ No players found! Game may not be initialized.');
        return;
    }
    
    console.log(`âœ… Found ${players.length} players:`);
    players.forEach((player, index) => {
        console.log(`   ${index}: ${player.name} - Â£${player.money} - Properties: [${player.properties.join(', ')}]`);
    });
    
    console.log('\n=== PROPERTY STATE SAMPLE ===');
    const sampleProperties = ['l1', 'l2', 'l3', 't1', 't2', 't3'];
    sampleProperties.forEach(prop => {
        if (propertyState[prop]) {
            console.log(`${prop}: owner=${propertyState[prop].owner || 'none'}, graveyards=${propertyState[prop].graveyards || 0}, crypt=${propertyState[prop].hasCrypt || false}`);
        } else {
            console.log(`${prop}: NOT FOUND in propertyState`);
        }
    });
    
    console.log('\n=== CURRENT PLAYER INFO ===');
    if (currentPlayerIndex >= 0 && currentPlayerIndex < players.length) {
        const currentPlayer = players[currentPlayerIndex];
        console.log(`Current player: ${currentPlayer.name}`);
        console.log(`Current square: ${currentPlayer.currentSquare}`);
        console.log(`Money: Â£${currentPlayer.money}`);
        
        // Check if current square has property info
        const propertyInfo = getPropertyInfo(currentPlayer.currentSquare);
        if (propertyInfo) {
            console.log(`âœ… Current square IS a property: ${getPropertyDisplayName(propertyInfo)}`);
            console.log(`   Owner: ${propertyInfo.state.owner || 'none'}`);
            console.log(`   Cost: Â£${propertyInfo.cost}`);
            
            if (propertyInfo.state.owner && propertyInfo.state.owner !== currentPlayer.name) {
                const rentInfo = calculateRent(propertyInfo);
                console.log(`   Expected rent: Â£${rentInfo.amount}`);
                console.log(`   Rent breakdown: ${rentInfo.breakdown.join(', ')}`);
                
                const owner = players.find(p => p.name.toLowerCase() === (propertyInfo.state.owner || '').toLowerCase());
                if (owner) {
                    console.log(`   âœ… Owner found in players array: ${owner.name} (Â£${owner.money})`);
                } else {
                    console.log(`   âŒ Owner NOT found in players array!`);
                }
            } else if (propertyInfo.state.owner && propertyInfo.state.owner.toLowerCase() === currentPlayer.name.toLowerCase()) {
                console.log(`   â„¹ï¸  Player owns this property - no rent to pay`);
            } else {
                console.log(`   â„¹ï¸  Property is unowned - no rent to pay`);
            }
        } else {
            console.log(`â„¹ï¸  Current square is NOT a property: ${currentPlayer.currentSquare}`);
        }
    } else {
        console.log('âŒ Invalid currentPlayerIndex!');
    }
    
    console.log('\n=== DIAGNOSTIC COMPLETE ===');
    console.log('To test rent manually, you can run:');
    console.log('1. testRentDeduction() - Tests rent deduction with mock data');
    console.log('2. testRentCollection() - Tests rent collection');
    console.log('3. Move a player to a property owned by another player and see if rent is deducted');
}

window.debugRentIssue = debugRentIssue;

// Test function for enhanced rent payment display
function testEnhancedRentDisplay() {
    console.log('=== TESTING ENHANCED RENT PAYMENT DISPLAY ===');
    
    if (players.length < 2) {
        console.log('âŒ Need at least 2 players to test rent payment display');
        return;
    }
    
    // Set up test scenario
    const owner = players[0];
    const renter = players[1];
    
    // Give owner a property
    const testProperty = 'l1';
    owner.properties.push(testProperty);
    propertyState[testProperty] = { owner: owner.name, graveyards: 0, hasCrypt: false };
    
    // Set initial money
    owner.money = 3000;
    renter.money = 2000;
    
    console.log('=== BEFORE RENT PAYMENT ===');
    console.log(`${owner.name} (owner) money: Â£${owner.money}`);
    console.log(`${renter.name} (renter) money: Â£${renter.money}`);
    
    // Simulate rent payment by calling handlePropertyLanding
    const propertyInfo = getPropertyInfo(testProperty);
    const rentInfo = calculateRent(propertyInfo);
    
    console.log(`Expected rent: Â£${rentInfo.amount}`);
    
    // Call handlePropertyLanding to trigger the enhanced display
    handlePropertyLanding(renter, propertyInfo);
    
    console.log('âœ… Enhanced rent payment display test completed');
    console.log('Check the advisory panel for the enhanced rent payment message with:');
    console.log('- Red highlighted rent amount with pulse animation');
    console.log('- Money transfer details showing before/after amounts');
    console.log('- Emojis and visual enhancements');
}

window.testEnhancedRentDisplay = testEnhancedRentDisplay;

// Test function for path exit with remaining movement
function testPathExitContinuedMovement() {
    console.log('=== TESTING PATH EXIT WITH CONTINUED MOVEMENT ===');
    
    if (players.length === 0) {
        console.log('âŒ Need at least 1 player to test path exit movement');
        return;
    }
    
    const player = players[0];
    
    // Test scenario 1: Player near end of snake path 1 with long roll
    console.log('\n--- Test 1: Snake Path 1 Exit with Remaining Movement ---');
    
    // Set player to near end of snake path 1
    player.currentPathKey = 'snakePath1';
    player.currentIndexOnPath = snakePath1.length - 2; // Near the end
    player.currentSquare = snakePath1[player.currentIndexOnPath];
    
    const nearEndPos = positionsMap.get(player.currentSquare);
    if (nearEndPos) {
        player.x = nearEndPos.x;
        player.y = nearEndPos.y;
    }
    
    console.log(`Player positioned at: ${player.currentSquare} (index ${player.currentIndexOnPath} on ${player.currentPathKey})`);
    console.log(`Snake path 1 length: ${snakePath1.length}`);
    console.log(`Steps to exit: ${snakePath1.length - 1 - player.currentIndexOnPath}`);
    
    // Simulate a roll of 5 (should exit path and continue 4 more steps on main board)
    const rollAmount = 5;
    console.log(`Simulating roll of ${rollAmount}`);
    console.log(`Expected: Exit to b1, then continue ${rollAmount - 1} more steps on main path`);
    
    // Call moveToken to test the new logic
    moveToken(player, rollAmount).then(() => {
        console.log(`Final position: ${player.currentSquare} on ${player.currentPathKey}`);
        console.log('âœ… Path exit with continued movement test completed');
        updateGameFrame();
    });
}

// Test function for path exit scenarios
function testAllPathExits() {
    console.log('=== TESTING ALL PATH EXIT SCENARIOS ===');
    
    if (players.length === 0) {
        console.log('âŒ Need at least 1 player to test path exits');
        return;
    }
    
    const player = players[0];
    
    console.log('Test scenarios:');
    console.log('1. Snake Path 1 â†’ exits to b1');
    console.log('2. Snake Path 2 â†’ exits to b9'); 
    console.log('3. U Path â†’ exits to r4');
    console.log('');
    console.log('Run testPathExitContinuedMovement() to test specific scenario');
    console.log('Or manually set player position and roll dice to test');
}

window.testPathExitContinuedMovement = testPathExitContinuedMovement;
window.testAllPathExits = testAllPathExits;

// Test function for doubles on special paths
function testDoublesOnSpecialPaths() {
    console.log('=== TESTING DOUBLES ON SPECIAL PATHS ===');
    
    if (players.length === 0) {
        console.log('âŒ Need at least 1 player to test doubles on special paths');
        return;
    }
    
    const player = players[0];
    
    console.log('\n--- Test 1: Doubles on Snake Path 1 ---');
    
    // Set player to middle of snake path 1
    player.currentPathKey = 'snakePath1';
    player.currentIndexOnPath = Math.floor(snakePath1.length / 2);
    player.currentSquare = snakePath1[player.currentIndexOnPath];
    
    const midPos = positionsMap.get(player.currentSquare);
    if (midPos) {
        player.x = midPos.x;
        player.y = midPos.y;
    }
    
    console.log(`Player positioned at: ${player.currentSquare} (index ${player.currentIndexOnPath} on ${player.currentPathKey})`);
    console.log('Expected: Rolling doubles should instantly transport to b1 (exit target)');
    
    // Simulate doubles by calling the function directly
    handleDoublesOnSpecialPath(player).then((result) => {
        if (result) {
            console.log(`âœ… Success: Player transported to ${player.currentSquare} on ${player.currentPathKey}`);
        } else {
            console.log('âŒ Failed: No transport occurred');
        }
        updateGameFrame();
    });
}

// Test function for 3 consecutive doubles
function testThreeConsecutiveDoubles() {
    console.log('=== TESTING 3 CONSECUTIVE DOUBLES (with 3doubles.mp3 sound) ===');
    
    if (players.length === 0) {
        console.log('âŒ Need at least 1 player to test 3 consecutive doubles');
        return;
    }
    
    const player = players[0];
    
    console.log(`Testing with: ${player.name}`);
    console.log('Simulating 3 consecutive doubles...');
    
    // Reset doubles state
    consecutiveDoublesCount = 0;
    lastRollWasDoubles = false;
    
    console.log(`Initial state: consecutiveDoublesCount = ${consecutiveDoublesCount}`);
    
    // Simulate first double
    consecutiveDoublesCount = 1;
    lastRollWasDoubles = true;
    console.log(`After 1st double: consecutiveDoublesCount = ${consecutiveDoublesCount}`);
    
    // Simulate second double
    consecutiveDoublesCount = 2;
    console.log(`After 2nd double: consecutiveDoublesCount = ${consecutiveDoublesCount}`);
    
    // Simulate third double - should trigger jail
    consecutiveDoublesCount = 3;
    console.log(`After 3rd double: consecutiveDoublesCount = ${consecutiveDoublesCount}`);
    console.log('Expected: Player should be sent to jail');
    
    if (consecutiveDoublesCount === 3) {
        console.log('âœ… 3 consecutive doubles detected - would send to jail');
        
        // Play 3 doubles sound
        playThreeDoublesSound().then(() => {
            return sendPlayerToJail(player);
        }).then(() => {
            consecutiveDoublesCount = 0;
            lastRollWasDoubles = false;
            console.log('âœ… Player sent to jail, doubles count reset');
            updateGameFrame();
        });
    }
}

// Test function for all doubles scenarios
function testAllDoublesRules() {
    console.log('=== TESTING ALL DOUBLES RULES ===');
    
    console.log('Available tests:');
    console.log('1. testDoublesOnSpecialPaths() - Test instant transport from special paths');
    console.log('2. testThreeConsecutiveDoubles() - Test jail for 3 consecutive doubles');
    console.log('');
    console.log('Rules implemented:');
    console.log('âœ… Doubles on snake path 1 â†’ instant transport to b1');
    console.log('âœ… Doubles on snake path 2 â†’ instant transport to b9');
    console.log('âœ… Doubles on U path â†’ instant transport to r4');
    console.log('âœ… 3 consecutive doubles â†’ sent to jail immediately');
}

window.testDoublesOnSpecialPaths = testDoublesOnSpecialPaths;
window.testThreeConsecutiveDoubles = testThreeConsecutiveDoubles;
window.testAllDoublesRules = testAllDoublesRules;

// Test function for steal card obtaining by passing Go 4 times
function testStealCardFromGo() {
    console.log('=== TESTING STEAL CARD FROM PASSING GO ===');
    
    if (players.length === 0) {
        console.log('Creating test player...');
        players = [{
            name: 'TestPlayer',
            money: 16500,
            properties: [],
            currentSquare: 'go',
            currentPathKey: 'gamePath',
            currentIndexOnPath: 0,
            x: 0,
            y: 0,
            isAI: false,
            bankrupt: false,
            stealCards: 0,
            goPassCount: 0
        }];
        currentPlayerIndex = 0;
    }
    
    const testPlayer = players[0];
    console.log(`Starting test with ${testPlayer.name}:`);
    console.log(`- Initial money: Â£${testPlayer.money}`);
    console.log(`- Initial steal cards: ${testPlayer.stealCards}`);
    console.log(`- Initial Go pass count: ${testPlayer.goPassCount}`);
    
    // Test passing Go multiple times
    console.log('\n--- Simulating passing Go 5 times ---');
    
    for (let i = 1; i <= 5; i++) {
        console.log(`\nPass ${i}:`);
        
        // Simulate the pass Go logic
        const oldMoney = testPlayer.money;
        const oldStealCards = testPlayer.stealCards;
        const oldPassCount = testPlayer.goPassCount;
        
        testPlayer.money += 250;
        testPlayer.goPassCount = (testPlayer.goPassCount || 0) + 1;
        
        // Check if player gets a steal card (every 4th pass)
        if (testPlayer.goPassCount % 4 === 0) {
            testPlayer.stealCards = (testPlayer.stealCards || 0) + 1;
            
            // Play steal award sound
            playStealAwardSound();
            
            console.log(`âœ… STEAL CARD EARNED! Pass #${testPlayer.goPassCount}`);
            console.log(`   Money: Â£${oldMoney} â†’ Â£${testPlayer.money} (+Â£250)`);
            console.log(`   Steal cards: ${oldStealCards} â†’ ${testPlayer.stealCards} (+1)`);
            console.log(`   Go passes: ${oldPassCount} â†’ ${testPlayer.goPassCount}`);
        } else {
            const remaining = 4 - (testPlayer.goPassCount % 4);
            console.log(`   Money: Â£${oldMoney} â†’ Â£${testPlayer.money} (+Â£250)`);
            console.log(`   Go passes: ${oldPassCount} â†’ ${testPlayer.goPassCount}`);
            console.log(`   ${remaining} more passes needed for next steal card`);
        }
    }
    
    console.log('\n--- Final Results ---');
    console.log(`Final money: Â£${testPlayer.money} (should be Â£${12000 + (5 * 250)})`);
    console.log(`Final steal cards: ${testPlayer.stealCards} (should be 1 after 5 passes)`);
    console.log(`Final Go pass count: ${testPlayer.goPassCount} (should be 5)`);
    
    // Verify results
    const expectedMoney = 13000 + (5 * 250);
    const expectedStealCards = Math.floor(5 / 4); // 1 steal card after 4 passes, 0 after 5
    const expectedPassCount = 5;
    
    console.log('\n--- Verification ---');
    console.log(`Money correct: ${testPlayer.money === expectedMoney ? 'âœ…' : 'âŒ'}`);
    console.log(`Steal cards correct: ${testPlayer.stealCards === expectedStealCards ? 'âœ…' : 'âŒ'}`);
    console.log(`Pass count correct: ${testPlayer.goPassCount === expectedPassCount ? 'âœ…' : 'âŒ'}`);
    
    if (testPlayer.money === expectedMoney && 
        testPlayer.stealCards === expectedStealCards && 
        testPlayer.goPassCount === expectedPassCount) {
        console.log('\nðŸŽ‰ ALL TESTS PASSED! Steal card system working correctly.');
    } else {
        console.log('\nâŒ SOME TESTS FAILED! Check the implementation.');
    }
    
    // Test ordinal suffix function
    console.log('\n--- Testing Ordinal Suffix Function ---');
    const testNumbers = [1, 2, 3, 4, 11, 12, 13, 21, 22, 23, 101, 102, 103];
    testNumbers.forEach(num => {
        const suffix = getOrdinalSuffix(num);
        console.log(`${num}${suffix}`);
    });
    
    updateInfoPanel();
    console.log('\n=== STEAL CARD TEST COMPLETED ===');
}

// Test function to simulate a full Go pass sequence with actual movement
function testFullGoPassSequence() {
    console.log('=== TESTING FULL GO PASS SEQUENCE ===');
    
    if (players.length === 0) {
        console.log('No players found. Please start a game first.');
        return;
    }
    
    const testPlayer = players[0];
    console.log(`Testing with ${testPlayer.name}`);
    
    // Move player to a position just before Go
    const goIndex = gamePath.indexOf('go');
    const beforeGoIndex = (goIndex - 1 + gamePath.length) % gamePath.length;
    const beforeGoSquare = gamePath[beforeGoIndex];
    
    console.log(`Moving ${testPlayer.name} to ${beforeGoSquare} (just before Go)`);
    
    testPlayer.currentSquare = beforeGoSquare;
    testPlayer.currentPathKey = 'gamePath';
    testPlayer.currentIndexOnPath = beforeGoIndex;
    
    const beforeGoPos = positionsMap.get(beforeGoSquare);
    if (beforeGoPos) {
        testPlayer.x = beforeGoPos.x;
        testPlayer.y = beforeGoPos.y;
    }
    
    console.log(`Current position: ${testPlayer.currentSquare} (index ${testPlayer.currentIndexOnPath})`);
    console.log(`Current steal cards: ${testPlayer.stealCards || 0}`);
    console.log(`Current Go pass count: ${testPlayer.goPassCount || 0}`);
    
    // Now move player 1 space to pass Go
    console.log('\nMoving 1 space to pass Go...');
    moveToken(testPlayer, 1).then(() => {
        console.log('Movement completed!');
        console.log(`New position: ${testPlayer.currentSquare}`);
        console.log(`New steal cards: ${testPlayer.stealCards || 0}`);
        console.log(`New Go pass count: ${testPlayer.goPassCount || 0}`);
        console.log('Check the advisory message for steal card notification!');
        updateGameFrame();
    });
    
    console.log('=== FULL GO PASS TEST INITIATED ===');
}

// Test function to simulate multiple Go passes quickly
function testMultipleGoPasses(numPasses = 3) {
    console.log(`=== TESTING ${numPasses} GO PASSES ===`);
    
    if (players.length === 0) {
        console.log('No players found. Please start a game first.');
        return;
    }
    
    const testPlayer = players[0];
    console.log(`Testing with ${testPlayer.name}`);
    console.log(`Initial state:`);
    console.log(`- Money: Â£${testPlayer.money}`);
    console.log(`- Steal cards: ${testPlayer.stealCards || 0}`);
    console.log(`- Go pass count: ${testPlayer.goPassCount || 0}`);
    
    // Position player just before Go
    const goIndex = gamePath.indexOf('go');
    const beforeGoIndex = (goIndex - 1 + gamePath.length) % gamePath.length;
    const beforeGoSquare = gamePath[beforeGoIndex];
    
    testPlayer.currentSquare = beforeGoSquare;
    testPlayer.currentPathKey = 'gamePath';
    testPlayer.currentIndexOnPath = beforeGoIndex;
    
    const beforeGoPos = positionsMap.get(beforeGoSquare);
    if (beforeGoPos) {
        testPlayer.x = beforeGoPos.x;
        testPlayer.y = beforeGoPos.y;
    }
    
    console.log(`\nPositioned at ${beforeGoSquare}, will pass Go ${numPasses} times...`);
    
    // Function to perform one pass
    async function performPass(passNumber) {
        console.log(`\n--- Pass ${passNumber} ---`);
        
        await moveToken(testPlayer, gamePath.length); // Full board loop
        
        console.log(`After pass ${passNumber}:`);
        console.log(`- Money: Â£${testPlayer.money}`);
        console.log(`- Steal cards: ${testPlayer.stealCards || 0}`);
        console.log(`- Go pass count: ${testPlayer.goPassCount || 0}`);
        
        if (passNumber < numPasses) {
            // Small delay between passes
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }
    
    // Perform all passes sequentially
    async function performAllPasses() {
        for (let i = 1; i <= numPasses; i++) {
            await performPass(i);
        }
        
        console.log(`\n=== FINAL RESULTS AFTER ${numPasses} PASSES ===`);
        console.log(`Money: Â£${testPlayer.money} (expected: Â£${testPlayer.money})`);
        console.log(`Steal cards: ${testPlayer.stealCards || 0} (expected: ${Math.floor(numPasses / 3)})`);
        console.log(`Go pass count: ${testPlayer.goPassCount || 0} (expected: ${numPasses})`);
        
        updateGameFrame();
        updateInfoPanel();
    }
    
    performAllPasses();
}

window.testStealCardFromGo = testStealCardFromGo;
window.testFullGoPassSequence = testFullGoPassSequence;
window.testMultipleGoPasses = testMultipleGoPasses;

// Test function for yingyang steal card system
async function testYingyangStealCard(numTests = 20) {
    console.log(`[testYingyangStealCard] Testing yingyang steal card system with ${numTests} attempts...`);
    
    const currentPlayer = players[currentPlayerIndex];
    if (!currentPlayer) {
        console.error('[testYingyangStealCard] No current player found');
        return;
    }
    
    // Record initial state
    const initialStealCards = currentPlayer.stealCards || 0;
    const initialMoney = currentPlayer.money;
    
    console.log(`[testYingyangStealCard] Initial state:`, {
        name: currentPlayer.name,
        money: initialMoney,
        stealCards: initialStealCards
    });
    
    let stealCardsEarned = 0;
    const results = [];
    
    // Perform multiple yingyang landings
    for (let i = 1; i <= numTests; i++) {
        console.log(`\n[testYingyangStealCard] Test ${i}/${numTests}:`);
        
        const beforeStealCards = currentPlayer.stealCards || 0;
        const beforeMoney = currentPlayer.money;
        
        // Trigger yingyang landing
        await handleYingyangLanding(currentPlayer);
        
        const afterStealCards = currentPlayer.stealCards || 0;
        const afterMoney = currentPlayer.money;
        
        const earnedStealCard = afterStealCards > beforeStealCards;
        const moneyChange = afterMoney - beforeMoney;
        
        if (earnedStealCard) {
            stealCardsEarned++;
        }
        
        results.push({
            test: i,
            earnedStealCard,
            moneyChange,
            totalStealCards: afterStealCards
        });
        
        console.log(`  Result: Steal card: ${earnedStealCard ? 'YES' : 'NO'}, Money change: ${moneyChange >= 0 ? '+' : ''}${moneyChange}`);
        
        // Brief pause between tests
        await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    // Calculate statistics
    const stealCardRate = (stealCardsEarned / numTests) * 100;
    const expectedRate = 14.3; // 1/7 â‰ˆ 14.3% expected
    const deviation = Math.abs(stealCardRate - expectedRate);
    
    console.log(`\n[testYingyangStealCard] RESULTS SUMMARY:`);
    console.log(`  Tests performed: ${numTests}`);
    console.log(`  Steal cards earned: ${stealCardsEarned}`);
    console.log(`  Actual rate: ${stealCardRate.toFixed(1)}%`);
    console.log(`  Expected rate: ${expectedRate}%`);
    console.log(`  Deviation: ${deviation.toFixed(1)}%`);
    console.log(`  Final steal cards: ${currentPlayer.stealCards || 0} (started with ${initialStealCards})`);
    
    // Analyze results
    if (deviation <= 10) {
        console.log(`  âœ… PASS: Rate is within acceptable range (Â±10%)`);
    } else if (deviation <= 20) {
        console.log(`  âš ï¸  CAUTION: Rate deviation is moderate (${deviation.toFixed(1)}%)`);
    } else {
        console.log(`  âŒ CONCERN: Rate deviation is high (${deviation.toFixed(1)}%)`);
    }
    
    console.log(`\n[testYingyangStealCard] Individual results:`, results);
    
    return {
        totalTests: numTests,
        stealCardsEarned,
        actualRate: stealCardRate,
        expectedRate,
        deviation,
        results
    };
}

window.testYingyangStealCard = testYingyangStealCard;

// Test function to verify new 4-pass steal card system
function testNewGoPassSystem() {
    console.log('=== TESTING NEW 4-PASS STEAL CARD SYSTEM ===');
    
    if (!players || players.length === 0) {
        console.error('No players found. Start a game first.');
        return;
    }
    
    const testPlayer = players[currentPlayerIndex];
    const initialMoney = testPlayer.money;
    const initialStealCards = testPlayer.stealCards || 0;
    const initialGoPassCount = testPlayer.goPassCount || 0;
    
    console.log('Initial state:', {
        player: testPlayer.name,
        money: initialMoney,
        stealCards: initialStealCards,
        goPassCount: initialGoPassCount
    });
    
    // Test 8 passes to see 2 steal cards earned
    console.log('\nSimulating 8 GO passes...');
    
    for (let i = 1; i <= 8; i++) {
        const beforeMoney = testPlayer.money;
        const beforeStealCards = testPlayer.stealCards || 0;
        const beforePassCount = testPlayer.goPassCount || 0;
        
        // Simulate passing GO
        testPlayer.money += 250;
        testPlayer.goPassCount = (testPlayer.goPassCount || 0) + 1;
        
        // Check for steal card (every 4th pass)
        let earnedStealCard = false;
        if (testPlayer.goPassCount % 4 === 0) {
            testPlayer.stealCards = (testPlayer.stealCards || 0) + 1;
            earnedStealCard = true;
            
            // Play steal award sound
            playStealAwardSound();
        }
        
        console.log(`Pass ${i}:`, {
            passCount: `${beforePassCount} â†’ ${testPlayer.goPassCount}`,
            money: `Â£${beforeMoney} â†’ Â£${testPlayer.money} (+Â£250)`,
            stealCards: `${beforeStealCards} â†’ ${testPlayer.stealCards || 0}`,
            earnedStealCard: earnedStealCard ? 'âœ… STEAL CARD!' : 'âŒ'
        });
    }
    
    const finalStealCards = testPlayer.stealCards || 0;
    const expectedStealCards = initialStealCards + Math.floor(8 / 4); // Should be +2
    const finalMoney = testPlayer.money;
    const expectedMoney = initialMoney + (8 * 250);
    
    console.log('\n=== RESULTS ===');
    console.log(`Steal cards: ${initialStealCards} â†’ ${finalStealCards} (expected: ${expectedStealCards})`);
    console.log(`Money: Â£${initialMoney} â†’ Â£${finalMoney} (expected: Â£${expectedMoney})`);
    console.log(`Go passes: ${initialGoPassCount} â†’ ${testPlayer.goPassCount} (expected: ${initialGoPassCount + 8})`);
    
    const stealCardsCorrect = finalStealCards === expectedStealCards;
    const moneyCorrect = finalMoney === expectedMoney;
    const passCountCorrect = testPlayer.goPassCount === (initialGoPassCount + 8);
    
    console.log('\n=== VALIDATION ===');
    console.log(`Steal cards correct: ${stealCardsCorrect ? 'âœ…' : 'âŒ'}`);
    console.log(`Money correct: ${moneyCorrect ? 'âœ…' : 'âŒ'}`);
    console.log(`Pass count correct: ${passCountCorrect ? 'âœ…' : 'âŒ'}`);
    
    if (stealCardsCorrect && moneyCorrect && passCountCorrect) {
        console.log('ðŸŽ‰ NEW 4-PASS SYSTEM WORKING CORRECTLY!');
        showAdvisory('4-pass steal card system test: âœ… PASSED!', 'info');
    } else {
        console.log('âŒ NEW 4-PASS SYSTEM HAS ISSUES!');
        showAdvisory('4-pass steal card system test: âŒ FAILED!', 'error');
    }
    
    updateInfoPanel();
    updateGameFrame();
    
    return {
        passed: stealCardsCorrect && moneyCorrect && passCountCorrect,
        results: {
            stealCards: { initial: initialStealCards, final: finalStealCards, expected: expectedStealCards },
            money: { initial: initialMoney, final: finalMoney, expected: expectedMoney },
            passCount: { initial: initialGoPassCount, final: testPlayer.goPassCount, expected: initialGoPassCount + 8 }
        }
    };
}

window.testNewGoPassSystem = testNewGoPassSystem;

// Test function to verify cave property functionality
function testCaveProperty() {
    console.log('=== TESTING CAVE PROPERTY (R3) ===');
    
    if (!players || players.length === 0) {
        console.error('No players found. Start a game first.');
        return;
    }
    
    const testPlayer = players[currentPlayerIndex];
    const caveSquare = 'r3';
    const cavePropertyInfo = getPropertyInfo(caveSquare);
    
    if (!cavePropertyInfo) {
        console.error('Cave property info not found!');
        return;
    }
    
    console.log('Cave property info:', cavePropertyInfo);
    console.log('Display name:', getPropertyDisplayName(cavePropertyInfo));
    console.log('Display name without number:', getPropertyDisplayNameWithoutNumber(cavePropertyInfo));
    
    // Test purchase cost
    console.log('\n--- Testing Purchase ---');
    console.log(`Purchase cost: Â£${cavePropertyInfo.cost} (expected: Â£250)`);
    console.log(`Cost correct: ${cavePropertyInfo.cost === 250 ? 'âœ…' : 'âŒ'}`);
    
    // Test rent calculation
    console.log('\n--- Testing Rent ---');
    const rentInfo = calculateRent(cavePropertyInfo);
    console.log(`Rent amount: Â£${rentInfo.amount} (expected: Â£500)`);
    console.log(`Rent correct: ${rentInfo.amount === 500 ? 'âœ…' : 'âŒ'}`);
    console.log('Rent breakdown:', rentInfo.breakdown);
    
    // Test development restriction
    console.log('\n--- Testing Development Restriction ---');
    
    // Temporarily assign cave to test player for development test
    const originalOwner = cavePropertyInfo.state.owner;
    cavePropertyInfo.state.owner = testPlayer.name;
    
    const canDevelop = canDevelopProperty(testPlayer, caveSquare);
    console.log(`Can develop cave: ${canDevelop} (expected: false)`);
    console.log(`Development restriction correct: ${!canDevelop ? 'âœ…' : 'âŒ'}`);
    
    const developmentCost = getDevelopmentCost(caveSquare);
    console.log(`Development cost: ${developmentCost} (expected: null)`);
    console.log(`Development cost correct: ${developmentCost === null ? 'âœ…' : 'âŒ'}`);
    
    // Restore original owner
    cavePropertyInfo.state.owner = originalOwner;
    
    // Test group info
    console.log('\n--- Testing Group Info ---');
    console.log(`Group: ${cavePropertyInfo.group} (expected: cave)`);
    console.log(`Group correct: ${cavePropertyInfo.group === 'cave' ? 'âœ…' : 'âŒ'}`);
    console.log(`Color: ${cavePropertyInfo.color} (expected: #8B4513)`);
    console.log(`Color correct: ${cavePropertyInfo.color === '#8B4513' ? 'âœ…' : 'âŒ'}`);
    
    // Test emoji
    const emoji = getGroupEmoji('cave');
    console.log(`Emoji: ${emoji} (expected: ðŸ•³ï¸)`);
    console.log(`Emoji correct: ${emoji === 'ðŸ•³ï¸' ? 'âœ…' : 'âŒ'}`);
    
    // Summary
    const allTestsPassed = 
        cavePropertyInfo.cost === 250 &&
        rentInfo.amount === 500 &&
        !canDevelop &&
        developmentCost === null &&
        cavePropertyInfo.group === 'cave' &&
        cavePropertyInfo.color === '#8B4513' &&
        emoji === 'ðŸ•³ï¸';
    
    console.log('\n=== CAVE PROPERTY TEST RESULTS ===');
    console.log(`Overall result: ${allTestsPassed ? 'âœ… ALL TESTS PASSED' : 'âŒ SOME TESTS FAILED'}`);
    
    if (allTestsPassed) {
        showAdvisory('Cave property test: âœ… ALL TESTS PASSED!', 'info');
    } else {
        showAdvisory('Cave property test: âŒ SOME TESTS FAILED!', 'error');
    }
    
    return {
        passed: allTestsPassed,
        results: {
            cost: cavePropertyInfo.cost,
            rent: rentInfo.amount,
            canDevelop: canDevelop,
            developmentCost: developmentCost,
            group: cavePropertyInfo.group,
            color: cavePropertyInfo.color,
            emoji: emoji
        }
    };
}

window.testCaveProperty = testCaveProperty;

// Test function to display crypts on properties
function testCryptDisplay() {
    console.log('=== TESTING CRYPT DISPLAY ===');
    
    if (players.length === 0) {
        console.log('No players found. Please start a game first.');
        return;
    }
    
    // List of properties to add crypts to for testing
    const testProperties = ['t1', 'b1', 'r3', 'l5', 't5', 'b5']; // Mix of different groups
    
    console.log('Adding crypts to test properties:', testProperties);
    
    testProperties.forEach(square => {
        if (propertyState[square]) {
            // Set property as owned by current player
            const currentPlayer = players[currentPlayerIndex];
            propertyState[square].owner = currentPlayer.name;
            
            // Add property to player's properties if not already there
            if (!currentPlayer.properties.includes(square)) {
                currentPlayer.properties.push(square);
            }
            
            // Add a crypt to the property
            propertyState[square].hasCrypt = true;
            propertyState[square].graveyards = 0; // Clear graveyards when crypt is built
            
            const propInfo = getPropertyInfo(square);
            const displayName = propInfo ? getPropertyDisplayNameWithoutNumber(propInfo) : square;
            console.log(`âœ… Added crypt to ${displayName} (${square})`);
        } else {
            console.log(`âŒ Property ${square} not found in propertyState`);
        }
    });
    
    // Update the game display
    updateGameFrame();
    updateInfoPanel();
    
    console.log('\n=== CRYPT DISPLAY TEST RESULTS ===');
    console.log('Crypts should now be visible on the board as ðŸ° icons');
    console.log('Properties with crypts:');
    
    testProperties.forEach(square => {
        const propInfo = getPropertyInfo(square);
        const displayName = propInfo ? getPropertyDisplayNameWithoutNumber(propInfo) : square;
        const state = propertyState[square];
        if (state && state.hasCrypt) {
            console.log(`  - ${displayName} (${square}): Owner: ${state.owner}, Crypt: âœ…`);
        }
    });
    
    console.log('\nCheck the game board to see the crypt icons!');
    console.log('Check the info panel to see crypts listed in property details!');
    
    // Show advisory message
    showAdvisory('Crypts added to test properties! Check the board and info panel.', 'info');
    
    // Sync to Firebase if in multiplayer mode
    if (isMultiplayerGame) {
        syncGameStateToFirebase();
    }
    
    console.log('=== CRYPT DISPLAY TEST COMPLETED ===');
}

// Test function to remove all crypts (cleanup)
function testRemoveCrypts() {
    console.log('=== REMOVING ALL CRYPTS ===');
    
    let cryptsRemoved = 0;
    
    // Remove all crypts from all properties
    Object.keys(propertyState).forEach(square => {
        if (propertyState[square].hasCrypt) {
            propertyState[square].hasCrypt = false;
            cryptsRemoved++;
            
            const propInfo = getPropertyInfo(square);
            const displayName = propInfo ? getPropertyDisplayNameWithoutNumber(propInfo) : square;
            console.log(`Removed crypt from ${displayName} (${square})`);
        }
    });
    
    console.log(`Total crypts removed: ${cryptsRemoved}`);
    
    // Update the game display
    updateGameFrame();
    updateInfoPanel();
    
    // Show advisory message
    showAdvisory(`Removed ${cryptsRemoved} crypts from the board.`, 'info');
    
    // Sync to Firebase if in multiplayer mode
    if (isMultiplayerGame) {
        syncGameStateToFirebase();
    }
    
    console.log('=== CRYPT REMOVAL COMPLETED ===');
}

// Test function to add crypts to specific property group
function testCryptsByGroup(groupName = 'demon') {
    console.log(`=== TESTING CRYPTS FOR ${groupName.toUpperCase()} GROUP ===`);
    
    if (players.length === 0) {
        console.log('No players found. Please start a game first.');
        return;
    }
    
    // Check if group exists
    if (!propertyGroups[groupName]) {
        console.log(`Group "${groupName}" not found. Available groups:`, Object.keys(propertyGroups));
        return;
    }
    
    const currentPlayer = players[currentPlayerIndex];
    const groupProperties = propertyGroups[groupName].positions;
    
    console.log(`Adding crypts to all ${groupName} properties:`, groupProperties);
    
    groupProperties.forEach(square => {
        // Set property as owned by current player
        propertyState[square].owner = currentPlayer.name;
        
        // Add property to player's properties if not already there
        if (!currentPlayer.properties.includes(square)) {
            currentPlayer.properties.push(square);
        }
        
        // Add a crypt to the property
        propertyState[square].hasCrypt = true;
        propertyState[square].graveyards = 0; // Clear graveyards when crypt is built
        
        const propInfo = getPropertyInfo(square);
        const displayName = propInfo ? getPropertyDisplayNameWithoutNumber(propInfo) : square;
        console.log(`âœ… Added crypt to ${displayName} (${square})`);
    });
    
    // Update the game display
    updateGameFrame();
    updateInfoPanel();
    
    console.log(`\n=== ${groupName.toUpperCase()} GROUP CRYPT TEST COMPLETED ===`);
    console.log(`All ${groupName} properties now have crypts!`);
    
    // Show advisory message
    showAdvisory(`All ${groupName} properties now have crypts! ðŸ°`, 'info');
    
    // Sync to Firebase if in multiplayer mode
    if (isMultiplayerGame) {
        syncGameStateToFirebase();
    }
}

// Test function to verify lightning strike logic on owned properties
function testLightningStrikeLogic() {
    console.log('=== TESTING LIGHTNING STRIKE LOGIC ===');
    
    if (players.length === 0) {
        console.log('No players found. Please start a game first.');
        return;
    }
    
    const currentPlayer = players[currentPlayerIndex];
    const testProperties = ['t1', 't2', 't3', 't4', 't5']; // Use 5 properties for different test scenarios
    
    console.log(`Setting up test properties for ${currentPlayer.name}...`);
    
    // Setup different property states for testing
    testProperties.forEach((prop, index) => {
        // Make sure property is owned by current player
        propertyState[prop].owner = currentPlayer.name;
        propertyState[prop].ownerColor = currentPlayer.color;
        
        // Add property to player's properties if not already there
        if (!currentPlayer.properties.includes(prop)) {
            currentPlayer.properties.push(prop);
        }
        
        // Set up different development states
        switch(index) {
            case 0: // t1: Property with crypt
                propertyState[prop].hasCrypt = true;
                propertyState[prop].graveyards = 0;
                console.log(`âœ… ${prop}: Set up with CRYPT`);
                break;
            case 1: // t2: Property with 4 graveyards
                propertyState[prop].hasCrypt = false;
                propertyState[prop].graveyards = 4;
                console.log(`âœ… ${prop}: Set up with 4 GRAVEYARDS`);
                break;
            case 2: // t3: Property with 2 graveyards
                propertyState[prop].hasCrypt = false;
                propertyState[prop].graveyards = 2;
                console.log(`âœ… ${prop}: Set up with 2 GRAVEYARDS`);
                break;
            case 3: // t4: Property with 1 graveyard
                propertyState[prop].hasCrypt = false;
                propertyState[prop].graveyards = 1;
                console.log(`âœ… ${prop}: Set up with 1 GRAVEYARD`);
                break;
            case 4: // t5: Property with no developments
                propertyState[prop].hasCrypt = false;
                propertyState[prop].graveyards = 0;
                console.log(`âœ… ${prop}: Set up with NO DEVELOPMENTS`);
                break;
        }
    });
    
    // Update display
    updateGameFrame();
    updateInfoPanel();
    
    console.log('\n=== TESTING LIGHTNING STRIKES ===');
    
    // Test each property
    testProperties.forEach(async (prop, index) => {
        const propInfo = getPropertyInfo(prop);
        const displayName = propInfo ? getPropertyDisplayNameWithoutNumber(propInfo) : prop;
        
        console.log(`\n--- Testing lightning strike on ${displayName} (${prop}) ---`);
        console.log(`Before: owner=${propertyState[prop].owner}, crypt=${propertyState[prop].hasCrypt}, graveyards=${propertyState[prop].graveyards}`);
        
        // Apply lightning strike
        const effectMessage = await applyLightningPropertyEffects(prop);
        
        console.log(`After: owner=${propertyState[prop].owner}, crypt=${propertyState[prop].hasCrypt}, graveyards=${propertyState[prop].graveyards}`);
        console.log(`Effect: ${effectMessage || 'No effect'}`);
        
        // Verify expected results
        switch(index) {
            case 0: // Crypt should become 4 graveyards
                const expected0 = !propertyState[prop].hasCrypt && propertyState[prop].graveyards === 4;
                console.log(`âœ… Expected: crypt removed, 4 graveyards added - ${expected0 ? 'PASS' : 'FAIL'}`);
                break;
            case 1: // 4 graveyards should become 3
                const expected1 = propertyState[prop].graveyards === 3;
                console.log(`âœ… Expected: 3 graveyards remaining - ${expected1 ? 'PASS' : 'FAIL'}`);
                break;
            case 2: // 2 graveyards should become 1
                const expected2 = propertyState[prop].graveyards === 1;
                console.log(`âœ… Expected: 1 graveyard remaining - ${expected2 ? 'PASS' : 'FAIL'}`);
                break;
            case 3: // 1 graveyard should become 0
                const expected3 = propertyState[prop].graveyards === 0 && propertyState[prop].owner;
                console.log(`âœ… Expected: 0 graveyards, still owned - ${expected3 ? 'PASS' : 'FAIL'}`);
                break;
            case 4: // No developments should lose ownership
                const expected4 = !propertyState[prop].owner;
                console.log(`âœ… Expected: ownership removed - ${expected4 ? 'PASS' : 'FAIL'}`);
                break;
        }
    });
    
    // Update display after all tests
    updateGameFrame();
    updateInfoPanel();
    
    console.log('\n=== LIGHTNING STRIKE LOGIC TEST COMPLETED ===');
    showAdvisory('Lightning strike logic test completed! Check console for results.', 'info');
}

// Test function to verify lightning strike corruption fixes
function testLightningCorruptionFixes() {
    console.log('=== TESTING LIGHTNING CORRUPTION FIXES ===');
    
    if (players.length === 0) {
        console.log('No players found. Please start a game first.');
        return;
    }
    
    const currentPlayer = players[currentPlayerIndex];
    const testProperty = 't1';
    
    console.log(`Testing corruption recovery for ${testProperty}...`);
    
    // Test 1: Corrupt property data
    console.log('\n--- Test 1: Corrupted Property Data ---');
    const originalData = propertyState[testProperty];
    console.log('Original data:', originalData);
    
    // Simulate corruption
    propertyState[testProperty] = null;
    console.log('Simulated corruption: set property data to null');
    
    // Try to apply lightning strike (should recover)
    applyLightningPropertyEffects(testProperty).then(result => {
        console.log('Recovery result:', result);
        console.log('Recovered data:', propertyState[testProperty]);
    });
    
    // Test 2: Invalid graveyards count
    console.log('\n--- Test 2: Invalid Graveyards Count ---');
    propertyState[testProperty] = {
        owner: currentPlayer.name,
        ownerColor: currentPlayer.color,
        graveyards: -5, // Invalid negative count
        hasCrypt: false,
        group: 'demon',
        declined: false
    };
    console.log('Set invalid graveyards count: -5');
    
    applyLightningPropertyEffects(testProperty).then(result => {
        console.log('Sanitization result:', result);
        console.log('Sanitized data:', propertyState[testProperty]);
    });
    
    // Test 3: Invalid crypt status
    console.log('\n--- Test 3: Invalid Crypt Status ---');
    propertyState[testProperty] = {
        owner: currentPlayer.name,
        ownerColor: currentPlayer.color,
        graveyards: 2,
        hasCrypt: "invalid", // Invalid non-boolean
        group: 'demon',
        declined: false
    };
    console.log('Set invalid crypt status: "invalid"');
    
    applyLightningPropertyEffects(testProperty).then(result => {
        console.log('Sanitization result:', result);
        console.log('Sanitized data:', propertyState[testProperty]);
    });
    
    // Restore original data
    setTimeout(() => {
        propertyState[testProperty] = originalData;
        updateGameFrame();
        updateInfoPanel();
        console.log('\n=== CORRUPTION FIXES TEST COMPLETED ===');
        console.log('Original property data restored');
        showAdvisory('Lightning corruption fixes test completed! Check console for results.', 'info');
    }, 3000);
}

// Test function to verify develop button timer persistence
function testDevelopButtonTimer() {
    console.log('=== TESTING DEVELOP BUTTON TIMER PERSISTENCE ===');
    
    if (players.length === 0) {
        console.log('No players found. Please start a game first.');
        return;
    }
    
    const currentPlayer = players[currentPlayerIndex];
    const testProperty = 't1';
    
    // Set up a property with development potential
    propertyState[testProperty].owner = currentPlayer.name;
    propertyState[testProperty].ownerColor = currentPlayer.color;
    propertyState[testProperty].graveyards = 0;
    propertyState[testProperty].hasCrypt = false;
    
    if (!currentPlayer.properties.includes(testProperty)) {
        currentPlayer.properties.push(testProperty);
    }
    
    console.log('âœ… Set up test property for development');
    
    // Start a develop timer
    startAutoActionTimer('develop');
    console.log('âœ… Started develop timer');
    
    // Simulate multiple updateInfoPanel calls (like Firebase syncs would do)
    let callCount = 0;
    const testInterval = setInterval(() => {
        callCount++;
        console.log(`ðŸ“± Simulating updateInfoPanel call #${callCount} (like Firebase sync)`);
        
        // Get property info for the test property
        const propertyInfo = getPropertyInfo(testProperty);
        updateInfoPanel(null, null, propertyInfo);
        
        if (callCount >= 5) {
            clearInterval(testInterval);
            console.log('\n=== DEVELOP BUTTON TIMER TEST COMPLETED ===');
            console.log('Check console logs above to see if timer was restarted multiple times');
            console.log('âœ… PASS: Timer should NOT restart if already running');
            console.log('âŒ FAIL: Timer restarts on each updateInfoPanel call');
            showAdvisory('Develop button timer test completed! Check console for results.', 'info');
        }
    }, 2000); // Every 2 seconds for 10 seconds total
}

// Test function to debug AI bot room auto-start issues
function testAIBotRoomAutoStart() {
    console.log('=== TESTING AI BOT ROOM AUTO-START ===');
    
    // Test the auto-start logic with mock data
    const mockGameStates = [
        {
            name: 'Room with AI bots and human player',
            gameState: {
                gameStarted: false,
                maxPlayers: 3,
                aiBots: 2,
                players: [
                    { name: 'Human Player', isAI: false, isHost: true },
                    { name: 'AI Player 1', isAI: true, isHost: false },
                    { name: 'AI Player 2', isAI: true, isHost: false }
                ]
            }
        },
        {
            name: 'Room with only AI bots (should not start)',
            gameState: {
                gameStarted: false,
                maxPlayers: 2,
                aiBots: 2,
                players: [
                    { name: 'AI Player 1', isAI: true, isHost: false },
                    { name: 'AI Player 2', isAI: true, isHost: false }
                ]
            }
        },
        {
            name: 'Full room without AI bots',
            gameState: {
                gameStarted: false,
                maxPlayers: 2,
                aiBots: 0,
                players: [
                    { name: 'Human Player 1', isAI: false, isHost: true },
                    { name: 'Human Player 2', isAI: false, isHost: false }
                ]
            }
        }
    ];
    
    mockGameStates.forEach(({ name, gameState }) => {
        console.log(`\n--- Testing: ${name} ---`);
        console.log('Game state:', gameState);
        
        // Test the auto-start logic
        const effectiveMaxPlayers = gameState.maxPlayers || 2;
        const hasAIBots = gameState.aiBots > 0;
        const hasHumanPlayer = gameState.players.some(p => !p.isAI);
        
        const shouldAutoStart = !gameState.gameStarted && (
            gameState.players.length >= effectiveMaxPlayers ||
            (hasAIBots && hasHumanPlayer)
        );
        
        console.log('Auto-start analysis:', {
            gameStarted: gameState.gameStarted,
            playersLength: gameState.players.length,
            effectiveMaxPlayers: effectiveMaxPlayers,
            hasAIBots: hasAIBots,
            hasHumanPlayer: hasHumanPlayer,
            shouldAutoStart: shouldAutoStart
        });
        
        console.log(`Result: ${shouldAutoStart ? 'âœ… SHOULD AUTO-START' : 'âŒ Should NOT auto-start'}`);
    });
    
    console.log('\n=== AI BOT ROOM AUTO-START TEST COMPLETED ===');
    showAdvisory('AI bot room auto-start test completed! Check console for results.', 'info');
}

// Make test functions available globally
window.testCryptDisplay = testCryptDisplay;
window.testLightningStrikeLogic = testLightningStrikeLogic;
window.testLightningCorruptionFixes = testLightningCorruptionFixes;
window.testDevelopButtonTimer = testDevelopButtonTimer;
window.testAIBotRoomAutoStart = testAIBotRoomAutoStart;
window.testRemoveCrypts = testRemoveCrypts;
window.testCryptsByGroup = testCryptsByGroup;

// Test function to demonstrate player colors and star property display
function testPlayerColorsAndStars() {
    console.log('=== TESTING PLAYER COLORS AND STAR PROPERTY DISPLAY ===');
    
    if (players.length === 0) {
        console.log('No players found. Please start a game first.');
        return;
    }
    
    // Assign colors to players if they don't have them
    console.log('Ensuring all players have colors assigned...');
    assignPlayerColors(players);
    
    // Display player colors
    console.log('Player Colors:');
    players.forEach((player, index) => {
        console.log(`${index + 1}. ${player.name}: ${player.colorName} (${player.color})`);
    });
    
    // Purchase some properties for different players to test star display
    const testPurchases = [
        { player: 0, property: 't1' },
        { player: 1, property: 'b1' },
        { player: 0, property: 'r3' },
        { player: 1, property: 'l5' }
    ];
    
    console.log('\\nSimulating property purchases to test star display:');
    testPurchases.forEach(purchase => {
        if (purchase.player < players.length) {
            const player = players[purchase.player];
            const propertyInfo = getPropertyInfo(purchase.property);
            
            if (propertyInfo) {
                // Set property as owned
                propertyState[purchase.property] = {
                    owner: player.name,
                    ownerColor: player.color,
                    graveyards: 0,
                    hasCrypt: false,
                    group: propertyInfo.group
                };
                
                // Add to player's properties
                if (!player.properties.includes(purchase.property)) {
                    player.properties.push(purchase.property);
                }
                
                console.log(`${player.name} (${player.colorName}) purchased ${purchase.property}`);
            }
        }
    });
    
    console.log('\\nâœ… Property purchases completed!');
    console.log('ðŸŒŸ Check the board - properties should now show colored stars with rent costs!');
    console.log('ðŸ‘¥ Check the UserIDs panel - players should show their assigned colors!');
    
    // Show what rent costs should be displayed
    console.log('\\nExpected rent costs:');
    testPurchases.forEach(purchase => {
        if (purchase.player < players.length) {
            const propertyInfo = getPropertyInfo(purchase.property);
            if (propertyInfo) {
                const rentCost = calculateRent(propertyInfo);
                console.log(`${purchase.property}: Â£${rentCost} (${propertyInfo.group} group)`);
            }
        }
    });
    
    // Force a game frame update to show the changes
    if (typeof updateGameFrame === 'function') {
        updateGameFrame();
    }
    
    // Update UserIDs panel if visible
    if (typeof updateUserIDsPanel === 'function') {
        updateUserIDsPanel(players);
    }
    
    console.log('\\nðŸ” Check the browser console for debug info about property colors and rent calculations.');
}

// Debug function to check and fix player colors
function debugPlayerColors() {
    console.log('ðŸ” Debug: Current player colors');
    console.log('Players array:', players.map(p => ({
        name: p.name,
        color: p.color,
              colorName: p.colorName,
          hasColor: !!p.color
     })));
    
    // Check if colors need to be assigned
    const playersWithoutColors = players.filter(p => !p.color);
    if (playersWithoutColors.length > 0) {
        console.log('âš ï¸ Players without colors:', playersWithoutColors.map(p => p.name));
        console.log('Assigning colors now...');
        assignPlayerColors(players);
        console.log('âœ… Colors assigned:', players.map(p => ({
            name: p.name,
            color: p.color,
            colorName: p.colorName
        })));
    } else {
        console.log('âœ… All players have colors assigned');
    }
    
    // Check property ownership colors
    console.log('ðŸ  Property ownership colors:');
    Object.keys(propertyState).forEach(prop => {
        const state = propertyState[prop];
        if (state.owner) {
            console.log(`${prop}: owned by ${state.owner}, color: ${state.ownerColor || 'MISSING'}`);
        }
    });
    
    // Fix any missing property colors
    ensurePropertyColors();
    
    // Force update
    updateGameFrame();
    updateUserIDsPanel(players);
    
    console.log('ðŸŽ¨ Color debug completed - check the board now!');
}

// Test function to demonstrate steal card functionality
function testStealCard() {
    console.log('ðŸƒ Testing steal card functionality');
    
    if (players.length === 0) {
        console.log('No players found. Please start a game first.');
        return;
    }
    
    // Check if positionsMap is available
    if (!positionsMap || positionsMap.size === 0) {
        console.error('âŒ positionsMap not available! This is likely the cause of steal card issues.');
        console.log('Attempting to reload positions...');
        loadPositions().then(() => {
            console.log('âœ… Positions reloaded successfully');
            setPositionsMap(positionsMap);
            console.log('You can now try the steal card system again');
        }).catch(error => {
            console.error('âŒ Failed to reload positions:', error);
        });
        return;
    }
    
    console.log('âœ… positionsMap is available with', positionsMap.size, 'entries');
    
    // Give ALL players steal cards for testing
    let stealCardsGiven = 0;
    players.forEach((player, index) => {
        if (player && !player.bankrupt) {
            const cardsToGive = 3;
            player.stealCards = (player.stealCards || 0) + cardsToGive;
            stealCardsGiven += cardsToGive;
            
            console.log(`âœ… Gave ${player.name} ${cardsToGive} steal cards (total: ${player.stealCards}) ${player.isAI ? '(AI)' : '(Human)'}`);
        }
    });
    
    // Play steal award sound
    playStealAwardSound();
    
    console.log(`ðŸŽ¯ Total steal cards distributed: ${stealCardsGiven} cards to ${players.filter(p => p && !p.bankrupt).length} players`);
    
    // Set up some properties for other players to steal
    const testProperties = ['t1', 'b1', 'r3'];
    let propertyIndex = 0;
    
    players.forEach(player => {
        if (player.name !== humanPlayer.name && propertyIndex < testProperties.length) {
            const prop = testProperties[propertyIndex];
            
            // Set property as owned by another player
            propertyState[prop].owner = player.name;
            propertyState[prop].ownerColor = player.color || getPlayerColor(player.name);
            
            // Add to other player's properties
            if (!player.properties.includes(prop)) {
                player.properties.push(prop);
            }
            
            console.log(`ðŸ“ Set ${prop} as owned by ${player.name} for testing`);
            propertyIndex++;
        }
    });
    
    // Update displays
    updateGameFrame();
    updateInfoPanel();
    updateUserIDsPanel(players);
    
    console.log('ðŸŽ¯ Test setup complete! Instructions:');
    console.log('1. ALL players now have steal cards (shown in green in the info panel)');
    console.log('2. Double-click (desktop) or double-tap (mobile) on any owned property to steal it');
    console.log('3. Properties with colored stars are owned and can be stolen');
    console.log('4. You can only steal during your turn');
    console.log('5. Each steal uses one steal card');
    console.log('6. Both human and AI players can now use steal cards');
    console.log('');
    console.log('ðŸ’¡ To test steal cards during purchase decisions:');
    console.log('   Run testStealCardsDuringPurchaseDecision() instead');
    
    const activePlayerCount = players.filter(p => p && !p.bankrupt).length;
    showAdvisory(`ALL ${activePlayerCount} PLAYERS received 3 STEAL CARDS! Double-click any owned property to steal it!`, 'turn');
    
    // Sync to Firebase if multiplayer
    if (isMultiplayerGame) {
        syncGameStateToFirebase();
    }
}

// Enhanced test function to give all players steal cards
function testStealCardsAllPlayers(cardsPerPlayer = 3) {
    console.log('ðŸƒ GIVING ALL PLAYERS STEAL CARDS');
    console.log('=================================');
    
    if (!players || players.length === 0) {
        console.error('âŒ No players found. Start a game first.');
        return false;
    }
    
    let totalCardsGiven = 0;
    let playersUpdated = 0;
    
    console.log(`Giving ${cardsPerPlayer} steal cards to each active player...`);
    
    players.forEach((player, index) => {
        if (player && !player.bankrupt) {
            const previousCards = player.stealCards || 0;
            player.stealCards = previousCards + cardsPerPlayer;
            totalCardsGiven += cardsPerPlayer;
            playersUpdated++;
            
            console.log(`âœ… ${player.name}: ${previousCards} â†’ ${player.stealCards} steal cards ${player.isAI ? '(AI)' : '(Human)'}`);
        } else if (player && player.bankrupt) {
            console.log(`â­ï¸ ${player.name}: Skipped (bankrupt)`);
        }
    });
    
    // Play steal award sound
    playStealAwardSound();
    
    console.log('');
    console.log('ðŸ“Š SUMMARY:');
    console.log(`   Players updated: ${playersUpdated}/${players.length}`);
    console.log(`   Total cards given: ${totalCardsGiven}`);
    console.log(`   Cards per player: ${cardsPerPlayer}`);
    
    // Update displays
    updateGameFrame();
    updateInfoPanel();
    if (typeof updateBottomPlayerDisplay === 'function') {
        updateBottomPlayerDisplay();
    }
    
    console.log('');
    console.log('ðŸŽ¯ USAGE INSTRUCTIONS:');
    console.log('   - Human players: Double-click on any owned property to steal it');
    console.log('   - AI players: Will automatically use steal cards during their turns');
    console.log('   - Steal cards are shown in green in the player info panel');
    console.log('   - You can only steal during your own turn');
    
    showAdvisory(`ALL ${playersUpdated} PLAYERS received ${cardsPerPlayer} STEAL CARDS each!`, 'turn');
    
    // Sync to Firebase if multiplayer
    if (isMultiplayerGame) {
        syncGameStateToFirebase();
    }
    
    return true;
}

// Test function for music states
function testMusicStates() {
    console.log('ðŸŽµ Testing music states');
    console.log('Current state:', currentMusicState);

    console.log('Cycling through all states...');
    const totalStates = 11; // Off + 10 music tracks
    for (let i = 0; i < totalStates; i++) {
        setTimeout(() => {
            cycleMusicState();
            if (i === totalStates - 1) {
                console.log('âœ… Music state test completed');
            }
        }, i * 1000);
    }
}

window.debugPlayerColors = debugPlayerColors;
window.testPlayerColorsAndStars = testPlayerColorsAndStars;

// Debug functions for token color issues
window.debugTokenOutlines = function() {
    console.log('=== TOKEN OUTLINE DEBUG ===');
    if (typeof players !== 'undefined' && players) {
        players.forEach((player, index) => {
            console.log(`Player ${index + 1}: ${player.name}`);
            console.log(`  Color: ${player.color || 'MISSING'}`);
            console.log(`  ColorName: ${player.colorName || 'MISSING'}`);
            console.log(`  IsAI: ${player.isAI}`);
            console.log(`  Expected outline: ${player.color || (player.isAI ? 'Red' : 'Green')}`);
            console.log('---');
        });
        
        // Force a re-render to see current state
        if (typeof updateGameFrame === 'function') {
            console.log('Forcing game frame update...');
            updateGameFrame();
        }
    } else {
        console.log('Players array not available');
    }
};

window.forceColorAssignment = function() {
    console.log('=== FORCING COLOR ASSIGNMENT ===');
    if (typeof players !== 'undefined' && players && typeof assignPlayerColors === 'function') {
        console.log('Before assignment:');
        players.forEach((p, i) => console.log(`  Player ${i}: ${p.name} - ${p.color}`));
        
        assignPlayerColors(players);
        
        console.log('After assignment:');
        players.forEach((p, i) => console.log(`  Player ${i}: ${p.name} - ${p.color}`));
        
        if (typeof updateGameFrame === 'function') {
            updateGameFrame();
        }
        if (typeof updateInfoPanel === 'function') {
            updateInfoPanel();
        }
    } else {
        console.log('Players array or assignPlayerColors function not available');
    }
};

// Test function to give current player lightning bolts
window.testLightningBolts = function(count = 1) {
    const currentPlayer = players[currentPlayerIndex];
    if (!currentPlayer) {
        console.log('No current player found');
        return;
    }
    
    currentPlayer.lightningBolts = (currentPlayer.lightningBolts || 0) + count;
    console.log(`âš¡ Gave ${currentPlayer.name} ${count} lightning bolt(s). Total: ${currentPlayer.lightningBolts}`);
    
    // Update displays
    updateInfoPanel();
    if (typeof updateBottomPlayerDisplay === 'function') {
        updateBottomPlayerDisplay();
    }
    
    showAdvisory(`âš¡ ${currentPlayer.name} received ${count} lightning bolt${count > 1 ? 's' : ''}! Total: ${currentPlayer.lightningBolts}`, 'turn');
};

// Emergency function to reset stuck turn state
window.resetTurnState = function() {
    console.log('ðŸš¨ Emergency turn state reset triggered');
    turnInProgress = false;
    isDiceRollInProgress = false;
    isDiceClickHandlerRunning = false;
    takeTurnCompleted = false;
    window.lastTurnStartTime = null;
    
    // Clear any pending timeouts
    if (typeof clearTimeout !== 'undefined') {
        clearTimeout(takeTurnTimeout);
        clearTimeout(window.autoActionTimer);
    }
    
    // Re-enable dice
    const diceSection = document.querySelector('.dice-section');
    if (diceSection) {
        diceSection.style.pointerEvents = 'auto';
        diceSection.classList.remove('dice-processing');
        diceSection.style.opacity = '';
    }
    
    console.log('âœ… Turn state reset complete - dice should be clickable now');
    showAdvisory('Turn state reset - you can now roll the dice', 'info');
};

// Automatic turn state monitor to prevent deadlocks
function startTurnStateMonitor() {
    if (window.turnStateMonitorInterval) {
        clearInterval(window.turnStateMonitorInterval);
    }
    
    window.turnStateMonitorInterval = setInterval(() => {
        // Only check if we're in a multiplayer game and it's our turn
        if (isMultiplayerGame && players && players.length > 1 && currentPlayerIndex >= 0) {
            const currentPlayer = players[currentPlayerIndex];
            const localPlayer = getLocalPlayer();
            
            if (currentPlayer && localPlayer && currentPlayer.userId === localPlayer.userId) {
                // It's our turn, check if we're stuck
                if (turnInProgress && window.lastTurnStartTime) {
                    const timeSinceStart = Date.now() - window.lastTurnStartTime;
                    if (timeSinceStart > 15000) { // 15 seconds
                        console.log('ðŸ”„ Auto-detected stuck turn state, resetting...');
                        window.resetTurnState();
                    }
                }
            }
        }
    }, 5000); // Check every 5 seconds
}

// Start the monitor when the game loads
if (typeof window !== 'undefined') {
    setTimeout(startTurnStateMonitor, 2000);
}

// Test function to verify dice color system
window.testDiceColors = function() {
    console.log('=== TESTING DICE COLOR SYSTEM ===');
    
    // Ensure we have players
    if (!players || players.length === 0) {
        console.log('No players found, creating test players...');
        window.createEmergencyPlayers();
    }
    
    const diceSection = document.getElementById('dice-section');
    if (!diceSection) {
        console.log('âŒ Dice section not found');
        return;
    }
    
    console.log('Testing dice colors for each player:');
    
    players.forEach((player, index) => {
        console.log(`\n--- Testing Player ${index + 1}: ${player.name} ---`);
        console.log(`Player color: ${player.color} (${player.colorName})`);
        
        // Set current player
        currentPlayerIndex = index;
        
        // Test helper functions
        const pulseClass = getPlayerDicePulseClassByPlayer(player);
        console.log(`Expected pulse class: ${pulseClass}`);
        
        // Apply the pulse class
        removeAllDicePulseClasses(diceSection);
        diceSection.classList.add(pulseClass);
        
        console.log(`Applied classes: ${Array.from(diceSection.classList).join(', ')}`);
        
        // Wait a moment to see the effect
        setTimeout(() => {
            if (index === players.length - 1) {
                console.log('\nâœ… Dice color test completed! Check the dice pulsing colors.');
                console.log('The dice should now be pulsing with the last player\'s color.');
            }
        }, 1000);
    });
    
    console.log('\n=== END DICE COLOR TEST ===');
};

window.createEmergencyPlayers = function() {
    console.log('=== CREATING EMERGENCY PLAYERS ===');
    
    // Create basic player structure for testing
    const emergencyPlayers = [
        {
            name: 'Player 1',
            userId: 'emergency_1',
            isAI: false,
            isHost: true,
            x: 0, y: 0,
            currentSquare: 'go',
            size: 62,
            money: 16500,
            properties: [],
            bankrupt: false,
            isCurrentPlayer: true,
            stealCards: 0,
            goPassCount: 0
        },
        {
            name: 'Player 2', 
            userId: 'emergency_2',
            isAI: false,
            isHost: false,
            x: 0, y: 0,
            currentSquare: 'go',
            size: 62,
            money: 16500,
            properties: [],
            bankrupt: false,
            isCurrentPlayer: false,
            stealCards: 0,
            goPassCount: 0
        }
    ];
    
    // Assign colors
    assignPlayerColors(emergencyPlayers);
    
    // Set as global players
    window.players = emergencyPlayers;
    players = emergencyPlayers;
    
    console.log('Emergency players created:');
    players.forEach((p, i) => console.log(`  Player ${i}: ${p.name} - ${p.color} (${p.colorName})`));
    
    // Update game systems
    if (typeof setPlayers === 'function') {
        setPlayers(players);
    }
    if (typeof updateGameFrame === 'function') {
        updateGameFrame();
    }
    if (typeof updateInfoPanel === 'function') {
        updateInfoPanel();
    }
    
    console.log('âœ… Emergency players setup complete! Token colors should now work.');
};
window.testStealCard = testStealCard;
window.testStealCardsAllPlayers = testStealCardsAllPlayers;

// Diagnostic function to check steal card system health
function diagnoseStealCardSystem() {
    console.log('ðŸ” STEAL CARD SYSTEM DIAGNOSTIC');
    console.log('=================================');
    
    // Check basic game state
    console.log('1. Basic Game State:');
    console.log('   - Players:', players.length);
    console.log('   - Current player index:', currentPlayerIndex);
    console.log('   - Current player:', players[currentPlayerIndex]?.name || 'None');
    console.log('   - Is multiplayer:', isMultiplayerGame);
    
    // Check positionsMap
    console.log('\n2. Positions Map:');
    if (!positionsMap) {
        console.log('   âŒ positionsMap is null');
    } else if (positionsMap.size === 0) {
        console.log('   âŒ positionsMap is empty');
    } else {
        console.log('   âœ… positionsMap has', positionsMap.size, 'entries');
        // Check a few key properties
        const testProps = ['t1', 'b1', 'r1', 'l1'];
        testProps.forEach(prop => {
            const pos = positionsMap.get(prop);
            console.log(`   - ${prop}:`, pos ? `(${pos.x}, ${pos.y})` : 'NOT FOUND');
        });
    }
    
    // Check propertyState
    console.log('\n3. Property State:');
    const ownedProperties = Object.entries(propertyState).filter(([key, prop]) => prop.owner);
    console.log('   - Total properties:', Object.keys(propertyState).length);
    console.log('   - Owned properties:', ownedProperties.length);
    
    if (ownedProperties.length > 0) {
        console.log('   - Sample owned properties:');
        ownedProperties.slice(0, 5).forEach(([key, prop]) => {
            console.log(`     * ${key}: owned by ${prop.owner} (color: ${prop.ownerColor})`);
        });
    }
    
    // Check current player's steal cards
    console.log('\n4. Current Player Steal Cards:');
    const currentPlayer = players[currentPlayerIndex];
    if (currentPlayer) {
        console.log('   - Player:', currentPlayer.name);
        console.log('   - Steal cards:', currentPlayer.stealCards || 0);
        console.log('   - Properties owned:', currentPlayer.properties?.length || 0);
        console.log('   - Is AI:', currentPlayer.isAI);
    } else {
        console.log('   âŒ No current player found');
    }
    
    // Check for potential issues
    console.log('\n5. Potential Issues:');
    const issues = [];
    
    if (!positionsMap || positionsMap.size === 0) {
        issues.push('positionsMap not loaded - steal cards cannot find property positions');
    }
    
    if (ownedProperties.length === 0) {
        issues.push('No properties are owned - nothing to steal');
    }
    
    if (currentPlayer && currentPlayer.isAI) {
        issues.push('Current player is AI - steal cards only work for human players');
    }
    
    if (currentPlayer && (currentPlayer.stealCards || 0) === 0) {
        issues.push('Current player has no steal cards');
    }
    
    if (issues.length === 0) {
        console.log('   âœ… No obvious issues detected');
    } else {
        issues.forEach(issue => console.log(`   âŒ ${issue}`));
    }
    
    console.log('\n6. Recommendations:');
    if (!positionsMap || positionsMap.size === 0) {
        console.log('   - Try: loadPositions().then(() => setPositionsMap(positionsMap))');
    }
    if (ownedProperties.length === 0) {
        console.log('   - Try: testStealCard() to set up test properties');
    }
    if (currentPlayer && (currentPlayer.stealCards || 0) === 0) {
        console.log('   - Try: players[currentPlayerIndex].stealCards = 3');
    }
    
    console.log('=================================');
    return {
        hasPositionsMap: !!(positionsMap && positionsMap.size > 0),
        hasOwnedProperties: ownedProperties.length > 0,
        currentPlayerStealCards: currentPlayer?.stealCards || 0,
        isCurrentPlayerHuman: currentPlayer && !currentPlayer.isAI,
        issues: issues
    };
}

// Comprehensive diagnostic function for steal card system
function diagnoseStealCardIssues() {
    console.log('ðŸ” STEAL CARD SYSTEM DIAGNOSIS');
    console.log('==============================');
    
    const issues = [];
    const warnings = [];
    
    // Check basic game state
    if (!players || players.length === 0) {
        issues.push('No players found - game not started');
        return { issues, warnings };
    }
    
    const currentPlayer = players[currentPlayerIndex];
    if (!currentPlayer) {
        issues.push('Current player not found');
        return { issues, warnings };
    }
    
    // Find human player for more relevant diagnostics
    const humanPlayer = players.find(p => !p.isAI);
    const playerToCheck = humanPlayer || currentPlayer; // Use human player if available, otherwise current player
    
    console.log('Current player:', currentPlayer.name, currentPlayer.isAI ? '(AI)' : '(Human)');
    console.log('Human player:', humanPlayer ? humanPlayer.name : 'None found');
    console.log('Checking steal cards for:', playerToCheck.name);
    console.log('Is AI:', playerToCheck.isAI);
    console.log('Steal cards:', playerToCheck.stealCards);
    console.log('Is multiplayer game:', isMultiplayerGame);
    console.log('Is AI turn:', isAITurn);
    
    // Check steal card availability
    if (playerToCheck.stealCards <= 0) {
        warnings.push(`${playerToCheck.name} has no steal cards`);
        console.log('ðŸ’¡ To get steal cards:');
        console.log('   - Pass GO 4 times (currently passed:', playerToCheck.goPassCount || 0, 'times)');
        console.log('   - Land on The Witches Grave');
    }
    
    // Check positionsMap
    if (!positionsMap || positionsMap.size === 0) {
        issues.push('positionsMap not available - this will prevent steal cards from working');
    } else {
        console.log('âœ… positionsMap available with', positionsMap.size, 'entries');
    }
    
    // Check multiplayer turn validation
    if (isMultiplayerGame) {
        const playerName = document.getElementById('player1-name').value.trim() || window.localPlayerName || '';
        const isMyTurn = currentPlayer.name.toLowerCase() === playerName.toLowerCase();
        console.log('Your name:', playerName);
        console.log('Current player name:', currentPlayer.name);
        console.log('Is your turn:', isMyTurn);
        
        if (!isMyTurn) {
            warnings.push('Not your turn in multiplayer - wait for your turn to steal');
        }
        
        // Also check if the player we're testing is the human player
        if (humanPlayer && humanPlayer.name.toLowerCase() === playerName.toLowerCase()) {
            console.log('âœ… You are the human player that would use steal cards');
        }
    }
    
    // Check for stealable properties
    let stealableCount = 0;
    players.forEach(player => {
        if (player.name !== playerToCheck.name && player.properties && player.properties.length > 0) {
            stealableCount += player.properties.length;
        }
    });
    
    console.log('Stealable properties available:', stealableCount);
    if (stealableCount === 0) {
        warnings.push('No properties available to steal - other players need to own properties first');
    }
    
    // Warn if we're testing an AI player
    if (playerToCheck.isAI && humanPlayer) {
        warnings.push('Currently testing AI player - use testAIStealCards() for AI testing or switch to human player turn');
    }
    
    // Check if player has pending purchase decision
    const playerPropertyInfo = getPropertyInfo(playerToCheck.currentSquare);
    const hasPendingPurchase = playerPropertyInfo && !playerPropertyInfo.state.owner && !playerToCheck.isAI;
    if (hasPendingPurchase) {
        console.log('âœ… Player has pending purchase decision - steal cards should still work!');
        console.log('   Property:', playerPropertyInfo.name);
        console.log('   ðŸ’¡ You can use steal cards even with purchase decisions pending');
    }
    
    // Check if player has pending development decision
    const canDevelop = playerPropertyInfo && playerPropertyInfo.state.owner === playerToCheck.name && !playerToCheck.isAI;
    if (canDevelop) {
        console.log('âœ… Player has pending development decision - steal cards should still work!');
        console.log('   Property:', playerPropertyInfo.name);
        console.log('   ðŸ’¡ You can use steal cards even with development decisions pending');
    }
    
    // Check if player is in jail
    if (playerToCheck.inJail) {
        warnings.push(`${playerToCheck.name} is in jail - steal cards may not work while jailed`);
    }
    
    // Check if it's the player's turn
    if (currentPlayerIndex !== players.indexOf(playerToCheck)) {
        warnings.push(`Not ${playerToCheck.name}'s turn - steal cards only work on your turn`);
    }
    
    // Check if game is in a valid state for stealing
    if (gameState !== 'playing') {
        warnings.push(`Game state is '${gameState}' - steal cards only work during normal gameplay`);
    }
    
    // Check if there are any active animations or delays
    if (isAnimating || isProcessingTurn) {
        warnings.push('Game is currently processing - wait for animations to complete before using steal cards');
    }
    
    // Summary
    console.log('\nðŸ“Š DIAGNOSIS SUMMARY:');
    console.log('Issues found:', issues.length);
    console.log('Warnings found:', warnings.length);
    
    if (issues.length > 0) {
        console.log('\nâŒ CRITICAL ISSUES:');
        issues.forEach(issue => console.log('   -', issue));
    }
    
    if (warnings.length > 0) {
        console.log('\nâš ï¸  WARNINGS:');
        warnings.forEach(warning => console.log('   -', warning));
    }
    
    if (issues.length === 0 && warnings.length === 0) {
        console.log('\nâœ… No issues found - steal card system should work properly');
    }
    
    return { issues, warnings };
}

window.diagnoseStealCardIssues = diagnoseStealCardIssues;

// Debug function specifically for multiplayer steal card issues
function debugMultiplayerStealCards() {
    console.log('ðŸŽ¯ MULTIPLAYER STEAL CARD DEBUG');
    console.log('===============================');
    
    if (!isMultiplayerGame) {
        console.log('âŒ Not in multiplayer mode');
        return;
    }
    
    const currentPlayer = players[currentPlayerIndex];
    const inputPlayerName = document.getElementById('player1-name')?.value?.trim() || '';
    const localPlayerName = window.localPlayerName || '';
    
    console.log('ðŸ“Š PLAYER INFO:');
    console.log(`   Current player: "${currentPlayer?.name}" (${currentPlayer?.isAI ? 'AI' : 'Human'})`);
    console.log(`   Current player index: ${currentPlayerIndex}`);
    console.log(`   Current player has steal cards: ${currentPlayer?.stealCards || 0}`);
    console.log(`   Current player is host: ${currentPlayer?.isHost}`);
    
    console.log('ðŸ“Š LOCAL PLAYER INFO:');
    console.log(`   Input field name: "${inputPlayerName}"`);
    console.log(`   Local player name: "${localPlayerName}"`);
    console.log(`   Is host: ${isHost}`);
    
    console.log('ðŸ“Š VALIDATION CHECKS:');
    const nameMatch1 = currentPlayer?.name?.toLowerCase() === inputPlayerName.toLowerCase();
    const nameMatch2 = currentPlayer?.name?.toLowerCase() === localPlayerName.toLowerCase();
    const hostMatch = currentPlayer?.isHost === isHost;
    
    console.log(`   Name match (input): ${nameMatch1} ("${currentPlayer?.name}" vs "${inputPlayerName}")`);
    console.log(`   Name match (local): ${nameMatch2} ("${currentPlayer?.name}" vs "${localPlayerName}")`);
    console.log(`   Host status match: ${hostMatch} (${currentPlayer?.isHost} vs ${isHost})`);
    
    const wouldPass = (nameMatch1 && inputPlayerName) || (nameMatch2 && localPlayerName) || (hostMatch && (inputPlayerName || localPlayerName));
    console.log(`   Would steal validation pass: ${wouldPass ? 'âœ…' : 'âŒ'}`);
    
    if (!wouldPass) {
        console.log('');
        console.log('ðŸ”§ POTENTIAL FIXES:');
        if (!inputPlayerName && !localPlayerName) {
            console.log('   - Player name not set. Try entering your name in the input field.');
        } else if (currentPlayer?.name && !nameMatch1 && !nameMatch2) {
            console.log('   - Name mismatch. Try:');
            console.log(`     window.localPlayerName = "${currentPlayer.name}"`);
            console.log(`     document.getElementById('player1-name').value = "${currentPlayer.name}"`);
        } else if (!hostMatch) {
            console.log('   - Host status mismatch. This might be a synchronization issue.');
        }
    }
    
    console.log('');
    console.log('ðŸŽ¯ ALL PLAYERS:');
    players.forEach((player, index) => {
        const isCurrent = index === currentPlayerIndex;
        console.log(`   ${isCurrent ? 'â†’' : ' '} ${player.name} (${player.isAI ? 'AI' : 'Human'}, ${player.isHost ? 'Host' : 'Guest'}) - ${player.stealCards || 0} steal cards`);
    });
}

window.debugMultiplayerStealCards = debugMultiplayerStealCards;

// Function to fix multiplayer player name synchronization issues
function fixMultiplayerPlayerNames() {
    console.log('ðŸ”§ FIXING MULTIPLAYER PLAYER NAMES');
    console.log('===================================');
    
    if (!isMultiplayerGame) {
        console.log('âŒ Not in multiplayer mode');
        return false;
    }
    
    const currentPlayer = players[currentPlayerIndex];
    if (!currentPlayer) {
        console.log('âŒ No current player found');
        return false;
    }
    
    const inputField = document.getElementById('player1-name');
    let fixed = false;
    
    console.log(`Current player: "${currentPlayer.name}"`);
    console.log(`Input field: "${inputField?.value || 'empty'}"`);
    console.log(`Local player name: "${window.localPlayerName || 'empty'}"`);
    
    // Fix 1: Set local player name to match current player
    if (!window.localPlayerName || window.localPlayerName !== currentPlayer.name) {
        console.log(`ðŸ”§ Setting window.localPlayerName to "${currentPlayer.name}"`);
        window.localPlayerName = currentPlayer.name;
        fixed = true;
    }
    
    // Fix 2: Set input field to match current player
    if (inputField && (!inputField.value || inputField.value.trim() !== currentPlayer.name)) {
        console.log(`ðŸ”§ Setting input field to "${currentPlayer.name}"`);
        inputField.value = currentPlayer.name;
        fixed = true;
    }
    
    // Fix 3: Try to match by host status if names don't match
    const playerByHost = players.find(p => p.isHost === isHost);
    if (playerByHost && playerByHost.name !== currentPlayer.name) {
        console.log(`ðŸ”§ Found player by host status: "${playerByHost.name}" (you are ${isHost ? 'host' : 'guest'})`);
        window.localPlayerName = playerByHost.name;
        if (inputField) inputField.value = playerByHost.name;
        fixed = true;
    }
    
    if (fixed) {
        console.log('âœ… Player name synchronization fixed!');
        console.log('ðŸŽ¯ You should now be able to use steal cards');
        
        // Update displays to reflect changes
        updateInfoPanel();
        
        return true;
    } else {
        console.log('âœ… Player names already synchronized correctly');
        return true;
    }
}

window.fixMultiplayerPlayerNames = fixMultiplayerPlayerNames;

// Add debug function to diagnose canvas issues
window.debugCanvasIssues = function() {
    console.log('ðŸ” CANVAS DEBUG DIAGNOSIS');
    console.log('==========================');
    
    console.log('Global canvas variable:', !!canvas);
    console.log('Global canvas dimensions:', canvas ? `${canvas.width}x${canvas.height}` : 'N/A');
    
    const canvasesInDOM = document.querySelectorAll('canvas');
    console.log('Canvases in DOM:', canvasesInDOM.length);
    
    canvasesInDOM.forEach((canvasEl, index) => {
        console.log(`Canvas ${index}:`, {
            id: canvasEl.id || 'no-id',
            width: canvasEl.width,
            height: canvasEl.height,
            parent: canvasEl.parentElement?.id || 'no-parent-id',
            visible: canvasEl.offsetWidth > 0 && canvasEl.offsetHeight > 0
        });
    });
    
    const gameContainer = document.getElementById('game-container');
    console.log('Game container:', {
        exists: !!gameContainer,
        id: gameContainer?.id,
        children: gameContainer?.children?.length || 0,
        visible: gameContainer?.offsetWidth > 0 && gameContainer?.offsetHeight > 0
    });
    
    if (gameContainer) {
        console.log('Game container children:');
        Array.from(gameContainer.children).forEach((child, index) => {
            console.log(`  Child ${index}:`, {
                tagName: child.tagName,
                id: child.id || 'no-id',
                className: child.className || 'no-class'
            });
        });
    }
    
    console.log('Game initialization state:', {
        isGameInitialized,
        isInitializing,
        positionsMap: !!positionsMap,
        positionsMapSize: positionsMap?.size || 0
    });
    
    return {
        globalCanvas: !!canvas,
        canvasesInDOM: canvasesInDOM.length,
        gameContainerExists: !!gameContainer
    };
};

// TEST FUNCTION: Test multiplayer property development
window.testMultiplayerPropertyDevelopment = function() {
    console.log('ðŸ§ª TESTING MULTIPLAYER PROPERTY DEVELOPMENT');
    
    if (!isMultiplayerGame) {
        console.error('âŒ This test requires a multiplayer game. Start a multiplayer game first.');
        return;
    }
    
    if (!players || players.length < 2) {
        console.error('âŒ Need at least 2 players for multiplayer test');
        return;
    }
    
    const currentPlayer = players[currentPlayerIndex];
    if (!currentPlayer) {
        console.error('âŒ No current player found');
        return;
    }
    
    console.log('ðŸŽ® Test Setup:', {
        isMultiplayerGame: isMultiplayerGame,
        currentPlayerIndex: currentPlayerIndex,
        currentPlayerName: currentPlayer.name,
        localPlayerName: window.localPlayerName,
        playersCount: players.length
    });
    
    // Test 1: Give current player some properties and money
    console.log('ðŸ“ Test 1: Setting up test properties...');
    
    // Give player money for development
    currentPlayer.money = 5000;
    
    // Give player a complete property set (blood group: t5, b5, b6, l2, l4)
    const testProperties = ['t5', 'b5', 'b6', 'l2', 'l4'];
    currentPlayer.properties = [...testProperties];
    
    // Set property ownership
    testProperties.forEach(square => {
        propertyState[square].owner = currentPlayer.name;
        propertyState[square].ownerColor = currentPlayer.color;
        propertyState[square].graveyards = 0;
        propertyState[square].hasCrypt = false;
    });
    
    console.log('âœ… Test setup complete:', {
        playerMoney: currentPlayer.money,
        playerProperties: currentPlayer.properties,
        propertyOwnership: testProperties.map(sq => ({
            square: sq,
            owner: propertyState[sq].owner,
            canDevelop: canDevelopProperty(currentPlayer, sq)
        }))
    });
    
    // Test 2: Test canDevelopProperty function
    console.log('ðŸ“ Test 2: Testing canDevelopProperty function...');
    const testSquare = 't5';
    const canDevelop = canDevelopProperty(currentPlayer, testSquare);
    const devCost = getDevelopmentCost(testSquare);
    
    console.log('ðŸ” Development test results:', {
        testSquare: testSquare,
        canDevelop: canDevelop,
        developmentCost: devCost,
        playerCanAfford: currentPlayer.money >= (devCost?.cost || 0)
    });
    
    // Test 3: Test multiplayer validation
    console.log('ðŸ“ Test 3: Testing multiplayer validation...');
    console.log('ðŸ” Multiplayer validation data:', {
        activePlayer: players[currentPlayerIndex],
        activePlayerName: players[currentPlayerIndex]?.name,
        localPlayerName: window.localPlayerName,
        playerNameInput: document.getElementById('player1-name')?.value,
        isMyTurn: players[currentPlayerIndex]?.name?.toLowerCase() === window.localPlayerName?.toLowerCase()
    });
    
    // Test 4: Simulate development attempt
    console.log('ðŸ“ Test 4: Simulating property development...');
    if (canDevelop && devCost) {
        console.log('ðŸŽ¯ Attempting to develop property via handlePropertyDevelopment...');
        try {
            handlePropertyDevelopment(testSquare, currentPlayerIndex);
            console.log('âœ… Development function called successfully');
        } catch (error) {
            console.error('âŒ Development function failed:', error);
        }
    } else {
        console.warn('âš ï¸ Cannot test development - prerequisites not met');
    }
    
    // Test 5: Update UI to show changes
    console.log('ðŸ“ Test 5: Updating UI...');
    updateGameFrame();
    updateInfoPanel();
    updateBottomPlayerDisplay();
    
    console.log('ðŸ Test complete! Check the UI for property development options.');
    
    return {
        testPassed: canDevelop && devCost && currentPlayer.money >= devCost.cost,
        playerSetup: {
            name: currentPlayer.name,
            money: currentPlayer.money,
            properties: currentPlayer.properties.length
        },
        developmentTest: {
            canDevelop: canDevelop,
            cost: devCost?.cost,
            type: devCost?.type
        }
    };
};

// TEST FUNCTION: Reset test state
window.resetPropertyTest = function() {
    console.log('ðŸ”„ RESETTING PROPERTY TEST STATE');
    
    if (!players || players.length === 0) {
        console.error('âŒ No players to reset');
        return;
    }
    
    // Reset all property ownership
    Object.keys(propertyState).forEach(square => {
        propertyState[square].owner = null;
        propertyState[square].ownerColor = null;
        propertyState[square].graveyards = 0;
        propertyState[square].hasCrypt = false;
    });
    
    // Reset player properties and money
    players.forEach(player => {
        player.properties = [];
        player.money = 1650; // Starting money
    });
    
    // Update UI
    updateGameFrame();
    updateInfoPanel();
    updateBottomPlayerDisplay();
    
    console.log('âœ… Test state reset complete');
};

// Function to validate and fix property state integrity
function validateAndFixPropertyState() {
    console.log('ðŸ”§ [validatePropertyState] Checking property state integrity...');
    
    let fixedCount = 0;
    
    Object.entries(propertyState).forEach(([square, state]) => {
        let needsUpdate = false;
        
        // Ensure hasCrypt is boolean
        if (typeof state.hasCrypt !== 'boolean') {
            console.warn(`ðŸ”§ Fixing hasCrypt type for ${square}: ${state.hasCrypt} -> false`);
            state.hasCrypt = false;
            needsUpdate = true;
        }
        
        // Ensure graveyards is a valid number
        if (typeof state.graveyards !== 'number' || state.graveyards < 0 || state.graveyards > 4) {
            console.warn(`ðŸ”§ Fixing graveyards for ${square}: ${state.graveyards} -> 0`);
            state.graveyards = 0;
            needsUpdate = true;
        }
        
        // If has crypt, graveyards should be 0
        if (state.hasCrypt && state.graveyards > 0) {
            console.warn(`ðŸ”§ Fixing graveyards for crypt property ${square}: ${state.graveyards} -> 0`);
            state.graveyards = 0;
            needsUpdate = true;
        }
        
        // Ensure group is set
        if (!state.group) {
            const foundGroup = Object.entries(propertyGroups).find(([groupName, groupInfo]) => 
                groupInfo.positions.includes(square)
            );
            if (foundGroup) {
                state.group = foundGroup[0];
                console.log(`ðŸ”§ Fixed missing group for ${square}: ${state.group}`);
                needsUpdate = true;
            }
        }
        
        if (needsUpdate) {
            fixedCount++;
        }
    });
    
    if (fixedCount > 0) {
        console.log(`ðŸ”§ [validatePropertyState] Fixed ${fixedCount} property state issues`);
        updateGameFrame();
        
        // Sync fixes to Firebase
        if (isMultiplayerGame) {
            syncGameStateToFirebase();
        }
    } else {
        console.log('ðŸ”§ [validatePropertyState] Property state integrity OK');
    }
    
    return fixedCount;
}

// Function to backup and restore crypt state
function backupCryptState() {
    const cryptBackup = {};
    Object.entries(propertyState).forEach(([square, state]) => {
        if (state?.hasCrypt) {
            cryptBackup[square] = {
                hasCrypt: true,
                owner: state.owner,
                ownerColor: state.ownerColor,
                graveyards: state.graveyards
            };
        }
    });
    console.log('ðŸ° Backed up crypt state:', cryptBackup);
    return cryptBackup;
}

function restoreCryptState(cryptBackup) {
    let restoredCount = 0;
    Object.entries(cryptBackup).forEach(([square, backupState]) => {
        if (propertyState[square] && !propertyState[square].hasCrypt) {
            console.log(`ðŸ° Restoring lost crypt for ${square}`);
            propertyState[square].hasCrypt = true;
            propertyState[square].graveyards = 0;
            restoredCount++;
        }
    });
    
    if (restoredCount > 0) {
        console.log(`ðŸ° Restored ${restoredCount} lost crypts`);
        updateGameFrame();
        
        // Sync the restoration to Firebase
        if (isMultiplayerGame) {
            syncGameStateToFirebase();
        }
    }
    
    return restoredCount;
}

// Debug function to check current crypt status
function debugCryptStatus() {
    console.log('ðŸ° === CURRENT CRYPT STATUS ===');
    
    const cryptProperties = [];
    Object.entries(propertyState).forEach(([square, state]) => {
        if (state?.hasCrypt) {
            const propInfo = getPropertyInfo(square);
            const displayName = propInfo ? getPropertyDisplayNameWithoutNumber(propInfo) : square;
            cryptProperties.push({
                square,
                displayName,
                owner: state.owner,
                ownerColor: state.ownerColor
            });
        }
    });
    
    if (cryptProperties.length === 0) {
        console.log('ðŸ° No crypts found on the board');
    } else {
        console.log(`ðŸ° Found ${cryptProperties.length} crypts:`);
        cryptProperties.forEach(prop => {
            console.log(`  - ${prop.displayName} (${prop.square}): owned by ${prop.owner}`);
        });
    }
    
    return cryptProperties;
}

// Export debug functions to window for console access
window.validateAndFixPropertyState = validateAndFixPropertyState;
window.backupCryptState = backupCryptState;
window.restoreCryptState = restoreCryptState;
window.debugCryptStatus = debugCryptStatus;

// Export ambient sound functions to window for console access
window.startAmbientSounds = startAmbientSounds;
window.stopAmbientSounds = stopAmbientSounds;
window.toggleAmbientSounds = toggleAmbientSounds;
window.debugAmbientSounds = debugAmbientSounds;

// Function to force canvas reinitialization
window.forceCanvasReinit = async function() {
    console.log('ðŸ”„ FORCING CANVAS REINITIALIZATION');
    
    // Reset initialization flags
    isGameInitialized = false;
    isInitializing = false;
    
    // Clear global canvas variable
    canvas = null;
    ctx = null;
    
    // Remove all existing canvases
    const allCanvases = document.querySelectorAll('canvas');
    console.log('Removing', allCanvases.length, 'existing canvases');
    allCanvases.forEach(canvasEl => canvasEl.remove());
    
    // Reinitialize game
    try {
        await initGame();
        console.log('âœ… Canvas reinitialization completed');
        return true;
    } catch (error) {
        console.error('âŒ Canvas reinitialization failed:', error);
        return false;
    }
};

// Simple test function to enable steal card testing
function enableStealCardTesting() {
    console.log('ðŸŽ® ENABLING STEAL CARD TESTING');
    console.log('===============================');
    
    if (!players || players.length === 0) {
        console.error('No players found. Start a game first.');
        return false;
    }
    
    // Find the first human player (not AI) to give steal cards to
    const humanPlayer = players.find(p => !p.isAI);
    if (!humanPlayer) {
        console.error('âŒ No human player found. This test is designed for human players.');
        console.log('ðŸ’¡ If you want to test AI steal cards, use testAIStealCards() instead');
        return false;
    }
    
    // Give human player steal cards
    humanPlayer.stealCards = Math.max(3, humanPlayer.stealCards || 0);
    
    // Play steal award sound
    playStealAwardSound();
    
    console.log(`âœ… Gave ${humanPlayer.name} (human) steal cards (total: ${humanPlayer.stealCards})`);
    
    // Set up test properties for other players
    const availableProperties = ['t1', 't2', 't3', 'b1', 'b2', 'b3', 'r1', 'r2', 'r3'];
    let propertiesSet = 0;
    
    for (let i = 0; i < players.length && propertiesSet < 3; i++) {
        const player = players[i];
        if (player.name !== humanPlayer.name && availableProperties.length > 0) {
            const property = availableProperties.shift();
            
            // Set property as owned
            propertyState[property].owner = player.name;
            propertyState[property].ownerColor = player.color || getPlayerColor(player.name);
            
            // Add to player's properties if not already there
            if (!player.properties.includes(property)) {
                player.properties.push(property);
            }
            
            console.log(`ðŸ“ Set ${property} as owned by ${player.name}`);
            propertiesSet++;
        }
    }
    
    // Update displays
    updateGameFrame();
    updateInfoPanel();
    
    console.log('ðŸŽ¯ Test setup complete!');
    console.log('ðŸ‘† Instructions:');
    console.log('  1. Double-click on any property with a colored star to steal it');
    console.log('  2. Each steal uses one steal card');
    console.log('  3. You can only steal properties owned by other players');
    console.log('  4. You can only steal during your turn');
    
    showAdvisory(`${humanPlayer.name} received STEAL CARDS! Double-click any owned property to steal it!`, 'turn');
    
    return true;
}

window.enableStealCardTesting = enableStealCardTesting;

// Test function to verify steal cards work during purchase decisions
function testStealCardsDuringPurchaseDecision() {
    console.log('ðŸ§ª TESTING STEAL CARDS DURING PURCHASE DECISION');
    console.log('==============================================');
    
    if (!players || players.length === 0) {
        console.error('âŒ No players found. Start a game first.');
        return false;
    }
    
    // Find the first human player (not AI) to give steal cards to
    const humanPlayer = players.find(p => !p.isAI);
    if (!humanPlayer) {
        console.error('âŒ No human player found. This test is designed for human players.');
        console.log('ðŸ’¡ If you want to test AI steal cards, use testAIStealCards() instead');
        return false;
    }
    
    // Give human player steal cards
    humanPlayer.stealCards = Math.max(2, humanPlayer.stealCards || 0);
    console.log(`âœ… Gave ${humanPlayer.name} (human) steal cards (total: ${humanPlayer.stealCards})`);
    
    // Set up a property for another player to steal
    const otherPlayer = players.find(p => p.name !== humanPlayer.name);
    if (otherPlayer) {
        const testProperty = 't1';
        propertyState[testProperty].owner = otherPlayer.name;
        propertyState[testProperty].ownerColor = otherPlayer.color || getPlayerColor(otherPlayer.name);
        
        if (!otherPlayer.properties.includes(testProperty)) {
            otherPlayer.properties.push(testProperty);
        }
        
        console.log(`ðŸ“ Set ${testProperty} as owned by ${otherPlayer.name} for stealing`);
    }
    
    // Move current player to an unowned property to create purchase decision
    const unownedProperties = ['t2', 't3', 'b1', 'b2', 'b3'];
    let selectedProperty = null;
    
    for (const prop of unownedProperties) {
        if (!propertyState[prop].owner) {
            selectedProperty = prop;
            break;
        }
    }
    
    if (selectedProperty) {
        // Move player to the unowned property
        const propertyInfo = getPropertyInfo(selectedProperty);
        if (propertyInfo && positionsMap && positionsMap.has(selectedProperty)) {
            const position = positionsMap.get(selectedProperty);
            humanPlayer.currentSquare = selectedProperty;
            humanPlayer.x = position.x;
            humanPlayer.y = position.y;
            
            // Set the human player as the current player for the test
            currentPlayerIndex = players.findIndex(p => p.name === humanPlayer.name);
            
            console.log(`ðŸƒ Moved ${humanPlayer.name} to ${selectedProperty} (unowned property)`);
            
            // Simulate landing on the property to trigger purchase decision
            handlePropertyLanding(humanPlayer, propertyInfo);
            
            console.log('ðŸŽ¯ SCENARIO CREATED:');
            console.log(`   - ${humanPlayer.name} landed on ${selectedProperty} (unowned)`);
            console.log(`   - Purchase decision should be pending`);
            console.log(`   - ${humanPlayer.name} has ${humanPlayer.stealCards} steal cards`);
            console.log(`   - ${otherPlayer?.name} owns t1 (available for stealing)`);
            console.log('');
            console.log('ðŸ“ INSTRUCTIONS:');
            console.log('   1. You should see purchase buttons for the property you landed on');
            console.log('   2. WITHOUT making a purchase decision, try to steal a property');
            console.log('   3. Double-click on the t1 property star to steal it');
            console.log('   4. The steal should work even with purchase decision pending');
            console.log('   5. After stealing, you can then make your purchase decision');
            console.log('');
            console.log('âœ… This demonstrates that steal cards work during purchase decisions!');
            
            updateGameFrame();
            updateInfoPanel();
            
            return true;
        }
    }
    
    console.error('âŒ Could not create test scenario - no suitable unowned property found');
    return false;
}

window.testStealCardsDuringPurchaseDecision = testStealCardsDuringPurchaseDecision;

// Documentation function for steal card system
function explainStealCardSystem() {
    console.log('ðŸ“š STEAL CARD SYSTEM GUIDE');
    console.log('==========================');
    console.log('');
    console.log('ðŸƒ WHAT ARE STEAL CARDS?');
    console.log('   Steal cards allow you to take any property from another player');
    console.log('   Each steal card can be used once to steal one property');
    console.log('');
    console.log('ðŸŽ¯ HOW TO GET STEAL CARDS:');
    console.log('   1. Pass GO every 4 times (automatic)');
    console.log('   2. Land on The Witches Grave (when active)');
    console.log('');
    console.log('ðŸŽ® HOW TO USE STEAL CARDS:');
    console.log('   1. It must be your turn');
    console.log('   2. You must have at least 1 steal card');
    console.log('   3. Double-click (or double-tap on mobile) on any owned property');
    console.log('   4. The property will be transferred to you immediately');
    console.log('');
    console.log('âœ… REQUIREMENTS:');
    console.log('   - Must be your turn');
    console.log('   - Must have steal cards > 0');
    console.log('   - Target property must be owned by another player');
    console.log('   - Must double-click directly on the property star');
    console.log('');
    console.log('â­ IMPORTANT: STEAL CARDS WORK DURING ANY GAME STATE');
    console.log('   - You can steal even with purchase decisions pending');
    console.log('   - You can steal even with development decisions pending');
    console.log('   - You can steal even when dice are disabled');
    console.log('   - Steal cards are independent of other game mechanics');
    console.log('');
    console.log('âŒ RESTRICTIONS:');
    console.log('   - Cannot steal unowned properties');
    console.log('   - Cannot steal your own properties');
    console.log('   - Cannot steal during other players turns');
    console.log('   - Cannot steal if you have no steal cards');
    console.log('');
    console.log('ðŸ”§ TROUBLESHOOTING:');
    console.log('   - Run diagnoseStealCardIssues() to check for problems');
    console.log('   - Run enableStealCardTesting() to set up a test scenario');
    console.log('   - Run testStealCardsDuringPurchaseDecision() to test during purchase decisions');
    console.log('   - Make sure you are double-clicking on the property star (colored dot)');
    console.log('   - Check that the game positions are loaded properly');
    console.log('');
    console.log('ðŸ“± MOBILE USERS:');
    console.log('   - Double-tap instead of double-click');
    console.log('   - Tap directly on the property star');
    console.log('   - Make sure you are zoomed in enough to see the property clearly');
}

window.explainStealCardSystem = explainStealCardSystem;

// Comprehensive test for steal card system
function testStealCardSystemComprehensive() {
    console.log('ðŸŽ¯ COMPREHENSIVE STEAL CARD SYSTEM TEST');
    console.log('========================================');
    
    // Run diagnosis first
    const diagnosis = diagnoseStealCardSystem();
    
    if (diagnosis.issues.length > 0) {
        console.log('âŒ Issues detected. Attempting to fix...');
        
        // Fix positionsMap if needed
        if (!diagnosis.hasPositionsMap) {
            console.log('Loading positions...');
            loadPositions().then(() => {
                setPositionsMap(positionsMap);
                console.log('âœ… Positions loaded. Try the test again.');
            }).catch(error => {
                console.error('âŒ Failed to load positions:', error);
            });
            return;
        }
        
        // Set up test properties if needed
        if (!diagnosis.hasOwnedProperties) {
            console.log('Setting up test properties...');
            testStealCard();
            return;
        }
        
        // Give steal cards if needed
        if (diagnosis.currentPlayerStealCards === 0) {
            console.log('Giving current player steal cards...');
            players[currentPlayerIndex].stealCards = 3;
            updateInfoPanel();
        }
    }
    
    console.log('\nðŸ”§ Testing steal card mechanics...');
    
    // Test 1: Check if properties can be detected
    console.log('\n1. Property Detection Test:');
    const testCoords = [
        { x: 100, y: 100, desc: 'Top-left area' },
        { x: 500, y: 300, desc: 'Center area' },
        { x: 900, y: 600, desc: 'Bottom-right area' }
    ];
    
    testCoords.forEach(coord => {
        const nearbyProps = [];
        const detectionRadius = 50;
        
        for (const [square, position] of positionsMap.entries()) {
            const distance = Math.sqrt(
                Math.pow(coord.x - position.x, 2) + 
                Math.pow(coord.y - position.y, 2)
            );
            
            if (distance < detectionRadius) {
                const propertyInfo = getPropertyInfo(square);
                if (propertyInfo && propertyInfo.state.owner) {
                    nearbyProps.push({
                        square,
                        distance: Math.round(distance),
                        owner: propertyInfo.state.owner
                    });
                }
            }
        }
        
        console.log(`   ${coord.desc} (${coord.x}, ${coord.y}):`, 
            nearbyProps.length > 0 ? `${nearbyProps.length} stealable properties` : 'No stealable properties');
    });
    
    // Test 2: Check if current player can steal
    console.log('\n2. Current Player Steal Test:');
    const currentPlayer = players[currentPlayerIndex];
    console.log('   - Player:', currentPlayer.name);
    console.log('   - Is human:', !currentPlayer.isAI);
    console.log('   - Has steal cards:', currentPlayer.stealCards || 0);
    console.log('   - Is their turn:', true); // Always true when testing
    
    // Test 3: Simulate steal card usage
    console.log('\n3. Steal Card Simulation:');
    const ownedProperties = Object.entries(propertyState).filter(([key, prop]) => 
        prop.owner && prop.owner !== currentPlayer.name
    );
    
    if (ownedProperties.length > 0) {
        const [testSquare, testProp] = ownedProperties[0];
        const testPosition = positionsMap.get(testSquare);
        
        if (testPosition) {
            console.log(`   - Target property: ${testSquare} owned by ${testProp.owner}`);
            console.log(`   - Property position: (${testPosition.x}, ${testPosition.y})`);
            console.log(`   - Simulating steal at coordinates: (${testPosition.x}, ${testPosition.y})`);
            
            // Test if the steal would work (without actually doing it)
            const previousOwner = players.find(p => p.name.toLowerCase() === (testProp.owner || '').toLowerCase());
            if (previousOwner) {
                console.log(`   âœ… Previous owner found: ${previousOwner.name}`);
                console.log(`   âœ… Steal would succeed`);
            } else {
                console.log(`   âŒ Previous owner not found for: ${testProp.owner}`);
            }
        }
    } else {
        console.log('   âŒ No properties available to steal');
    }
    
    console.log('\n4. Instructions:');
    console.log('   - Double-click on any property star to steal it');
    console.log('   - Properties with colored stars are owned and can be stolen');
    console.log('   - You can only steal during your turn');
    console.log('   - Each steal uses one steal card');
    
    console.log('\n5. Console Commands:');
    console.log('   - diagnoseStealCardIssues() - Check for issues');
    console.log('   - testStealCard() - Set up test properties');
    console.log('   - players[currentPlayerIndex].stealCards = 3 - Give steal cards');
    
    console.log('========================================');
    
    // Show final advisory message
    if (diagnosis.issues.length === 0) {
        showAdvisory('Steal card system test complete! All systems appear to be working correctly.', 'turn');
    } else {
        showAdvisory('Steal card system test complete. Check console for any remaining issues.', 'info');
    }
}

window.testStealCardSystemComprehensive = testStealCardSystemComprehensive;
window.testMusicStates = testMusicStates;

// --- AI Analysis Panel ---
// IMPORTANT: This analysis is purely read-only and does NOT make any API calls
// It performs local logical analysis of the board state without affecting game data
function showAIAnalysis() {
    const modal = document.getElementById('ai-analysis-modal');
    const content = document.getElementById('ai-analysis-content');
    if (!modal || !content) return;

    // Generate analysis using only local game state - NO API calls, NO game modifications
    const analysis = generateComprehensiveAIAnalysis();
    content.innerHTML = analysis;
    modal.style.display = 'block';
}

function generateComprehensiveAIAnalysis() {
    // SAFETY CHECK: This function only reads game data, never modifies it
    if (!Array.isArray(players) || players.length === 0) {
        return '<h3 style="margin-top:0;color:#fff;">ðŸ§  Local Game Analysis</h3><p>No player data available.</p>';
    }

    let html = '<h3 style="margin-top:0;color:#fff;">ðŸ§  Local Game Analysis Report</h3>';
    html += '<div style="font-size:11px;color:#888;margin-bottom:10px;">ðŸ“Š Analysis performed locally - no external calls, no game state changes</div>';
    html += '<div style="max-height: 400px; overflow-y: auto; padding-right: 10px;">';

    // Overall game state analysis
    const gameState = analyzeGameState();
    html += `<div style="background: rgba(0,100,200,0.2); padding: 10px; border-radius: 5px; margin-bottom: 15px;">`;
    html += `<h4 style="margin: 0 0 8px 0; color: #4CAF50;">ðŸ“Š Game State Overview</h4>`;
    html += `<div style="font-size: 12px; line-height: 1.4;">`;
    html += `Turn: ${currentPlayerIndex + 1} | Phase: ${gameState.phase} | Total Properties Owned: ${gameState.totalPropertiesOwned}/${gameState.totalProperties}<br>`;
    html += `Leading Player: ${gameState.leader.name} (Â£${gameState.leader.money})<br>`;
    html += `Most Properties: ${gameState.propertyLeader.name} (${gameState.propertyLeader.count} properties)`;
    html += `</div></div>`;

    // Individual player analysis
    players.forEach((player, index) => {
        const playerAnalysis = analyzePlayer(player, index);
        const isCurrentPlayer = index === currentPlayerIndex;
        
        html += `<div style="background: rgba(${isCurrentPlayer ? '76,175,80' : '100,100,100'},0.2); padding: 12px; border-radius: 5px; margin-bottom: 12px; border-left: 4px solid ${player.color || '#fff'};">`;
        html += `<h4 style="margin: 0 0 8px 0; color: ${player.color || '#fff'};">`;
        html += `${isCurrentPlayer ? 'ðŸ‘‘ ' : ''}${player.name}${player.bankrupt ? ' ðŸ’€' : ''}`;
        html += `</h4>`;
        
        // Financial status
        html += `<div style="font-size: 12px; margin-bottom: 8px;">`;
        html += `ðŸ’° <strong>Â£${player.money}</strong> | `;
        html += `ðŸ  ${playerAnalysis.propertyCount} properties | `;
        html += `ðŸ“ˆ Net Worth: Â£${playerAnalysis.netWorth}`;
        html += `</div>`;

        // Strategy assessment
        html += `<div style="font-size: 11px; color: #ccc; margin-bottom: 6px;">`;
        html += `<strong>Strategy:</strong> ${playerAnalysis.strategy.type}<br>`;
        html += `<strong>Risk Level:</strong> ${playerAnalysis.riskLevel} | `;
        html += `<strong>Position:</strong> ${playerAnalysis.gamePosition}`;
        html += `</div>`;

        // Property portfolio
        if (playerAnalysis.propertyGroups.length > 0) {
            html += `<div style="font-size: 11px; margin-bottom: 6px;">`;
            html += `<strong>Portfolio:</strong> `;
            playerAnalysis.propertyGroups.forEach(group => {
                const emoji = getGroupEmoji(group.name);
                html += `${emoji}${group.name}(${group.owned}/${group.total}) `;
            });
            html += `</div>`;
        }

        // AI recommendations
        html += `<div style="font-size: 11px; background: rgba(255,193,7,0.2); padding: 6px; border-radius: 3px;">`;
        html += `<strong>ðŸŽ¯ AI Recommendations:</strong><br>`;
        playerAnalysis.recommendations.forEach(rec => {
            html += `â€¢ ${rec}<br>`;
        });
        html += `</div>`;

        html += `</div>`;
    });

    // Market analysis
    const marketAnalysis = analyzeMarket();
    html += `<div style="background: rgba(156,39,176,0.2); padding: 10px; border-radius: 5px; margin-bottom: 10px;">`;
    html += `<h4 style="margin: 0 0 8px 0; color: #E91E63;">ðŸª Market Analysis</h4>`;
    html += `<div style="font-size: 11px; line-height: 1.3;">`;
    html += `Most Valuable Group: ${marketAnalysis.mostValuableGroup}<br>`;
    html += `Best Investment Opportunity: ${marketAnalysis.bestInvestment}<br>`;
    html += `Market Saturation: ${marketAnalysis.saturation}%<br>`;
    html += `Predicted Winner: ${marketAnalysis.predictedWinner} (${marketAnalysis.winProbability}% chance)`;
    html += `</div></div>`;

    html += '</div>';
    return html;
}

function analyzeGameState() {
    const totalProperties = Object.keys(propertyState).length;
    const totalPropertiesOwned = Object.values(propertyState).filter(p => p.owner).length;
    
    // Find leader by money
    const leader = players.reduce((prev, current) => 
        (current.money > prev.money && !current.bankrupt) ? current : prev
    );
    
    // Find property leader
    const propertyLeader = players.reduce((prev, current) => {
        const currentCount = current.properties ? current.properties.length : 0;
        const prevCount = prev.count || 0;
        return currentCount > prevCount ? { name: current.name, count: currentCount } : prev;
    }, { name: 'None', count: 0 });

    // Determine game phase
    let phase = 'Early Game';
    if (totalPropertiesOwned > totalProperties * 0.7) phase = 'Late Game';
    else if (totalPropertiesOwned > totalProperties * 0.4) phase = 'Mid Game';

    return {
        totalProperties,
        totalPropertiesOwned,
        leader,
        propertyLeader,
        phase
    };
}

function analyzePlayer(player, playerIndex) {
    const propertyCount = player.properties ? player.properties.length : 0;
    const netWorth = calculateNetWorth(player);
    const propertyGroups = analyzePropertyGroups(player);
    const strategy = determinePlayerStrategy(player);
    const riskLevel = calculateRiskLevel(player);
    const gamePosition = determineGamePosition(player, playerIndex);
    const recommendations = generatePlayerRecommendations(player);

    return {
        propertyCount,
        netWorth,
        propertyGroups,
        strategy,
        riskLevel,
        gamePosition,
        recommendations
    };
}

function calculateNetWorth(player) {
    let netWorth = player.money;
    
    if (player.properties) {
        player.properties.forEach(propSquare => {
            const propInfo = getPropertyInfo(propSquare);
            if (propInfo) {
                netWorth += propInfo.cost;
                // Add development value
                const propState = propertyState[propSquare];
                if (propState && propState.graveyards) {
                    netWorth += propState.graveyards * (propInfo.graveyardCost || 0);
                }
                if (propState && propState.crypts) {
                    netWorth += propState.crypts * (propInfo.cryptCost || 0);
                }
            }
        });
    }
    
    return netWorth;
}

function analyzePropertyGroups(player) {
    const groups = {};
    
    if (player.properties) {
        player.properties.forEach(propSquare => {
            const propInfo = getPropertyInfo(propSquare);
            if (propInfo && propInfo.group) {
                if (!groups[propInfo.group]) {
                    groups[propInfo.group] = { owned: 0, total: 0 };
                }
                groups[propInfo.group].owned++;
            }
        });
    }

    // Count total properties in each group
    Object.values(propertyState).forEach(prop => {
        const propInfo = getPropertyInfo(prop.square || Object.keys(propertyState).find(key => propertyState[key] === prop));
        if (propInfo && propInfo.group) {
            if (!groups[propInfo.group]) {
                groups[propInfo.group] = { owned: 0, total: 0 };
            }
            groups[propInfo.group].total++;
        }
    });

    return Object.entries(groups).map(([name, data]) => ({
        name,
        owned: data.owned,
        total: data.total,
        completion: data.total > 0 ? (data.owned / data.total * 100).toFixed(0) : 0
    })).filter(group => group.owned > 0);
}

function determinePlayerStrategy(player) {
    const propertyCount = player.properties ? player.properties.length : 0;
    const cashRatio = player.money / (calculateNetWorth(player) || 1);
    
    if (cashRatio > 0.7) {
        return { type: 'Conservative (Cash Hoarder)', description: 'Prefers liquid assets' };
    } else if (propertyCount > players.length * 2) {
        return { type: 'Aggressive Expansion', description: 'Rapid property acquisition' };
    } else if (propertyCount > 0 && cashRatio < 0.3) {
        return { type: 'Development Focused', description: 'Invests heavily in improvements' };
    } else {
        return { type: 'Balanced Approach', description: 'Mixed strategy' };
    }
}

function calculateRiskLevel(player) {
    const cashRatio = player.money / (calculateNetWorth(player) || 1);
    const propertyLeverage = (player.properties ? player.properties.length : 0) / Math.max(player.money / 100, 1);
    
    if (cashRatio < 0.2 || propertyLeverage > 3) return 'High Risk';
    if (cashRatio < 0.4 || propertyLeverage > 1.5) return 'Medium Risk';
    return 'Low Risk';
}

function determineGamePosition(player, playerIndex) {
    const netWorth = calculateNetWorth(player);
    const sortedPlayers = players.map((p, i) => ({ player: p, index: i, netWorth: calculateNetWorth(p) }))
                                 .sort((a, b) => b.netWorth - a.netWorth);
    
    const position = sortedPlayers.findIndex(p => p.index === playerIndex) + 1;
    
    if (position === 1) return 'Leading';
    if (position === players.length) return 'Behind';
    return 'Competitive';
}

function generatePlayerRecommendations(player) {
    const recommendations = [];
    const cashRatio = player.money / (calculateNetWorth(player) || 1);
    const propertyGroups = analyzePropertyGroups(player);
    
    // Cash management
    if (cashRatio > 0.8) {
        recommendations.push('Consider investing excess cash in properties');
    } else if (cashRatio < 0.1) {
        recommendations.push('âš ï¸ Dangerously low on cash - avoid risky investments');
    }
    
    // Property strategy
    const nearCompleteGroups = propertyGroups.filter(g => g.owned / g.total >= 0.5);
    if (nearCompleteGroups.length > 0) {
        recommendations.push(`Focus on completing ${nearCompleteGroups[0].name} group`);
    }
    
    // Development opportunities
    const ownedGroups = propertyGroups.filter(g => g.owned === g.total);
    if (ownedGroups.length > 0 && player.money > 500) {
        recommendations.push('Develop complete property groups for higher rent');
    }
    
    // Risk warnings
    if (player.money < 200 && !player.bankrupt) {
        recommendations.push('ðŸš¨ Bankruptcy risk - sell properties if needed');
    }
    
    // Strategic advice
    if (propertyGroups.length === 0) {
        recommendations.push('Start building a property portfolio');
    }
    
    if (recommendations.length === 0) {
        recommendations.push('Continue current strategy - performing well');
    }
    
    return recommendations.slice(0, 3); // Limit to 3 recommendations
}

function analyzeMarket() {
    // Find most valuable property group
    const groupValues = {};
    Object.entries(propertyState).forEach(([square, state]) => {
        const propInfo = getPropertyInfo(square);
        if (propInfo && propInfo.group) {
            if (!groupValues[propInfo.group]) {
                groupValues[propInfo.group] = { totalValue: 0, owned: 0, total: 0 };
            }
            groupValues[propInfo.group].totalValue += propInfo.cost;
            groupValues[propInfo.group].total++;
            if (state.owner) groupValues[propInfo.group].owned++;
        }
    });
    
    const mostValuableGroup = Object.entries(groupValues)
        .sort((a, b) => b[1].totalValue - a[1].totalValue)[0]?.[0] || 'Unknown';
    
    // Find best investment opportunity
    const availableGroups = Object.entries(groupValues)
        .filter(([name, data]) => data.owned < data.total)
        .sort((a, b) => (b[1].totalValue / b[1].total) - (a[1].totalValue / a[1].total));
    
    const bestInvestment = availableGroups[0]?.[0] || 'None available';
    
    // Calculate market saturation
    const totalProperties = Object.keys(propertyState).length;
    const ownedProperties = Object.values(propertyState).filter(p => p.owner).length;
    const saturation = Math.round((ownedProperties / totalProperties) * 100);
    
    // Predict winner
    const playerScores = players.map(p => ({
        name: p.name,
        score: calculateNetWorth(p) + (p.properties?.length || 0) * 50
    })).sort((a, b) => b.score - a.score);
    
    const predictedWinner = playerScores[0]?.name || 'Unknown';
    const winProbability = Math.min(95, Math.round(60 + (playerScores[0]?.score || 0) / 100));
    
    return {
        mostValuableGroup,
        bestInvestment,
        saturation,
        predictedWinner,
        winProbability
    };
}

function getGroupEmoji(groupName) {
    const emojis = {
        'demon': 'ðŸ‘¹',
        'strangulation': 'ðŸ”ª',
        'torment': 'ðŸ˜±',
        'suffering': 'ðŸ’€',
        'evil': 'ðŸ‘¿',
        'darkness': 'ðŸŒ‘',
        'hell': 'ðŸ”¥',
        'death': 'âš°ï¸',
        'cave': 'ðŸ•³ï¸'
    };
    return emojis[groupName?.toLowerCase()] || 'ðŸ ';
}

function hideAIAnalysis() {
    const modal = document.getElementById('ai-analysis-modal');
    if (modal) modal.style.display = 'none';
}

window.showAIAnalysis = showAIAnalysis;
window.hideAIAnalysis = hideAIAnalysis;

// Debug function to fix player identity in multiplayer
window.fixPlayerIdentityNow = function() {
    console.log('=== FIXING PLAYER IDENTITY NOW ===');
    
    if (!isMultiplayerGame || !players || !Array.isArray(players)) {
        console.log('Not in multiplayer game or no players found');
        return;
    }
    
    console.log('Current state before fix:');
    console.log('- currentPlayerIndex:', currentPlayerIndex);
    console.log('- currentPlayer:', players[currentPlayerIndex]?.name);
    console.log('- localPlayerName:', window.localPlayerName);
    console.log('- input field name:', document.getElementById('player1-name')?.value);
    console.log('- isHost:', isHost);
    
    // Try to match by host status
    const myPlayer = players.find(p => p.isHost === isHost);
    if (myPlayer) {
        console.log(`Found matching player by host status: "${myPlayer.name}"`);
        
        // Update local identity
        window.localPlayerName = myPlayer.name;
        const inputField = document.getElementById('player1-name');
        if (inputField) {
            inputField.value = myPlayer.name;
        }
        
        console.log(`Identity updated: You are now "${myPlayer.name}" (host: ${isHost})`);
        
        // Update UI immediately
        enableDiceSection();
        updateInfoPanel();
        
        // Check if it's now your turn
        const currentPlayer = players[currentPlayerIndex];
        if (currentPlayer && currentPlayer.name === myPlayer.name) {
            console.log('After identity fix, it IS your turn!');
            showAdvisory(`Identity fixed! It's your turn, ${myPlayer.name}. Click dice to roll!`, 'success');
        } else {
            console.log(`After identity fix, it's ${currentPlayer?.name}'s turn, not yours`);
            showAdvisory(`Identity fixed! You are ${myPlayer.name}. Waiting for ${currentPlayer?.name}'s turn.`, 'info');
        }
        
        return true;
    } else {
        console.log('Could not find matching player by host status');
        showAdvisory('Could not fix player identity automatically', 'error');
        return false;
    }
};

// Debug function to check dice state and fix red pulsing issue
window.debugDiceState = function() {
    console.log('=== DICE STATE DEBUG ===');
    
    const diceSection = document.getElementById('dice-section');
    if (!diceSection) {
        console.log('ERROR: Dice section not found');
        return;
    }
    
    console.log('Current dice state:');
    console.log('- Classes:', diceSection.className);
    console.log('- Pointer events:', diceSection.style.pointerEvents);
    console.log('- Computed style pointer events:', window.getComputedStyle(diceSection).pointerEvents);
    
    console.log('Game state:');
    console.log('- isMultiplayerGame:', isMultiplayerGame);
    console.log('- currentPlayerIndex:', currentPlayerIndex);
    console.log('- currentPlayer:', players[currentPlayerIndex]?.name);
    console.log('- currentPlayer bankrupt:', players[currentPlayerIndex]?.bankrupt);
    console.log('- isAITurn:', isAITurn);
    console.log('- isPlayerMoving:', isPlayerMoving);
    console.log('- isRecordingEyes:', isRecordingEyes);
    
    const playerName = document.getElementById('player1-name')?.value.trim();
    const localPlayerName = window.localPlayerName;
    const currentPlayer = players[currentPlayerIndex];
    
    console.log('Player identity:');
    console.log('- Input player name:', playerName);
    console.log('- Local player name:', localPlayerName);
    console.log('- Current player name:', currentPlayer?.name);
    console.log('- Is host:', isHost);
    console.log('- Current player is host:', currentPlayer?.isHost);
    
    const isMyTurn = currentPlayer && (
        currentPlayer.name.toLowerCase() === (playerName || '').toLowerCase() ||
        currentPlayer.name.toLowerCase() === (localPlayerName || '').toLowerCase()
    );
    
    console.log('- Is my turn calculated:', isMyTurn);
    
    // Check if there are any overriding CSS rules
    const allStyles = window.getComputedStyle(diceSection);
    console.log('All computed styles for dice section:');
    console.log('- display:', allStyles.display);
    console.log('- visibility:', allStyles.visibility);
    console.log('- opacity:', allStyles.opacity);
    console.log('- pointer-events:', allStyles.pointerEvents);
    
    console.log('=== END DICE DEBUG ===');
};

// Debug function to force fix dice state
window.forceDiceFix = function() {
    console.log('=== FORCING DICE FIX ===');
    
    const diceSection = document.getElementById('dice-section');
    if (!diceSection) {
        console.log('ERROR: Dice section not found');
        return;
    }
    
    console.log('Before fix - Classes:', diceSection.className);
    console.log('Before fix - Pointer events:', diceSection.style.pointerEvents);
    
    // Remove all pulse classes
    removeAllDicePulseClasses(diceSection);
    
    // Force player color pulse and enable clicking
    const currentPlayer = players[currentPlayerIndex];
    const playerPulseClass = getPlayerDicePulseClassByPlayer(currentPlayer);
    diceSection.classList.add(playerPulseClass);
    diceSection.style.pointerEvents = 'auto';
    console.log(`Applied player color pulse: ${playerPulseClass}`);
    
    console.log('After fix - Classes:', diceSection.className);
    console.log('After fix - Pointer events:', diceSection.style.pointerEvents);
    
    showAdvisory('Dice state force-fixed! Try clicking now.', 'success');
    
    console.log('=== END DICE FIX ===');
};

// Function to clean up duplicate dice sections
function cleanupDuplicateDiceSections() {
    const diceContent = document.getElementById('dice-content');
    if (diceContent) {
        const diceSections = diceContent.querySelectorAll('#dice-section');
        if (diceSections.length > 1) {
            console.log(`[cleanupDuplicateDiceSections] Found ${diceSections.length} dice sections, removing duplicates`);
            // Keep the first one, remove the rest
            for (let i = 1; i < diceSections.length; i++) {
                diceSections[i].remove();
            }
        }
    }
}

// Function to toggle info panel minimize/restore
function toggleInfoPanelMinimize() {
    const infoPanel = document.getElementById('info-panel');
    const infoPanelContent = document.getElementById('info-panel-content');
    const minimizeButton = document.getElementById('minimize-info-panel');
    
    if (!infoPanel || !infoPanelContent || !minimizeButton) {
        console.error('Info panel elements not found');
        return;
    }
    
    const isMinimized = infoPanel.classList.contains('minimized');
    
    if (isMinimized) {
        console.log('ðŸ“± Restoring info panel to full window');
        
        // Clean up any duplicate dice sections first
        cleanupDuplicateDiceSections();
        
        // Remove minimized class and property-decision class
        infoPanel.classList.remove('minimized', 'property-decision');
        infoPanelContent.style.display = 'block';
        minimizeButton.textContent = 'âˆ’';
        minimizeButton.title = 'Minimize';
        infoPanel.style.height = 'auto';
        infoPanel.style.minHeight = 'auto';
        
                        // Restore dice section to original location
                const diceSection = document.getElementById('dice-section');
                if (diceSection && (diceSection.getAttribute('data-original-parent') || diceSection.getAttribute('data-original-parent-id'))) {
                    const storedParentId = diceSection.getAttribute('data-original-parent-id') || 'dice-content';
                    const originalParent = document.getElementById(storedParentId);
                    if (originalParent) {
                        console.log('ðŸ“± Restoring dice to original location:', storedParentId);
                        diceSection.style.cssText = ''; // Reset styling
                        diceSection.removeAttribute('data-original-parent');
                        diceSection.removeAttribute('data-original-parent-id');
                        
                        // Check if dice section is already in the original parent to prevent duplicates
                        const existingDiceInParent = originalParent.querySelector('#dice-section');
                        if (existingDiceInParent && existingDiceInParent !== diceSection) {
                            console.log('ðŸ“± Removing duplicate dice section from original parent');
                            existingDiceInParent.remove();
                        }
                        
                        originalParent.appendChild(diceSection);
                        
                        // Re-enable dice section for normal mode and ensure touch handlers
                        setTimeout(() => {
                            enableDiceSection();
                            
                            // Ensure touch handlers are properly attached after restoration
                            console.log('ðŸ“± Re-applying touch handlers after dice restoration');
                            
                            // Remove any existing listeners first
                            diceSection.removeEventListener('touchstart', handleDiceTouchStart);
                            diceSection.removeEventListener('touchend', handleDiceTouchEnd);
                            
                            // Re-add the standard touch handlers
                            diceSection.addEventListener('touchstart', handleDiceTouchStart, { passive: false });
                            diceSection.addEventListener('touchend', handleDiceTouchEnd, { passive: false });
                            
                            // Also ensure individual dice have handlers
                            const dice = diceSection.querySelectorAll('.die, [id^="die"]');
                            dice.forEach((die, index) => {
                                console.log(`ðŸ“± Re-applying touch handlers to restored die ${index + 1}:`, die.id || die.className);
                                
                                // Remove existing listeners
                                die.removeEventListener('touchstart', handleDiceTouchStart);
                                die.removeEventListener('touchend', handleDiceTouchEnd);
                                
                                // Add touch handlers
                                die.addEventListener('touchstart', handleDiceTouchStart, { passive: false });
                                die.addEventListener('touchend', handleDiceTouchEnd, { passive: false });
                            });
                            
                            console.log('ðŸ“± Touch handlers restored for dice section and', dice.length, 'individual dice');
                        }, 50);
                    } else {
                        console.error('ðŸ“± Original parent not found for dice restoration:', storedParentId);
                    }
                }
        
        // Remove minimized content if it exists
        const minimizedContent = document.getElementById('minimized-content');
        if (minimizedContent) {
            minimizedContent.remove();
        }
        
        // Update the info panel to show full content
        setTimeout(() => {
            console.log('ðŸ“± Calling updateInfoPanel after restore');
            
            // Check game state before updating
            console.log('ðŸ“± Game state check:', {
                players: Array.isArray(players) ? players.length : 'not array',
                currentPlayerIndex: currentPlayerIndex,
                currentPlayer: players && players[currentPlayerIndex] ? players[currentPlayerIndex].name : 'none'
            });
            
            updateInfoPanel();
            
            // Force refresh all content sections
            const playerInfoContent = document.getElementById('player-info-content');
            const propertyInfoContent = document.getElementById('property-info-content');
            const diceContent = document.getElementById('dice-content');
            
            console.log('ðŸ“± Content elements found:', {
                playerInfoContent: !!playerInfoContent,
                propertyInfoContent: !!propertyInfoContent,
                diceContent: !!diceContent
            });
            
            // Ensure necessary sections are visible (player-info-content stays hidden)
            if (playerInfoContent) playerInfoContent.style.display = 'none'; // Always hidden now
            if (propertyInfoContent) propertyInfoContent.style.display = 'block';
            if (diceContent) diceContent.style.display = 'block';
            
            // If game state is not ready, try again later
            if (!Array.isArray(players) || players.length === 0) {
                console.log('ðŸ“± Game state not ready, retrying in 500ms');
                setTimeout(() => {
                    console.log('ðŸ“± Retry updateInfoPanel call');
                    updateInfoPanel();
                }, 500);
            } else {
                // Force a second update to ensure content is populated
                setTimeout(() => {
                    console.log('ðŸ“± Second updateInfoPanel call');
                    updateInfoPanel();
                }, 200);
            }
        }, 100);
    } else {
        // Clean up any duplicate dice sections first
        cleanupDuplicateDiceSections();
        
        // Minimize the panel - show only essential info
        infoPanel.classList.add('minimized');
        infoPanelContent.style.display = 'none';
        minimizeButton.textContent = '+';
        minimizeButton.title = 'Restore';
        
        // Create minimized content with only player info, funds, token, properties, and dice
        const minimizedContent = document.createElement('div');
        minimizedContent.id = 'minimized-content';
        
        // Helper function to safely set innerHTML
        const safeSetInnerHTML = (element, html) => {
            if (typeof window.safeSetInnerHTML === 'function') {
                return window.safeSetInnerHTML(element, html);
            } else {
                try {
                    element.innerHTML = html;
                    return true;
                } catch (error) {
                    console.error('Error setting innerHTML:', error);
                    element.textContent = html.replace(/<[^>]*>/g, '');
                    return false;
                }
            }
        };
        
        // Adjust styles for mobile vs desktop
        const isMobileDevice = isMobile || window.innerWidth <= 768;
        const fontSize = isMobileDevice ? '10px' : '14px';
        const padding = isMobileDevice ? '3px 6px' : '5px 10px';
        const gap = isMobileDevice ? '3px' : '5px';
        
        minimizedContent.style.cssText = `
            padding: ${padding};
            color: #fff;
            font-size: ${fontSize};
            display: flex;
            flex-direction: column;
            gap: ${gap};
            height: auto;
            overflow: visible;
            pointer-events: auto;
            position: relative;
            z-index: 1;
        `;
        
        // Add click debugging to minimized content (throttled to prevent spam)
        let lastClickLog = 0;
        minimizedContent.addEventListener('click', (e) => {
            const now = Date.now();
            if (now - lastClickLog > 1000) { // Only log once per second
                console.log('ðŸ“± Click detected on minimized content:', e.target.tagName, e.target.id || e.target.className);
                lastClickLog = now;
            }
        });
        
        // Get current player info - only show steal cards if any (name, token, money now in bottom-player-display)
        const currentPlayer = players[currentPlayerIndex];
        if (currentPlayer) {
            // Only show steal cards if player has them (other info is in bottom-player-display)
            if (currentPlayer.stealCards && currentPlayer.stealCards > 0) {
                const stealCardsDiv = document.createElement('div');
                stealCardsDiv.style.cssText = 'display: flex; align-items: center; justify-content: center; gap: 8px;';
                
                const stealCardsSpan = document.createElement('span');
                stealCardsSpan.style.cssText = 'color: #00ff00; font-weight: bold; font-size: 12px;';
                stealCardsSpan.textContent = `ðŸƒ ${currentPlayer.stealCards} Steal Card${currentPlayer.stealCards > 1 ? 's' : ''}`;
                stealCardsSpan.title = `${currentPlayer.stealCards} steal card${currentPlayer.stealCards > 1 ? 's' : ''}`;
                
                stealCardsDiv.appendChild(stealCardsSpan);
                minimizedContent.appendChild(stealCardsDiv);
            }
            
            // Skip token section since it's now in bottom-player-display
            if (false) {
                const tokenDiv = document.createElement('div');
                safeSetInnerHTML(tokenDiv, tokenSection);
                minimizedContent.appendChild(tokenDiv);
            }
            
            // Properties owned (compact format)
            if (currentPlayer.properties && currentPlayer.properties.length > 0) {
                const propertiesDiv = document.createElement('div');
                propertiesDiv.style.cssText = 'font-size: 8px; line-height: 1.2;';
                
                // Group properties by color/type
                const groupedProps = {};
                currentPlayer.properties.forEach(propSquare => {
                    const propInfo = getPropertyInfo(propSquare);
                    if (propInfo && propInfo.group) {
                        if (!groupedProps[propInfo.group]) {
                            groupedProps[propInfo.group] = [];
                        }
                        groupedProps[propInfo.group].push(propInfo);
                    }
                });
                
                const propDisplay = Object.entries(groupedProps).map(([group, props]) => {
                    const colorIcon = propertyGroups[group]?.colorIcon || 'â—';
                    return props.length > 1 ? `<span style="font-size: 16px;">${colorIcon}${props.length}</span>` : `<span style="font-size: 16px;">${colorIcon}</span>`;
                }).join(' ');
                
                propertiesDiv.innerHTML = `<span style="color: #ccc;">Properties: ${propDisplay}</span>`;
                minimizedContent.appendChild(propertiesDiv);
            }
        }
        
        // Add dice section (move original, don't clone to preserve events)
        const diceSection = document.getElementById('dice-section');
        if (diceSection) {
            // Check if dice section is already in minimized content to prevent duplicates
            const existingMinimizedDice = minimizedContent.querySelector('#dice-section');
            if (existingMinimizedDice) {
                console.log('ðŸ“± Dice section already exists in minimized content, skipping duplicate');
                // Do not return here, continue to ensure proper state
            }
            
            // Store original parent to restore later
            diceSection.setAttribute('data-original-parent', 'dice-content');
            const diceScale = isMobileDevice ? '0.6' : '0.8';
            const marginTop = isMobileDevice ? '3px' : '5px';
            // Store current pointer-events value before applying new styles
            const currentPointerEvents = diceSection.style.pointerEvents || 'auto';
            diceSection.style.cssText = `margin-top: ${marginTop}; transform: scale(${diceScale}); transform-origin: left center; position: relative; z-index: 1000;`;
            // Ensure dice are always clickable in minimized mode
            diceSection.style.pointerEvents = 'auto';
            
            console.log('ðŸ“± Moving dice to minimized content. Current pointer-events:', diceSection.style.pointerEvents);
            
            // Check if original event listeners are still attached
            console.log('ðŸ“± Checking dice section before move - classList:', diceSection.className);
            
            // Remove any existing click handlers and re-add the main handler
            const originalClickHandlers = diceSection.cloneNode(true);
            console.log('ðŸ“± Cloned dice section for comparison');
            
            // Re-attach the main dice click handler specifically for minimized mode
            let lastClickTime = 0;
            const minimizedDiceClickHandler = async (e) => {
                const now = Date.now();
                
                // Debounce clicks to prevent multiple rapid clicks
                if (now - lastClickTime < 500) {
                    console.log('ðŸ“± Minimized dice click ignored (debounced)');
                    return;
                }
                lastClickTime = now;
                
                console.log('ðŸ“± MINIMIZED DICE CLICKED!', e.target.tagName, e.target.id, e.target.className);
                console.log('ðŸ“± Click coordinates:', e.clientX, e.clientY);
                console.log('ðŸ“± Target element bounds:', e.target.getBoundingClientRect());
                e.preventDefault();
                e.stopPropagation(); // Prevent triggering main handler
                
                // Use unified dice click handler
                await handleDiceClick('minimized');
            };
            
            // Remove any existing event listeners and add the new one
            diceSection.addEventListener('click', minimizedDiceClickHandler, { capture: true });
            
            // Set cursor style for individual die elements but don't add separate handlers
            const die1 = diceSection.querySelector('#die1');
            const die2 = diceSection.querySelector('#die2');
            if (die1) {
                die1.style.cursor = 'pointer';
            }
            if (die2) {
                die2.style.cursor = 'pointer';
            }
            
            console.log('ðŸ“± Added single click handler to dice section for minimized mode');
            
            // Store original dice parent before moving to minimized content
            const originalDiceParent = diceSection.parentElement;
            diceSection.setAttribute('data-original-parent-id', originalDiceParent?.id || 'info-panel-content');
            
            // Also move the turn-info element to show underneath the dice in minimized mode
            const turnInfo = document.getElementById('turn-info');
            if (turnInfo) {
                const originalTurnInfoParent = turnInfo.parentElement;
                turnInfo.setAttribute('data-original-parent-id', originalTurnInfoParent?.id || 'info-panel-content');
                console.log('ðŸ“± Moving turn-info to minimized content along with dice');
            }
            
            minimizedContent.appendChild(diceSection);
            
            // Add turn-info right after dice in minimized content
            if (turnInfo) {
                // Ensure turn-info is visible and properly styled in minimized mode
                turnInfo.style.display = 'block';
                turnInfo.style.visibility = 'visible';
                turnInfo.style.opacity = '1';
                turnInfo.style.fontSize = isMobileDevice ? '10px' : '12px';
                turnInfo.style.margin = '3px 0';
                turnInfo.style.textAlign = 'center';
                
                minimizedContent.appendChild(turnInfo);
                console.log('ðŸ“± Added turn-info to minimized content with enhanced styling in toggleInfoPanelMinimize');
            }
            
            // Ensure dice has correct state after being moved to minimized content
            setTimeout(() => {
                console.log('ðŸ“± Dice moved to minimized content - preserving minimized handlers');
                // Don't call enableDiceSection here as it will replace minimized handlers
                // Just ensure basic clickability
                diceSection.style.pointerEvents = '';
                diceSection.classList.remove('dice-disabled');
                
                // ALWAYS ensure dice has player color pulse in minimized mode
                const hasPlayerColorPulse = ['dice-pulse-player-red', 'dice-pulse-player-blue', 'dice-pulse-player-green', 'dice-pulse-player-yellow', 'dice-pulse-player-purple'].some(cls => diceSection.classList.contains(cls));
                if (!hasPlayerColorPulse) {
                    const currentPlayer = players[currentPlayerIndex];
                    const playerPulseClass = getPlayerDicePulseClassByPlayer(currentPlayer);
                    diceSection.classList.add(playerPulseClass);
                    console.log(`ðŸ“± Added player color pulse class to ensure visibility in minimized mode: ${playerPulseClass}`);
                }
            }, 50);
            
            // Log final dice state
            setTimeout(() => {
                console.log('ðŸ“± Dice in minimized mode - Final state:', {
                    parentElement: diceSection.parentElement?.id,
                    pointerEvents: diceSection.style.pointerEvents,
                    zIndex: diceSection.style.zIndex,
                    position: diceSection.style.position,
                    transform: diceSection.style.transform
                });
            }, 100);
        }
        
        // Insert after header
        const header = document.getElementById('info-panel-header');
        if (header) {
            header.insertAdjacentElement('afterend', minimizedContent);
        }
        
        // Adjust panel height to fit content
        infoPanel.style.height = 'auto';
        infoPanel.style.minHeight = 'auto';
    }
}

// Make the function globally accessible
window.toggleInfoPanelMinimize = toggleInfoPanelMinimize;

// Global debugging function for room issues
window.debugRoomIssue = async function(roomId) {
    console.log(`ðŸ” Debugging room issue for: ${roomId}`);
    
    try {
        // Check if debug functions are available
        if (typeof debugRoomStatus !== 'function') {
            console.error('âŒ Debug functions not available. Make sure firebase-init.js is loaded.');
            return;
        }
        
        const roomInfo = await debugRoomStatus(roomId);
        console.log('ðŸ“Š Room analysis:', roomInfo);
        
        if (roomInfo.success) {
            if (roomInfo.needsCleanup) {
                console.log(`ðŸ§¹ Room has ${roomInfo.invalidPlayers} invalid players that can be cleaned up.`);
                console.log('ðŸ’¡ Run: cleanupInvalidPlayers("' + roomId + '") to clean up invalid players.');
            }
            
            if (roomInfo.isFull) {
                console.log(`ðŸš« Room is full (${roomInfo.validPlayers}/${roomInfo.maxPlayers} players).`);
                console.log(`ðŸ‘¥ Current players: ${roomInfo.validPlayerNames.join(', ')}`);
            }
        }
        
        return roomInfo;
    } catch (error) {
        console.error('âŒ Error debugging room:', error);
        return { success: false, error: error.message };
    }
};

console.log('ðŸ”§ Room debugging utility loaded! Use in console:');
console.log('  - debugRoomIssue("ROOM_ID") // Debug room joining issues');

// Snake path money utility functions
function spawnSnakePathMoney() {
    // In multiplayer games, use deterministic generation based on game start time
    if (isMultiplayerGame && window.gameStartTimestamp) {
        spawnDeterministicSnakePathMoney();
        return;
    }
    
    // Clear any existing money
    snakePathMoney = {};
    
    // Only use specific locations: s8 (snakePath1), TT18 (snakePath2), and u6 (uPath)
    const allowedMoneyPositions = ['s8', 'TT18', 'u6'];
    
    const randomPos = allowedMoneyPositions[Math.floor(Math.random() * allowedMoneyPositions.length)];
    
    // 1 out of 7 times, spawn a steal card instead of money
    const stealCardChance = Math.random();
    const stealCardThreshold = 1/7; // 1 in 7 chance (approximately 0.143)
    
    if (stealCardChance < stealCardThreshold) {
        // Spawn a steal card
        snakePathMoney[randomPos] = {
            isStealCard: true,
            collected: false,
            pulsePhase: 0
        };
        console.log(`ðŸƒ Snake path STEAL CARD spawned on ${randomPos}! (${stealCardChance.toFixed(3)} < ${stealCardThreshold.toFixed(3)})`);
    } else {
        // Spawn money as usual
        const randomAmount = Math.floor(Math.random() * 3 + 1) * 500; // Â£500, Â£1000, or Â£1500
        snakePathMoney[randomPos] = {
            amount: randomAmount,
            collected: false,
            pulsePhase: 0
        };
        console.log(`ðŸ’° Snake path money spawned on ${randomPos} for Â£${randomAmount}! (${stealCardChance.toFixed(3)} >= ${stealCardThreshold.toFixed(3)})`);
    }
    
    updateGameFrame(); // Refresh the display
    
    // Schedule next spawn
    scheduleNextMoneySpawn();
}

// Deterministic snake path money generation for multiplayer synchronization
function spawnDeterministicSnakePathMoney() {
    // Create a seed based on game start time and current spawn cycle
    const baseTimestamp = window.gameStartTimestamp || Date.now();
    const spawnCycle = Math.floor((Date.now() - baseTimestamp) / 120000); // Every 2 minutes
    const seed = baseTimestamp + spawnCycle * 1000;
    
    // Simple seeded random number generator
    function seededRandom(seed) {
        const x = Math.sin(seed) * 10000;
        return x - Math.floor(x);
    }
    
    // Clear any existing money
    snakePathMoney = {};
    
    // Only use specific locations: s8 (snakePath1), TT18 (snakePath2), and u6 (uPath)
    const allowedMoneyPositions = ['s8', 'TT18', 'u6'];
    
    const positionSeed = seed + 1;
    const randomPos = allowedMoneyPositions[Math.floor(seededRandom(positionSeed) * allowedMoneyPositions.length)];
    
    // 1 out of 7 times, spawn a steal card instead of money
    const stealCardSeed = seed + 2;
    const stealCardChance = seededRandom(stealCardSeed);
    const stealCardThreshold = 1/7; // 1 in 7 chance (approximately 0.143)
    
    if (stealCardChance < stealCardThreshold) {
        // Spawn a steal card
        snakePathMoney[randomPos] = {
            isStealCard: true,
            collected: false,
            pulsePhase: 0
        };
        console.log(`ðŸƒ [MULTIPLAYER SYNC] Snake path STEAL CARD spawned on ${randomPos}! (seed: ${seed})`);
    } else {
        // Spawn money as usual
        const amountSeed = seed + 3;
        const randomAmount = Math.floor(seededRandom(amountSeed) * 3 + 1) * 500; // Â£500, Â£1000, or Â£1500
        snakePathMoney[randomPos] = {
            amount: randomAmount,
            collected: false,
            pulsePhase: 0
        };
        console.log(`ðŸ’° [MULTIPLAYER SYNC] Snake path money spawned on ${randomPos} for Â£${randomAmount}! (seed: ${seed})`);
    }
    
    updateGameFrame(); // Refresh the display
    
    // Schedule next spawn
    scheduleNextMoneySpawn();
}

function scheduleNextMoneySpawn() {
    let randomTime;
    
    if (isMultiplayerGame && window.gameStartTimestamp) {
        // In multiplayer, use fixed 2-minute intervals for synchronization
        randomTime = 120000; // 2 minutes
        console.log(`â° [MULTIPLAYER SYNC] Next snake path money will spawn in ${Math.round(randomTime / 1000)} seconds (fixed interval)`);
    } else {
        // In single player, use random time between 1-4 minutes (60000-240000 ms)
        randomTime = Math.floor(Math.random() * (240000 - 60000) + 60000);
        console.log(`â° Next snake path money will spawn in ${Math.round(randomTime / 1000)} seconds`);
    }
    
    nextMoneySpawnTime = Date.now() + randomTime;
    
    // Set timer for next spawn
    if (snakePathMoneyTimer) {
        clearTimeout(snakePathMoneyTimer);
    }
    
    snakePathMoneyTimer = setTimeout(() => {
        spawnSnakePathMoney();
    }, randomTime);
}

window.resetSnakePathMoney = function() {
    // Clear existing money
    snakePathMoney = {};
    
    // Spawn new money immediately
    spawnSnakePathMoney();
    
    console.log('âœ… Snake path money reset and new money spawned!');
};

window.showSnakePathMoneyStatus = function() {
    console.log('ðŸ’° Snake Path Money/Steal Card Status:');
    Object.keys(snakePathMoney).forEach(square => {
        const status = snakePathMoney[square].collected ? 'âŒ COLLECTED' : 'âœ… AVAILABLE';
        const item = snakePathMoney[square].isStealCard ? 'STEAL CARD ðŸƒ' : `Â£${snakePathMoney[square].amount}`;
        console.log(`  ${square}: ${item} - ${status}`);
    });
};

window.addSnakePathMoney = function(square, amount = 1000) {
    if (snakePathMoney[square]) {
        snakePathMoney[square].amount = amount;
        snakePathMoney[square].collected = false;
        snakePathMoney[square].pulsePhase = 0;
        console.log(`âœ… Added Â£${amount} to ${square}!`);
    } else {
        snakePathMoney[square] = { amount: amount, collected: false, pulsePhase: 0 };
        console.log(`âœ… Created new money position on ${square} with Â£${amount}!`);
    }
    updateGameFrame(); // Refresh the display
};

window.randomizeSnakePathMoney = function() {
    // Clear existing money
    Object.keys(snakePathMoney).forEach(square => {
        snakePathMoney[square].collected = true; // Mark as collected to hide
    });
    
    // Only use specific locations: s8 (snakePath1), TT18 (snakePath2), and u6 (uPath)
    const allowedMoneyPositions = ['s8', 'TT18', 'u6'];
    
    const numMoneyPositions = Math.floor(Math.random() * 2) + 2; // 2 or 3 positions
    const selectedPositions = [];
    
    for (let i = 0; i < numMoneyPositions; i++) {
        const availablePositions = allowedMoneyPositions.filter(pos => !selectedPositions.includes(pos));
        if (availablePositions.length > 0) {
            const randomPos = availablePositions[Math.floor(Math.random() * availablePositions.length)];
            const randomAmount = Math.floor(Math.random() * 3 + 1) * 500; // Â£500, Â£1000, or Â£1500
            selectedPositions.push(randomPos);
            
            snakePathMoney[randomPos] = {
                amount: randomAmount,
                collected: false,
                pulsePhase: 0
            };
        }
    }
    
    console.log(`ðŸŽ² Randomized snake path money! ${numMoneyPositions} positions selected:`, selectedPositions);
    selectedPositions.forEach(pos => {
        console.log(`  ${pos}: Â£${snakePathMoney[pos].amount}`);
    });
    
    updateGameFrame(); // Refresh the display
};

console.log('ðŸ’° Snake path money utilities loaded! Use in console:');
console.log('  - resetSnakePathMoney() // Reset money to available state');
console.log('  - showSnakePathMoneyStatus() // Show current money status');
console.log('  - addSnakePathMoney("s5", 2000) // Add money to specific position');
console.log('  - randomizeSnakePathMoney() // Randomly place money on 2-3 snake path positions');